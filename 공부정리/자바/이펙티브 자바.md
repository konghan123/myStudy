- 생성자 대신 정적 팩토리 메서드를 ==고려==하라
	- 정적 팩토리 메서드가 유효한 경우가 있음 (장점)
		- 같은 매개변수를 가지더라도 분간이 될 필요가 있는 경우 (생성 표현을 더 자유롭게 할 수 있음)
			- 생성자는 이름을 가질 수 없기에 매개변수로만 판단이 되기 때문(오버로딩)
			- ex.
			  before![[Pasted image 20240928121104.png]]after![[Pasted image 20240928121043.png]]
		- 객체를 반드시 하나만 가져가야하는 경우
			- 생성자가 public 인 순간부터 다른쪽에서 원하는대로 마음껏 객체를 생성할 수 있게됨
			- 그래서 private 생성자로 지정하고 정적 메서드를 통해 만들어놓은 객체만 가져갈 수 있게 함.
			- ex.![[Pasted image 20240928121705.png]]
		- 매개변수에 따라 각기 다른 인스턴스를 리턴해야하는 경우
			- 정적 메서드 리턴값을 인터페이스로 두고 리턴할때 해당 인터페이스를 구현한 객체를 반환함
			- ex.![[Pasted image 20240928122150.png]]
		- 코드 작성 시 어떤 객체를 쓸지 알 수 없는 상황이기에 인터페이스만을 의존하여 코드를 작성해야하는 경우
			- 작성 시점에 반환할 객체의 클래스가 없어도 됨(서비스 제공자 프레임워크)
			- 인터페이스만을 사용하기 때문에 코드가 더욱 유연함
			- ex.'서비스 로더'라는 자바가 제공하는 메서드를 사용하여 인터페이스에만 의존하여 런타임에 서비스 객체들을 호출함![[Pasted image 20240928123548.png]]
	- 유효하지 않는 경우 (단점)
		- 생성자를 private으로 만들기 때문에 상속이 불가능함
		- 개발자가 찾기 힘듬 (자바 doc기능을 사용하면 편함)
- 생성자에 매개변수가 많다면 빌더를 고려하라
	- 매개변수가 많으면 클래스 코드 및 객체 생성시 불편함이 발생
	- 대안
		- 점진적 생성자 패턴
			- 작은것부터 큰 순서대로 생성자를 넣어주어 중복을 줄임![[Pasted image 20240928141532.png]]
			- 문제점
				- 객체를 생성할때 어떤 매개변수가 어떤 값을 들어가야할지 판단하기 힘듬 (IDE로 어느정도 유추가능)
		- 자바빈스
			- 객체 생성 후 세터를 활용하여 값을 넣어줌
			- 문제점
				- 필수값, 선택값 구분을 못함
				- 불변객체로 만들지 못함
		- 빌더 패턴
			- 자바빈스의 문제점이었던 필수값, 선택값을 나눌 수 있음 (필수값 : builder 생성자, 선택값 : builder를 반환하는 메서드)
			- 자바빈스의 문제점이었던 불변객체로 만들지 못하는 문제도 builder.build()를 통해 해당 클래스 객체를 생성함로 세터 없이 불변 유지가능
			- 사용 권장
				- ==매개변수가 많아지고 불변객체로 유지하면서 필수,선택 필드가 나뉜다면 빌드 패턴을 고려할 수 있다.==
			- 단점
				- 코드가 길어짐 (이 문제는 롬복이 @Builder로 해결해줌)
					- 단 롬복 빌더는 필수, 선택 값을 나눌 수 없음
		- 계층형 빌더 패턴
			- 추상 클래스에 빌더 패턴을 두어 자식 클래스 빌더들을 한곳에 모아서 사용![[Pasted image 20240928144201.png]]
- 생성자나 열거 타입으로 싱글턴임을 보증하라
	- 방법1 : private 생성자 + static final 자기자신 객체
		- 장점
			- 간결하고 싱글턴임을 드러낼 수 있음
		- 단점
			- 해당 싱글턴객체를 필드로 가지는 객체를 테스트하기 어려워짐
				- 그 ==싱글턴 객체를 해당 인터페이스를 구현받게 하여== 테스트 시 해다 인터페이스를 구현한 ==Mock객체==를 생성하여 테스트함
				- 외부 API를 통해서 매핑이 될 경우 테스트마다 외부 API를 불러오는 것은 비효율적이기에 내부에서 Mock객체로 로직을 테스트함 
			- 리플렉션으로 private 생성자를 호출할 수 있음
				- 생성자 호출 시 체크 값을 두어 생성하지 못하게 막음
				- 처음 1번만 생성될 수 있게 만들고 이후 생성시 익셉션![[Pasted image 20240929120630.png]]
			- 역직렬화 할 때 새로운 인스턴스가 생길 수 있음
				- 클래스에 readResolve()를 오버라이딩하여 역직렬화 시 해당 싱글톤 객체를 리턴할 수 있음
	- 방법2: static 메서드를 통해 싱글톤 객체를 호출하는 방식
		- 장점
			- 이후 각각의 객체로 생성이 되어야한다면 다른 코드를 고칠 필요 없이 해당 static 메서드에서 생성자만 추가해주면 됨![[Pasted image 20240930162206.png]]
			- 제네릭타입을 통해 원하는 타입으로 형변환하여 싱글톤 객체를 불러올 수 있음(단 해쉬코드가 다르기 때문에 \==으로 비교할 수 없다![[Pasted image 20240930162403.png]]
			- 해당 static 메서드의 참조를 공급자로 사용 가능함![[Pasted image 20240930163236.png]]
	- 방법3 : 열거 타입 활용
		- ![[Pasted image 20240930163523.png]]
		- 장점
			- 가장 바람직한 방법
			- 열거 타입은 태생적으로 생성자 사용 불가능
			- 리플렉션, 직렬화, 역직렬화에 가장 안전하며 따로 코드로 거를 필요가 없게됨.
				- 리플렉션
					- 리플레션 API 내부에서 열거타입에 대한 생성자 호출을 막아놓았기 때문에 코드추가할 필요가 없음
- 사용하는 자원따라 동작이 달라지는 경우 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
- 불필요한 객체 생성을 피하라
	- 문자열 
		- 생성할 때 new String()으로 생성하지 말기
	- 정규식
		- ![[Pasted image 20241002214716.png]]
		- 유한 상태 머신 알고리즘이 쓰임
		- 패턴을 컴파일하여 인스턴스로 만드는 과정이 오래 걸림
		- 자주 사용되는 정규식인 경우 ==필드에 static으로 선언==하여 사용하는 것을 권장 (10배가량 차이남)
		- 해당 정규식을 매번 컴파일하여 사용하면 생각보다 비용이 크기 때문
	- 오토박싱
		- 반복적인 연산이 많은 경우 래퍼타입보다 원시타입으로 계산하여 불필요한 오토박싱으로 객체를 생성하는 것을 피하여 성능을 높임
		- 성능을 떨어뜨리는 예![[Pasted image 20241002215252.png]]
- 다 쓴 객체 참조를 해제하라
	- 배열, 컬렉션 등 객체들을 계속 쌓아두는 객체가 존재할 때  메모리 누수에 신경써여하며 다 쓴 객체의 경우 참조를 해제해야함
	- 방법
		- 해당 배열을 null로 대입
			- Stack pop() 예시![[Pasted image 20241003124047.png]]
		- Weak 참조값를 이용
			- Weak 참조값을 키로 가지는 Map를 사용 (WeakHashMap)
		- 백그라운드 쓰레드를 이용하여 주기적으로 클린
			- 어떠한 기준을 가지고 해당 객체를 주기적으로 삭제
			- 예시![[Pasted image 20241003130517.png]]
- finalizer, cleaner 사용하지마라
	- 어떠한 오브젝트가 할일을 끝냈을 때(소멸할 때) 사용한 자원들을 반납하기 위한 명령어
	- 심각한 문제가 있음
		- 둘 다 즉시 수행된다는 보장이 없음 (실행이 안될 수 도 있음)
		-  보안 문제
		- 예외 발생 시 정리 작업이 처리 안됨
	- 대안
		- 반납할 자원이 있는 클래스는 AutoCloseable 구현하고 클라이언트에서 close() 호출
		- try-with-resouce를 사용
	- 어떠한 객체의 작업에 대해 정리할 때 내부클래스로 만드는 경우 반드시 정적으로 만들어야한다. 
		- 예시![[Pasted image 20241003153730.png]]
		- 중첩 내부 클래스로 만들 경우 외부클래스의 참조가 생긴다.![[Pasted image 20241003153200.png]]
	- 어떠한 객체의 작업에 대해 정리할 때 내부클래스로 만드는 경우 람다식도 내부클래스 만드는 방식과 비슷하기 때문에 정적으로 만들어야한다.
- try-finally 보다 try-with-resouces를 사용하라
	-  try-with-resouces 사용하면 코드가 더 짧고 간단해짐
		- 둘다 자원 회수 메서드 호출을 보장해줌![[Pasted image 20241005000553.png]]
		- 여러 자원들을 회수할 때 finally 이후 finally를 해야하는 코드 문제가 있음![[Pasted image 20241005000538.png]]
	- 예외를 잡아먹지 않음
		- 이렇게 작성했을 때 try, finally 둘다 예외 에러가 발생하는 경우 마지막 예외만 발생함![[Pasted image 20241005000900.png]]
		- 이렇게 작성할 경우 모든 예외 에러를 확인할 수 있음![[Pasted image 20241005001020.png]]
- equals는 일반 규약을 지켜 재정의하라(equals를 재정의 하지 않는 것이 최선)
	- equals를 재정의 할 필요가 없는 경우
		- 인스턴스가 고유하다( 싱글톤이다 )
		- 인스턴스의 논리적인 값으로 같다는 것을 검사할 필요가 없다
		- 부모클래스의 equals가 자식 클래스에도 적절하다
		- 클래스가 private이거나 equals 메서드를 호출할 일이 없다.
			- 클래스가 private인 경우 밖에서 쓸 수가 없기에 비교할 일이 없음
	- equals를 재정의할 때 신경써야하는 요소
		- 반사성
			- ![[Pasted image 20241005135941.png]]
			- A.equals(A) == true
			- 본인과 본인이 비교했을 때 같아야함
		- 대칭성
			- A.equals(B) == B.equals(A)
			- 반대의 경우에도 같은 결과가 나와야함
			- 다른 타입을 넣어서 equals를 정의할 경우 대칭성이 깨질 수 있음![[Pasted image 20241005004614.png]]
		- 추이성
			- A.equals(B) == B.equals(C) == C.equals(A)
			- 주로 하위클래스가 생길때 이런 문제가 발생
			- 하위 클래스에 필드 값을 추가하여 equals를 재정의하는 경우 무조건 추이성이 깨짐 (이럴 땐 해당 클래스를 상속을 하지 않고 구 클래스를 필드로 가지는 클래스로 만듬)![[Pasted image 20241005133641.png]]![[Pasted image 20241005134736.png]]
		- 일관성
			- 불변객체라면 항상 equals 결과가 같아야함
	- 구현 방법
		- ![[Pasted image 20241005140055.png]]
		- 부동소수점의 영향을 받는 타입들은 자체 비교 메서드를 통해 비교함![[Pasted image 20241005140140.png]]
		- 해당 객체의 핵심이 되는 필드만 비교할 것
- equals를 재정의한다면 hascode()도 같이 재정의하라
	- 두 객체의 equals가 같다면, hashCode의 값도 같아야한다.
	- 두객체에 대한 equals가 다르더라도 hashCode의 값은 같을 수 있지만 해시 테이블 성능을 고려하여 다른 값으로 리턴하는 것이 좋음
	- equals에서 사용한 필드값으로 hashCode를 구현해야함
	- 구현방법
		- Object.hashCode()를 통해 구현
		- 롬복을 이용하여 구현가능
- toString을 항상 재정의하라
- clone 재정의는 주의해서 진행하라 (==사용을 지양==)
	- 클론 != 본체 => 반드시 true
	- 클론.getClass() == 본체.getClass() =>반드시 true
	- 클론.equals(본체) 는 true가 아닐 수 있음
	- 불변객체 clone 구현
		- 예시![[Pasted image 20241007205724.png]]
		- super.clone()을 통해 올라가 Object의 clone()까지 가서 호출됨
		- 재정의 시 super.clone()을 리턴하지 않으면 캐스팅Exception이 발생함
	- 가변객체 clone 구현
		- 불변객체 clone 방식으로 구현 시 내부 필드 값들을 공유하게 됨
			- ex. stack을 카피했을 경우 stack안 배열을 공유하게됨
		- 예시![[Pasted image 20241007211801.png]]
		- 해당 필드 값은 새로 만들어줌
	- clone 재정의 시 주의점
		- clone에서 메서드를 호출한다면 하위 클래스가 해당 메서드를 재정의할 수 없게 만들어야함
		- 멀티스레드에 영향을 받는 클래스라면 clone 메서드의 동기화 필수
		- 추상클래스에서는 clonable을 구현받지 않음
	- ==데이터를 clone할 때는 생성자를 활용하여 clone함==
		- 일반 객체 clone 생성자![[Pasted image 20241007213459.png]]
		- 자료구조![[Pasted image 20241007213245.png]]
		- 장점
			- clone 사용 시 필드값에 final을 붙일 수 없지만 생성자로 clone하면 필드값 final이 가능해짐
			- 상위타입의 데이터를 원하는 객체의 하위 타입으로 받을 수 있음
- Comparable을 구현할지 고민하라
	- 구현방법
		- 여러 필드 값들을 비교한다면 이러한 방식으로 가능함![[Pasted image 20241008141301.png]]
		- 상속 받는 하위 클래스에 Comparable을 구현할 경우 해당 상위 클래스를 상속받지 말고 컴포지션(해당 상위 클래스를 필드로 정의)하여 구현![[Pasted image 20241008141923.png]]
		- Comparator를 만들고 Comparable인터페이스를 오버라이딩한 compareTo 메서드에 해당 Comparator의 compare()메서드를 호출하는 방식으로 진행![[Pasted image 20241008145129.png]]
- 클래스와 멤버의 접근 권한을 최소화하라(구현과 API 분리)
	- 장점
		- 
	- 클래스와 인터페이스 접근제한자 사용 팁
		- 최상단 클래스와 인터페이스에는 package-private(default) 또는 public을 쓸 수 있다.
			- public을 쓸 경우 : API가 됨(밖에서 접근 가능함)
				- 하위 호환성을 유지 (공개되었기 때문에 매번 버전 업할 때마다 호환성 관리가 필요함)
			- package-private을 쓸  경우 : 패키지 외부에서 쓰지 않을 클래스나 인터페이스 (내부구현체)(만약 밖에서 접근할 경우 API를 통해 접근할 수 있음)
	- 한 클래스에서만 쓰이는 클래스의 경우 내부 private static 클래스로 만들자(독립적인 관계)
		- 내부 private static 클래스로 만드는 이유
			- 내부 클래스로만 만들 경우 외부 클래스의 필드에 접근이 가능하게 되어 독립적인 관계가 아니게 된다.
	- 멤버(필드/메서드/클래스) 접근제한자 팁
		- 공개할 API인 경우에만 public, protected로 선언
		- 기본적으로 private, default
		- 생성자의 경우 public
		- public으로 선언되는 필드는 반드시 불변 필드이어야 한다
	- Serializable을 구현한 직렬화, 역직렬화가 가능한 클래스의 경우 private으로 숨긴 멤버들도 노출될 수 있음
- public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
	- 필드로 직접 사용하면 캡슐화의 장점을 제공하지 못함
	- 필드값을 변경하려고 할때 제한을 줄 수 있음
	- 필드 값에 접근할 때 부수적인 작업이 불가능함
- 변경 가능성을 최소화 하라
	- 불변 클래스
		- 한번 만들어지면 해당 인스턴스가 가지고 있는 값, 내부 필드값들이 변경되지 않는 클래스 (소멸될 때까지 값이 변경되지 않음)![[Pasted image 20241010214508.png]]
		- 규칙
			- 객체 상태를 변경하는 메서드 제공 x
			- 클래스를 확장(상속 등)을 할 수 없게 final로 클래스 선언
			- 모든 필드는 private final로 선언
			- 불변 클래스의 필드가 가변 객체를 가질 경우 불변 객체에서 해당 가변객체를 접근할 때 불변 객체 생성 시 복사한 값을 접근할 수 있도록 해야함
		- 장점
			- 함수형 프로그래밍에 적합하다(피연산자 값이 바뀌지 않기에 좀 더 편하게 코딩 가능하다.)
			- 쓰레드 안전
			- 불변 객체끼리는 내부 데이터를 공유할 수 있다.(불변이기에 내부 값에 조합하여 불변객체를 새로 생성하여 반환하게됨)
		- 단점
			- 계속 새로운 불변 객체들이 만들어지는 비용이 있음.
		- 불변 클래스를 만들 때 고려할 점
			- 상속을 못하게 만들 수 있다.(생성자가 private임)
				- 정적 팩토리 메서드로 생성함
				- 해당 팩토리 메서드를 사용하므로서 반환해주는 객체가 유연해짐
				- 해당 클래스 내부에 구현한 static 자식 클래스를 반환해주는 코드로 변경해도 사용하는 외부에서는 알 수 없음 (결국 해당 클래스로 다형성이 성립함)
			- 생성자를 통하는 등 외부에 공개되는 필드는 전부 final이여야한다 (즉, 공개되지 않는 필드는 final이 아니어도 된다(ex. hashcode))
			- 재정의가 가능한 클래스는 방어적인 복사를 해야함 (getClass()를 통해 같은지 비교 후 생성하는 로직이 필요)![[Pasted image 20241010215921.png]]
			- 
- 상속보다는 컴포지션을 사용하라
	- 다른 패키지의 구체 클래스를 상속하는 일은 위험함(상속 자체는 불안전한 작업이다)
		- 상위 클래스에서의 메서드의 로직변경된다면 하위 클래스에서 쓰고 있는 상위 클래스위 메서드들의 로직들도 그에 맞게 모두 변경하여야함
		- 상위 클래스의 메서드를 쓸때 그 메서드에서 대해서 정확히 알고 있어야함 
			- 해당 메서드가 하위클래스에서 재정의한 메서드를 쓰는 경우가 있음
			- 파악이 안되면 예상값과 달라지는 등 사이드 이펙트가 발생할 수 있음
	- 컴포지션 활용
		- 컴포지션 전달 클래스를 만들어서 해당 클래스를 상속하는 하위 클래스를 만들어서 사용 (컴포지션 전달 클래스)![[Pasted image 20241013135309.png]]
		- 이렇게 하여 직접 상속하여 생기는 메서드들의 문제점(캡슐화 깨짐)을 방지할 수 있음 
		- implements를 했기 때문에 인터페이스가 변경되면 바로 알게됨 이후 해당 메서드에 대해 로직을 추가하면 됨
- 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라
	- 재정의 가능한 메서드는내부 구현을 문서로 남겨라
		- 상속을 통해 재정의 된 메서드의 경우 캡슐화가 깨지기 때문에 결국 내부 로직을 구체적으로 알려주어야함![[Pasted image 20241013143712.png]]
- 추상클래스보다 인터페이스를 우선하라
	- 인터페이스의 장점
		- 디폴트 메서드를 추가할 수 있음
		- 계층구조가 불명확한 경우 
			- 상속의 경우 반드시1개만 상속할 수 있기 때문에 명확하지 않은 경우 인터페이스를 통해 다중 상속을 받을 수 있음![[Pasted image 20241013151354.png]]
	- 추상 골격 클래스
		- 인터페이스와 추상 클래스의 장점을 모두 취할 수 있음
			- 기존 인터페이스에서는 모든 메서드를 구현해야했지만 추상 골격 클래스를 통해 필요한 메서드들만 구현가능해짐
			- 구현하지 않은 인터페이스의 디폴트 메서드도 사용가능하다
		- 방법
			- 해당 인터페이스를 구현하는 골격 추상 클래스를 만들어주고 그 추상 클래스에서 구현한 메서드들 중 재정의가 필요한 메서드들만 추상 메서드화 시킴
			- 외부에서 해당 인터페이스 타입으로 반환받을 때 해당 인터페이스를 구현받은 골격 추상클래스를 리턴하여 추상 메서드들만 구현시킴
- 인터페이스는 구현하는 쪽을 생각해 설계하라
	- 기존 인터페이스에 디폴트 메서드 구현을 추가하는 것은 위험함
		- 디폴트 메서드는 기존 구현체에 런타임 오류를 일으킬 수 있음
		- 버그가 일어남
- 인터페이스는 타입을 정의하는 용도로만 사용하라
	- 상수를 정의하는 것은 인터페이스의 본질을 오염시킴
	- 상수의 경우 상수 유틸리티 클래스를 만들어 사용하자
	- 태그 달린 클래스보다는 계층구조 클래스를 활용하라
	- 멤버 클래스는 되도록 static으로 만들어라
		- 멤버 클래스
			- 정적 멤버 클래스
				- 사용 권장
				- 바깥 클래스의 static한 멤버만 접근할 수 있음
				- 바깥 클래스의 인스턴스가 필요하지 않음
				- 바깥 클래스의 도우미 정도로 사용됨
				- ![[Pasted image 20241014203836.png]]
			- 비정적 멤버 클래스
				- 바깥 클래스의 인스턴스를 참조함(암묵적)
				- 바깥 클래스의 인스턴스 없이 해당 인스턴스를 생성할 수 없음
				- 어댑터 패턴에 사용됨
				- ![[Pasted image 20241014203823.png]]
		- 익명클래스
			- 바깥 클래스의 멤버가 아니며 쓰이는 시점과 동시에 인스턴스가 만들어짐
		- 지역클래스
	- 하나의 파일에 클래스는 1개로 유지
		- 컴파일이 꼬일 수 있다. (컴파일을 어떻게 진행하냐에 따라 결과가 달라지게됨)
- 로우 타입을 사용하지 마라
	- 로우 타입
		- 자료구조의 타입을 지정하지 않은 코드![[Pasted image 20241016203244.png]]
	- 제네릭
		- 사용해야하는 이유
			- 런타임이 아닌 컴파일 타임에 문제 찾을 수 있음(컴파일 시 타입 문제에 대해 알려줌) (안정성)
			- 제네릭을 사용하여 생성 시 타입을 지정하여 코드 표현력이 상승 (표현력)
		- 객체 생성 시점에 타입을 지정
		- 와일드카드
			- 로우 타입보다 안전하게 모든 타입을 받기 위한 문법
			- 제네릭으로 타입 지정 시 제네릭 타입 Object는 Object 타입에 해당하는 데이터들만 담을 수 있게됨 (자식은 담지 못함)
			- 하지만 와일드 카드를 쓰면 모든 제네릭 타입을 받을 수 있게됨 (extends, super을 통해 한정적으로 타입을 받을 수 있음)
- 비검사 경고를 제거하라
	- 비검사(unchecked) 경고
		- 컴파일러가 타입 안정성을 확인하는데 필요한 정보가 충분하지 않을 때 발생
		- 컴파일이 실패하진 않음
		- 경고를 제거할 수 없지만 안전하다고 확신한다면
		  @SuppressWarning("unchecked") 애노테이션을 달아서 경고 제거
- 배열보다는 리스트를 사용하라
	- 배열은 공변이다
		- 선언한 타입의 자식들을 모두 담을 수 있다![[Pasted image 20241017204655.png]]
		- 여러 자식 타입을 담을 수 있기에 컴파일 타임에 문제가 발생하지 않고 런타임 시 문제가 생김
		- 성능은 배열이 좋을지 몰라도 안정성이 떨어짐
- 이왕이면 제네릭 타입으로 만들어라
	- 제네릭 클래스를 만들때 생성자에서 제네릭은 생성자를 통해 생성 불가능하기 때문에 Object형으로 생성 후 필드값의 제네릭타입으로 형변환하여 대입하여 생성함
		- 힙오염 발생할 수 있음
		- 이게 자주쓰임
	- 배열로 가지고 있다가 꺼낼때 형변환
		- 꺼낼때마 형변환해야하는 번거로움
- 이왕이면 제네릭 메서드로 만들어라
	- 제네릭 메서드로 만들면 좋은 경우
		- 매개변수화 타입을 받는 정적 유틸리티 메서드
			- 대표적으로 컬렉션 타입을 매개변수로 받는 메서드
			- ex.![[Pasted image 20241020184219.png]]
		- 제네릭 싱글톤 팩토리 메서드
			- 싱글톤 객체를 리턴하는 팩토리 객체
			- ex.![[Pasted image 20241020184736.png]]
- 한정적 와일드카드를 사용해 API 유연성을 높여라
	- 제네릭은 불공변이기 때문에 제네릭을 사용할 시 선언한 타입의 하위타입에 대한 데이터를 넘길 때 컴파일 오류가 발생함(선언한 해당 타입만 가능)
	- 이러한 문제점을 해결하기 위해 한정적인 와일드 카드를 이용하여 ==해당 하위 타입들==에 대한 데이터를 넘길 수 있게 만들 수 있다.![[Pasted image 20241020190006.png]]![[Pasted image 20241020190321.png]]
	- 한정적 와일드카드![[Pasted image 20241020185714.png]]![[Pasted image 20241020190257.png]]
	- 한정적 타입![[Pasted image 20241020185618.png]]![[Pasted image 20241020190312.png]]
- 제네릭과 가변인수를 함께 쓸 때는 신중하라
	- 가변인수를 쓰면 공변인 배열을 매개변수로 받게 되는것인데 제네릭은 불공변이기에 서로 충돌이 생김
	- 차라리 가변인수 대신 리스트로 인수를 받는 것이 좋음
- 타입 안전 이종 컨테이너를 고려하라
- 자바 핵심 공략
	- 열거타입
		- 타입 안정성을 부여함
			- ![[Pasted image 20240928125858.png]]이러한 방식으로 지정하여 개발자가 보기 쉽게 만들 수 있지만 0,2가 아닌 100이 넣어질 경우 컴파일에서 잡아낼 수 가 없기에 타입 안정성이 떨어짐
		- 오로지 객체 1개만 생성되기 때문에 싱글톤으로 만들어짐
		- \\\==으로 비교가 가능하다 (객체가 하나임을 보장하기 때문에 jvm에서 치환하여 판단함)
			- null임에도 비교됨
	- 플라이웨이트 패턴
		- 어떠한 객체를 특정 속성을 자주사용될 때 사용되는 패턴
		- 객체를 가볍게 만들어 메모리 사용을 줄이는 패턴
		- 팩토리를 만들어 하나의 객체를 바라보게끔하여 적용함 
		- ![[Pasted image 20240928131933.png]]![[Pasted image 20240928131945.png]]
	- 인터페이스 메서드
		- 자바 8 이후로 인터페이스에 메서드를 '정의'할 수 있게됨
		- 인터페이스에 메서드를 경우 모든 구현체에 해당 메서드를 구현해야하는 문제가 생기기 때문에 해당 메서드를 구현하지 않은 구현체에 대해 인터페이스에서 정의해놓은 메서드로직을 따르게 됨
		- 인터페이스 정적 메서드
			- 정적 메서드도 정의 가능
			- 일부 유틸적인 메서드를 사용할 때 유용
	- 서비스 제공자 프레임워크
		- 확장 가능한 애플리케이션을 만드는 방법
		- 코드를 건들지 않고 설정 값만 변경하여도 작동하는 방식
		- 내적인 부분이 아닌 외적인 부분만 건들여서 작동
		- 서비스 제공자 인터페이스
			- 여러 구현체들이 만들어질 수 있는 인터페이스
			- 구현체들이 다른 프로젝트에 들어갈 수 있음
	- 리플렉션
		- 클래스로더를 통해 읽어온 클래스 정보를 사용하는 기줄
		- 리플렉션을 통해 클래스를 읽어 객체를 만들거나 메서드를 실행, 필드값 가져오거나 수정 가능
		- 접근 지시자를 무시하기 때문에 private도 가져올 수 있다.
		- 적용 예시
			- 애노테이션이 붙어있는필드 ,메서드 읽기
		- 예시![[Pasted image 20240928141007.png]]![[Pasted image 20240928141035.png]]
		- 
	- 자바빈 스펙
		- GUI에서 재사용을 위한 컴포넌트
		- IDE같은 GUI프로그램에서 자바에서 지정해둔 규약을 통해 메서드 등을 편리하게 접근하여 만들 수 있다.
		- ex. getter, setter, 생성자 
		- 완벽하게 자바빈 스펙에 따를 필요는 없음
	- 객체 프리징
		- 객체가 불변이더라도 프로퍼티가 불변이 아니라면 그 프로퍼티 값을 변경할 수 있기에 그러한 프로퍼티 변경도 방지하는 방법
		- final로 필드를 지정하더라도 그 참조값만 불변일 뿐 그 필드 안의 값은 가변이다.
	- IllegalArgumentException
		- 잘못된 인자를 넘겨 받았을 때 사용할 수 있는 런타임 예외 (언체크드 익셉션)
		- 너무 많은 언체크드 익셉션을 선언하는 거 자체가 코드 가독성을 떨어뜨리기 때문에 체크드 익셉션만 throw 던짐
		- 체크드 익셉션 사용 이유
			- 해당 메서드를 쓰는 상대에게 예외 발생 시 부가적인 작업이 필요하다는 것을 강요할 때 쓰임
	- 가변인수
		- 매개변수에 인수를 가변적으로 줄 수 있는 인수
		- 타입... 매개변수이름
		- 가변인수는 해당 타입의 배열로 반환됨
	- 메서드 참조
		- 어떠한 람다식에서 하는 일이 오로지 메서드 하나를 호출하는 것이라면 간단하게 줄여서 사용할 수 있다.
		- ex. ![[Pasted image 20240930165601.png]]![[Pasted image 20240930165610.png]]
		- 형태
			- static 메서드 형태![[Pasted image 20240930165715.png]]![[Pasted image 20240930165705.png]]
				- 연관된 메서드의 반환 타입이 같아야함
			- 인스턴스 메서드 형태![[Pasted image 20240930165949.png]]
			- 임의 객체 인스턴스 메서드 형태![[Pasted image 20240930171556.png]]
				- 이 경우 매개변수로 자기자신이 이미 있다는 것을 가정함
				- 그래서 compare()의 매개변수는 2개이지만 1개만으로 사용이 가능한것 처럼 보이는 것![[Pasted image 20240930171530.png]]![[Pasted image 20240930171521.png]]
			- 생성자 메서드 형태![[Pasted image 20240930170323.png]]
	- 함수형 인터페이스
		- 함수형 인터페이스 정의 방법
			- 인터페이스를 만들고 거기에 함수 하나만 존재한다면 모두 함수형 인터페이스가 됨
		- 자바에서 제공하는 함수형 인터페이스
			- Function
				- 무엇가 받고 결과를 리턴함
				- 제네릭 타입이 두개
					- 첫번째  : input 타입
					- 두번째  : output 타입
			- Supplier
				- 받는 것이 없고 리턴만 존재
				- 매개변수가 없음
			- Consumer
				- 받는 것은 있지만 리턴은 없음
				- 매개변수 존재
			- Predicate
				- 받고나서 boolean를 리턴함
	- 객체 직렬화
		- 바이트스트림으로 변환한 객체를 파일로 저장 또는 네트워크를 통해 다른 시스템으로 전송
			- 하지만 주로 XML, JSON으로 객체를 변환하여 다른 시스템으로 전송함
			- 다른 시스템에 바이트스트림을 보내도 역직렬화하지못하는 시스템의 경우일 수 있기 때문에 JSON으로 변환하여 보내는 것이 범용적이다.
		- Serializable 인터페이스를 구현한 객체만 가능
		- 객체의 필드에 transient로 선언하여 해당 필드는 직렬화 되지 않게 만들 수 있음
		- static값은 직렬화 되지 않음
		- serialVersionUID
			- 역직렬화 시 해당 객체 타입로 변환하기 위한 구분자
			- Serializable를 구현 시 JVM에서 런타임에 자동적으로 생성해줌
			- 만약 해당 클래스가 변경되었을 경우 런타임 시 자동으로 만들어지는 serialVersionUID도 변경됨
			- 그 부분을 막기 위해 serialVersionUID를 지정할 수 있다.
	- 팩토리 메서드 패턴
		- 어떠한 구체적인 인스턴스 생성을 팩토리 클래스의 메서드에서 생성하여 반환하는 패턴![[Pasted image 20241001153433.png]]![[Pasted image 20241001153456.png]]
		- 단순히 해당 인스턴스의 인터페이스로 사용해도 되지만 만약 인스턴스 생성이 매우 복잡한 경우 한번 더 인터페이스화 하여 진행하는 방식
			- 복잡한 방식 예시![[Pasted image 20241001153359.png]]
	- 스프링 IoC
		- 제어권 역전
			- 인스턴스를 직접 만들지 않거나 메서드를 직접 호출하지 않는 경우
			- ex. 서블릿의 doPost메서드, 스프링 빈
		- 스프링 컨테이너 안에 들어있는 스프링 빈들을 자동적으로 자동적으로 의존성 주입을 해줌
	- Deprecation
		- 사용 자제를 권장하고 대안이 존재하는 코드
	- 정규식패턴
		- 문자열의 matches(), replaceAll(), split()에서 쓰임
		- 자주 쓰이는 패턴은 정적 필드에 선언하자
	- 가바지 컬렉션
		- 기본개념, 옵션, 툴
			- 기본적인 개념
				- Mark
					- 해당 오브젝트가 참조되고 있는지 체크
					- 참조되지 않는다면 가비지컬렉션의 대상이 됨
				- Sweep
					- 필요없는 오브젝트를 힙에서 날림
				- Compact
					- 필요없는 오브젝트를 날려 파편화된 메모리 공간을 정리
				- 오브젝트 관리법
					- 영 제너레이션
						- 짧게 참조될 오브젝트들이 해당영역에서 관리됨
						- 영역구분
							- 에덴영역
								- 오브젝트가 생성되면 해당영역으로 들어옴
							- S0,S1
								- 에덴 영역이 가득차면 해당 영역으로 옮김
								- 영역을 옮기면서 필요없는 오브젝트들을 제거함
					- 올드 제너레이션
						- 오래 참조되는 오브젝트들이 해당영역에서 관리됨
						- S0, S1 영역으로부터 오래 남아있는 오브젝트들이 해당영역으로 옮겨짐
				- Minor GC
					- 영 제너레이션에서만 일어남
				- Full GC
					- 영, 올드 제너레이션에서 일어남
					- 가비지컬렉션의 꽃
					- 알고리즘
						- Serial
							- 직렬
						- Parallel
							- 병렬(쓰레드를 많이씀)
						- Cms
						- G1
						- ZGC
						- Shenandoah
					- 알고리즘 선택 관점
						- Throughput
							- 해당 애플리케이션이 서버의 리소스를 사용하는 크기
							- GC알고리즘이 Throughput에 얼마나 영향을 주는지가 관건
						- Latency
							- 더이상 새로운 오브젝트를 만들 수 없을 때 어플리케이션이 정지하고 GC만 활동함
							- 이 시간이 길어질수록 시스템 장애로 이어짐
							- Latency를 줄이는 것이 관건
						- Footprint
							- GC알고리즘이 동작할때 필요한 메모리 공간을 얼마나 사용하는지
	- Optional
		- 자바 8부터 Optional타입을 통해 NullPointException을 간단하게 처리할 수 있다.(해당 객체가 null일 경우를 간략하게 처리 가능)
		- ![[Pasted image 20241003131525.png]]
		- 변경전![[Pasted image 20241003131841.png]]변경후![[Pasted image 20241003131755.png]]
		- Optional은 매개변수로 넣지 않는 것이 좋다
			- 의미가 없음 결국 안에서 다시 검사해야함 즉, 코드가 늘어남
			- Optional의 리턴타입으로만 써라
		- 자바에서 지원하는 자료구조에 대해서 optional을 사용하지 않는다
			- 빈값에 대해 리턴하는 메서드를 지원함
		- 원시타입은 Optional로 감쌀 수 없기 떄문에 OptionalInt, OptionalLong 등 타입을 이용한다
	- WeakHashMap
		- 더이상 사용하지 않는 객체를 GC할 때 자동으로 삭제해주는 Map
		- Key가 더이상 강하게 참조되는 곳이 없다면 해당 엔트리를 제거함
		- Key값이 무의미해지면 Value도 무의미해지는 곳에 사용 권장
		- WeakReference타입이라고 해서 모든 자료구조에서 GC처리 되는 것이 아니라 WeakHashMap에 그러한 기능이 있는 것뿐!
			- 이러한 자료구조에서는 GC처리가 되지 않음![[Pasted image 20241003140851.png]]
		- 주의사항
			- 커스텀한 객체타입만 사용 가능
				- 기존 원시타입, 래퍼타입은 적용이 안됨
		- 참조의 종류
			- Strong
				- '=' 를 통해 대입하는 참조
				- 더이상 참조되지 않을 때 GC처리
			- Soft
				- 예시![[Pasted image 20241003135611.png]]
				- Strong 참조가 없고 Soft참조만 남았을 때 GC처리 (단, 메모리가 필요한 상황일 때)
			- Weak
				- 예시![[Pasted image 20241003135936.png]]
				- Strong 참조가 없고 Weak참조만 남았을때 무조건 GC처리됨
			- Phantom
				- 더이상 참조가 되지 않을 경우 GC처리되면서 참조큐에 들어감
				- 언제 GC처리되었는지 알 수 있음
	- ScheduledThreadPoolExcutor
		- ExcutorService
			- 한 쓰레드가 여러 일을 비동기적으로 처리할 수 있게 하기 위해 threadPool이 필요한데 그것을 구현하는 객체
			- ExcutorService 객체를 생성할 때 여러가지 ThreadPool들을 쓸 수 있음
				- ex. newScheduledThreadPool, newFixedThreadPool
			- 쓰레드풀의 쓰레드 갯수 고려사항
				- CPU의 갯수
				- I/O 발생 지연시간
			- 변경전![[Pasted image 20241003142823.png]]
			- 변경후![[Pasted image 20241003142805.png]]
		- Callable<타입>
			- 보통 스레드는 Runable을 구현하여 할일을 정의하지만 어떠한 일을 통해서 리턴받을 필요가 있는 경우 Callable을 사용하여 구현![[Pasted image 20241003144136.png]]
			- 이때 리턴타입은 Future이다
	- Finalizer 공격
		- 해당 클래스를 상속 받는 클래스를 만들고 거기에 finalize()를 구현![[Pasted image 20241003154714.png]]![[Pasted image 20241003154735.png]]
		- gc 시 finalize()에서 작업이 일어나면서 해당 클래스의 메서드를 호출함
		- 대안
			- 상속을 막기 위해 클래스에 final를 정의
			- 해당 클래스에 finalize()를 오버라이딩하고 해당 메서드에 final을 붙여 오버라이딩을 허용하지 않음 
	- AutoClosable 인터페이스
		- try-with-resouce를 지원
		- 구현한 객체에 대해 자동으로 close()를 호출함
		- 예시![[Pasted image 20241003155957.png]]
	- Value 기반 클래스
		- Integer, String 처럼 값을 표현하는 클래스
		- 식별자가 없고 불변
			- 값 자체가 식별자
			- 불변이기에 필드는 final
		- VO가 여기에 해당
		- 해당 객체의 필드의 값이 그 객체를 대변함
		- 예시![[Pasted image 20241005141915.png]]
	- 스레드 안전
		- 멀티 스레드 환경에서 안전한 코드
		- 스레드 간에 공유하는 데이터가 없는 것이 베스트
		- 스레드 간에 공유하는 데이터가 있다면
			- 메서드에 synchronized 키워드 추가
				- 자주 호출된다면 성능이 느려짐
			- DoubleCheckedLocking
				- 메서드에 synchronized 키워드 추가하는 것이 아닌 필요한 부분만 블럭으로 동기화 시킴
				- 이때 메서드에 volatile 키워드를 추가해야함
					- 간혹 쓰레드가 CPU 캐시 값을 들고와서 유효하지 않는 데이터를 가져오는 경우가 있기 때문에 메인 메모리에서 값을 들고오게 끔 유도
				- ![[Pasted image 20241005153206.png]]
			- String ThreadLocal
			- 불변 객체 사용
				- 한번 만들고 바뀌지 않으니 쓰레드에 안전
	-  checked, unChecked Exception 선택기준
		- 해당 메서드 사용자가 예외 상황을 복구할 수 있다면 checked Exception 발생 시키고 해당 Exception에 대해추가적인 정보를 제공(해당 예외에 대한 정보)
		- 해당 예외 상황이 발생했을 때 아무것도 할 수 없다면 unChecked Exception
			- 어짜피 처리할 수 없는 예외라면 코드라도 깔끔하게 unChecked Exception을 사용하여 예외를 던지지 않게 끔 만듬
	- TreeSet
		- 사용자 지정의 객체의 경우 Comparable을 구현받은 객체만 가능
		- 동기화가 안됨 (쓰레드 안전하지 않음)
			- 동기화시키기![[Pasted image 20241008135020.png]]
	- 자바 9 모듈 (JPMS)
		- 더 나은 컴포넌트들 간의 관계들을 표현하기 위해
		- 안정성
			- 실행 시 필요한 모든 모듈을 확인
			- 이전에는 오로지 클래스패스로만 관리했음
				- 컴파일 시점에 해당 클래스패스로 해당 클래스가 존재하는 지 유무를 판단할 수 없었기 때문에 런타임 시 해당 클래스가 없다면 오류가 발생
		- 캡슐화
			- public 클래스, 인터페이스 이더라도 공개된 패키지가 아니라면 외부에서 접근하지 못함
		- 확장성
			- 필요한 자바 모듈만 모아서 최적의 JRE를 구성할 수 있음
		- 잘 쓰지 않는 이유
			- 강제성이 없음
				- 모듈파일로 지정하지 않아도 설정파일에 모듈을 디펜던시 추가해버리면 해당 모듈을 사용할 수 있음 
			- 
	- final과 자바 메모리 모델
		- final을 사용하면 안전하게 초기화 할 수 있다
			- 만약 여러 쓰레드가 동작할 때 final을 쓴 필드 값들이 초기화 되기 전까진 생성자를 통해 객체를 생성해도 다른 쓰레드에서 해당 객체를 할당할 수 없으며 그 필드가 초기화될 때까지 프리징하게 됨.
	- 데코레이션 패턴
		- 상속이 아닌 위임(컴포지션)을 사용하서 보다 유연하게 부가 기능을 추가할 수 있음
		- ![[Pasted image 20241013141650.png]]
		- 여기서 HashSet이 concreteComponent, ForwardingSet이 Decorator이다 ![[Pasted image 20241013141612.png]]![[Pasted image 20241013141624.png]]
	- 콜백프레임워크
		- A 메서드에서 매개변수로 받은 B 메서드를 A 메서드 내부에서 원하는 시점에 B 메서드를 호출할 수 있는 것을 말하며 A메서드가 이에 해당됨 (보통 객체를 넘기고 해당 객체의 메서드를 불러오는 방식)
		- 래퍼 클래스를 만들어 사용할 경우 문제가 발생
			-  셀프 문제
			- ![[Pasted image 20241013142723.png]]
			- 사진처럼 this로 넘기는 경우 해당 this는 래퍼클래스가 아닌 bobFunction의 객체가 넘어가게 됨
	- 템플릿 메서드 패턴
		- 템플릿 콜백 패턴, 템플릿 매서드 패턴으로 나뉨
		- 탬플릿 콜백 패턴
			- 추상 클래스는 템플릿을 제공하고 하위 클래스가 구체적인 로직을 제공함
			- 템플릿용 추상 클래스![[Pasted image 20241013153824.png]]
			- 구체적인 로직을 정의하는 하위 클래스(getResult)![[Pasted image 20241013153903.png]]
		- 템플릿 메서드 패턴
			- 굳이 추상클래스를 사용하지 않고 해당 클래스의 메서드에서 매개변수로 구체적인 로직의 메서드를 제공
			- 템플릿 메서드 클래스![[Pasted image 20241013154621.png]]
			- 사용![[Pasted image 20241013154701.png]]
		- 
	- 디폴트 메서드, Object 메서드
		- 인터페이스 디폴트 메서드에는 Object메서드를 정의할 수 없음
		- 모든 클래스는 Object의 자식이기에 Object메서드를 사용할 수 있다. 다만, 인터페이스에도 해당 이름의 메서드가 정의되어있다면 컴파일러는 어떤 것을 참조하여 해당 메서드를 사용해야할지 알 수 없음
		- 
	- ConcurrentModificationException
		- 컬렉션을 순회하다가 어떠한 엘리먼트를 삭제할 때 발생
		- 바뀔 수 없는 객체를 바꾸려고 했을 때 발생
		- 이터레이터로 순회하다가 컬렉션의 메서드를 통해 컬렉션이 변경된다면 그 즉시 예외 발생 (fast-fail)
		- 단 이터레이터를 통해 컬렉션을 삭제한다면 발생하지 않음![[Pasted image 20241014201651.png]]
	- 어댑터 패턴
		- 기존 코드를 클라이언트가 상요하는 인터페이스의 구현체로 바꾸는 패턴![[Pasted image 20241014205547.png]]
		- ![[Pasted image 20241014210458.png]]![[Pasted image 20241014210503.png]]![[Pasted image 20241014210442.png]]
			- 덕에 맞추기 위해 어댑터 클래스를 생성하고 해당 클래스는 맞추기위한 인터페이스를 구현함
			  그 후 터키 타입을 가지는 멤버의 메서드를 구현에 필요한 메서드에 알맞게 넣어줌
			  (기존 기능이 필요하다면 기존 클래스 타입을 지정하여 구현에필요한 메서드를 채운다)
	- 애노테이션
		- @Retention
			- 애노테이션 정보를 얼마나 오래 유지하느냐
			- 설정 
				- 런타임 까지
				- 클래스파일 생성까지
				- 소스코드 까지
		- @Target
			- 애노테이션을 사용할 수 있는 위치
			- 설정
				- 클래스, 인터페이스 
				- 메서드
				- 파라미터
				- 생성자
				- 필드
				- 등등
	- @SafeVarags
		- 생성자와 메서드의 제네릭 가변인자를 사용할 수 있는 애노테이션
		- 굳이 사용 안하는 것을 권장
		- ...은 배열로 받는 것이며 배열은 공변이기에 제네릭의 불공변과 충돌이됨
		- 해당 에노테이션은 무턱되고 붙이는 것이 아니라 리턴하지 않는 메서드의 경우 개발자가 안전하다고 판단하에 비검사 경고를 없애기 위해 쓸 수 있음![[Pasted image 20241017211134.png]]
	- 한정적 타입 매개변수
		- 어떠한 클래스에서 일반적인 제네릭으로 받으면 Object형까지 모두 받을 수 있게 된다
		- 하지만 한정적인 타입을 사용하여 해당 객체 생성 시 받을 수 있는 타입을 제한할 수 있음
		- 그리고 타입을 제한하므로 E에서 사용할 수 있는 메서드는 해당 제한한 타입에 대한 모든 메서드들을 사용할 수 있다. (일반적인 E는 Object의 메서드만 사용가능하다)
		- ![[Pasted image 20241017213438.png]]
	- ThreadLocal
		- 쓰레드 지역 변수
		- 모든 멤버 변수는 기본적으로 여러 쓰레드에서 공유되어 사용될 수 있는데 그것을 각 쓰레드마다 컨테이너를 두어 동기화 없이 멀티쓰레드 환경에서도 원하는 결과값을 도출할 수 있음
		- 사용법
			- 공유되는 값을 ThreadLocal로 묶어서 선언![[Pasted image 20241020195813.png]]
			- 값을 꺼낼 땐 .get(), 값을 수정할 땐 .set()
		- ThreadLocalRandom
			- Random 클래스는 쓰레드 안전한 클래스임은 분명하지만 로직상 멀티쓰레드 환경에서 공유된 값의 변경으로 인해 해당 로직을 재시도하는 경우가 발생할 수 있음. 결국 성능에 영향이 가기 때문에 이러한 재시도를 하지 않는, 한 쓰레드에서만 사용되는 ThreadLocalRandom 클래스가 나오게 됨![[Pasted image 20241020200903.png]]
			- 