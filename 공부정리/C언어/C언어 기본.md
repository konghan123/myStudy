- 자료형
	- 일정 길이의 메모리에 저장된 정보를 해석(형식)하는 방법
	- 자료는 결국 숫자이다 
	- 변수와 상수가 존재
		- 변수
			- 앞으로 변경될 가능성이 있는 수
			- 메모리를 사용하는 가장 일반적인 방법
			- 즉, 메모리가 가지는 특성을 지님 
				- 주소(위치정보)
				- 크기 (공간의 크기)
		- 상수
			- 값이 확정되어 변할 가능성이 없는 수
			- 리터럴 상수 , 심볼릭 상수로 나뉨
				- 리터럴 상수![[Pasted image 20240712211106.png]]
	- 종류
		- ![[Pasted image 20240712210607.png]]
		- 정수형
			- 부호가 존재 (Unsigned 조합은 제외)
			- char형은 문자 '표현'되지만 결국 숫자로 이루어져 있다.(아스킷 코드)
			  그래서 'A' + 3 이 연산이 가능함
			- ![[Pasted image 20240712212121.png]]
		- 실수형
			- 소수점 이하 정보 표시
			- 배정도(double), 단정도(float) 형식이 있지만 배정도형식만 쓴다.
			- 부동 소수점 표현 (두 정수 사이에는 무수 많은 실수가 존재하기 때문에 일정 수준의 오류 (보동 소수점 오차)를 인정함)
				- 부동소수점 오차
					- 근사값 때문에 발생
					- 1.1~1.2사이에도 무수히 많은 실수가 존재하기 때문에 어떠한 한 실수값에 대해 대표하는 실수값으로 표현하기에 오차가 생김
					- 그렇기에 어느정도 오차를 무시하고 실수 연산을 함
			- float형은 쓰지 않음 (오차가 많음)
				- 0.1F를 50번 더한 값이 5가 아닌 4.99998이 나옴
				- 그리고 그 값과 5가 같다고 표현해버리기 때문에 쓰지 않음
- 컴퓨터의 문자 표현
	- 숫자를 문자로 표현함
	- ASCII표준을 기준 표현중 (국제 표준)
		- 글자를 표현하기 위한 숫자
	- 컴퓨터의 모든 정보는 2진 정보 즉, 바이너리 정보이다.
	- 문자열
		- MBCS 셋와 유니코드 셋이 존재
			- 이러한 셋마다 문자 한글자의 바이트가 달라짐
			- 유니코드는 한글 영문 모두 한글자가 2바이트
- 컴파일러 vs 인터프리터
	- 고급어 코드를 기계어 코드로 변역해주는 프로그램
	- 컴파일러
		- 전체 고급어 코드를 모두 기계어로 변환 후 실행
		- 성능최적화에 용이
	- 인터프리터
		- 고급어 코드를 직접 실행
		- 한줄 단위로 실행
		- 한줄 단위로 실행하다보니 성능 최적화가 힘듬
		- 
- Visual studio
	- Visual studio 단축키
		- ![[Pasted image 20240713131629.png]]
	- 솔루션 파일과 프로젝트
		- VS는 여러 프로젝트를 한 솔루션으로 묶어서 관리함
		- 한 프로젝트는 여러 C언어 소스 코드파일을 하나로 묶어서 관리
		- 한 솔루션에 여러 프로젝트 파일이 존재할 경우 '시작 프로젝트'로 설정한 후 실행해야 해당 프로젝트 파일을 실행시킬 수 있음
- 시점
	- 컴파일 타임
		- 소스코드를 목적파일 .obj파일로 번역
		- C언어 소스코드 파일은 .c
		- 목적파일은 .obj
	- 링크 타임
		- 목적파일들과 라이브러리를 실행 파일로 합성
		- 라이브러리 파일은 .lib
		- .obj 와 .lib를 합성하여 .exe 파일 생성 
	- 빌드 타임 (컴파일타임 + 링크타임)
	- 런타임(실행)
- C 언어 기본 코드 세팅 의미
	- ![[Pasted image 20240713140624.png]]
	- '#include<??>' 
		- 컴파일 전 ??을 포함하라
	- 'studio.h'
		- standard Input output 라이브러리
		- .h -> 헤더
- 문자입출력
	- ![[Pasted image 20240714130435.png]]
		- getchar()
			- 키보드 I/O buffer에 쌓여있는 데이터를 하나를 메모리의 어떠한 변수에 대입 
			- Buffered I/O가 일어남
		- putchar(a)
			- 비디오 I/O buffer에 메모리의 a변수 값 또는 지정값 하나 쌓고 출력
			- Buffered I/O가 일어남
		- _ getch() / _ getche()
			- NON-Buffered I/O
			- I/O buffer 를 거치지 않음
			- 키보드 입력 자체를 감지
		- I/O buffer
			- 메모리이다.
			- 큐 형태의 자료구조
			- 입력/출력된 데이터가 선착순으로 연속적으로 쌓여있음
		- ![[Pasted image 20240714131444.png]]
- 문자열입출력
	- 문자열을 가져올때 I/O buffer에서 문자열의 끝을 알리는 값 이전까지 가져옴
		- 문자열 끝엔 항상 끝을 알리는 어떠한 지정된 값이 들어감 (string zero)
		- string zero값이 확인할 때까지 버터에 입력된 값을 가져옴
		- string zero는 일반적으로 null이며 buffer마다 약속된 기호가 존재할 수 있음
		- ![[Pasted image 20240714140757.png]]
	- gets(a) / gets_s(a, 사이즈)
		- 입력된 문자열을 메모리의 변수 a에 대입 
		- 스탠다드 인풋의 데이터를 가져옴
		- 키보드 == 스탠다드 인풋
		- gets()함수의 보안 결함
			- gets()함수는 배열 크기를 넘어서 문자열을 입력한 경우 그대로 메모리에 적재를 해버리기에 그 옆의 다른 변수가 사용하고 있는 메모리에도 영향을 미치게되어 사용하지 않는 것이 좋다.
			- 그것을 보안하여 gets_s(a, 사이즈)가 등장
	- puts(a)
		- 문자열 a변수의 값 또는 지정값을 출력
		- 스탠다드 아웃풋에 출력
		- 스탠다드 아웃풋 == 콘솔
- 형식문자
	- 형식문자에 맞춰서 값을 출력할 때 쓰임
	- ![[Pasted image 20240714142611.png]]
	- 문자형식
		- %nc
			- 문자형식을 n개까지 출력
	- 실수형식
		- %.nf
			- 소수점 n+1번째에서 에서 반올림하고 n자리까지 출력
		- %m.nf
			- 소수점을 포함해 m자리만큼 출력하고 소수점 n+1번째에서 에서 반올림하고 n자리까지 출력
		- float 형식을 쓰는 것을 지양(실수는 무조건 double)![[Pasted image 20240714143610.png]]
- 이스케이프 시퀀스
	- ![[Pasted image 20240714142719.png]]
- 문자, 정수 입력
	- scanf_s(형식문자, 변수주소값, 읽을갯수)
		- scanf는 보안문제로 쓰지 않음
		- 키보드의 입력값이 모여있는 I/O buffer에서 지정한 형식으로 어떠한 변수의 주소값에 입력값을 저장하는데 갯수만큼 저장 
		- 단, %c 로 읽을 때만 갯수를 지정함
		- scanf의 경우 엔터를 쳐서 해당 함수를 끝낸다. 즉, 개행문자가 들어가야 문자열이 끝났다는 걸을 인식한다. I/O buffer에 해당문자열 꺼내져 메모리에 저장되고 개행문자는 남는다.
		  (다른 입력 함수와 혼용하여 썻을 때 문제가 생김)
		- 그래서 %*c를 통해 입력버퍼의 한글자를 제거해주는 형식을 붙임 (ex. %d%*c)
		  
		- ![[Pasted image 20240714144904.png]]
- 연산자
	- 우선순위가 같은 경우 결항성을 따짐![[Pasted image 20240716210225.png]]
	- 정수간의 나눗셈은 정수가 되며 소수점은 절삭됨
	- 연산 시 표현범위가 넓은 형식으로 변경됨 (정수 * 실수 = 실수)
	- 그리고 형식을 표현할 때도 넓어진 형식으로 표현해야 옳바른 값이 표현됨 (연산하여 실수가된 값을 정수로 표현하면 0이됨)
	- 단순 대입 연산자
		- L = R
		- L 에 copy가 일어남
		- L은 무조건 변수 R은 변수, 상수 가능
	- 복합 대입 연산자
		- +=, -=, *=, /= , %=
	- 형변환 연산자
		- 형식을 강제로 변경
		- (형)값
		- 큰형식에서 작은형식으로 형변환할 경우 일부 데이터가 절삭될 수 있다
			- int형의 257을 char로 변경하면 값이 1이됨
		- 형변환에 따른 연산
			- 5/2 = 2
			- (double)5 / 2 = 2.5
			- (double)(5/2) = 2.0
	- 단항 증감 연산자
		- 전 / 후 위 연산으로 나뉨
			- 후위 연산의 경우 연산 우선순위가 가장 낮음
			- n = 2
			- ex. n = ++x 
				- n = 3 x=3
			- ex. n = x++
				- n=2 x=3 
				- 즉, 대입부터 일어나고 그다음 1증가되는 연산이 일어남
	- 비트 연산자
		- 자료를 비트 단위로 논리 식을 수행
		- 보통 2진수로 변환하여 판단
		- 값에 0x가 들어가면 16진수로 본다는 뜻
		- AND(&), OR(|), NOT(~), XOR(^), Shift left(<<), Shift right(>>)
		- NOT은 단항 연산, 나머지는 2항 연산
		- 비트 마스크 연산
			- 데이터에서 특정 영역의 값이 모두 0이 되도록 지우는 연산
			- AND 특징을 이용
			- 0과 AND 연산을 수행하면 결과는 무조건 0이다.
		- 비트연산![[Pasted image 20240718212743.png]]
		- 엔디안
			- 바이트 단위로 메모리를 읽어올 떄 순서대로 읽지 않음![[Pasted image 20240718213716.png]]
			- 리틀엔디안
				- 주소값이 큰쪽에서 작은쪽으로 읽는 방식
			- 빅엔디안
				- 주소값이 작은쪽에서 큰쪽으로 읽는 방식
			- ![[Pasted image 20240718213927.png]]
	- sizeof 연산자
		- 피연산자의 자료형에 대해 수행
		- 해당 피연산자의 메모리 크기를 계산해줌
		- sizeof(피연산자)
		- sizeof(5) == sizeof(int)
			- 5는 정수이기에 int형과 같다
		- 배열도 적용 가능
			- ![[Pasted image 20240718215338.png]]
		- sizeof 연산은 컴파일 타임에 연산하기 때문에 런타임에 연산되지 않는다 
		  (즉, CPU를 쓰지 않는다)
		  (실행되는 시기에 한번만 연산됨)
	- 관계 연산자
		- 실수형에 대해 상등, 부등 연산은 하지 않는 것이 좋다
		  (비교 연산자는 괜찮지만 => 의 경우 '=' 기준에 대한 오차가 존재할 수 있음)
			- 실수형은 부동소수점에 따른 오차가 존재하기 때문
		- 0은 false , 1은 true
	- 논리 연산자
		- || ,  &&
		- 왼쪽부터 등장하는 연산식을 먼저 수행 후 이어지는 연산식을 수행
		- !변수 
			- true -> false , false -> true가 됨
			- 이 경우 0이 아닌 값은 false가 되므로 0이 됨
			- 0인 값은 true가 되므로 1이 됨
		- Short circuit
			- 논리식은 왼쪽부터 시작됨 
				- 논리합의 경우 
					- 어느 지점에서 true가 되면 이후 논리식은 수행하지 않음
					- false라면 나머지 모든 논리식을 확인
				- 논리곱의 경우 
					- 어느 지점에서 false가 되면 이후 논리식은 수행하지 않음
					- true라면 나머지 모든 논리식을 확인
			- 팁
				- 논리합 논리곱이 섞여있을 때 논리합을 기준으로 묶으면 됨
				- 빠르게 연산되는 논리식을 앞으로 두는것이 성능상 좋음
	- 삼항 연산자
		- 논리적 오류를 피하려면 삼항 연산의 피연산자들은 괄호로 묶는 것이 좋음
- 기본 제어문
	- if
	- switch-case
		- == 상등연산만 가능
		- 조건식 결과는 반드시 정수
	- 무조건 goto
		- 사용을 권하지 않음
		- 사용할 일이 거의 없음
		- 순수 C로 리소스 클리어할 때 쓰임
- 반복문
	- while
		- 조건기반 반복
		- 어떠한 조건이 만족될 때까지 반복
	- for
		- 계수 기반 반복
	- break
		- 반복문에 사용되며 수행 시 스코프를 즉시 벗어나 다음 구문으로 이동
		- 조건과 상관 없이 반복문 종료
	- continue
		- 반복문에 사용되며 수행 시 이후 구문을 실행하지 않고 반복시작으로 넘어감
		- 안쓰는 것이 좋다
- 배열
	- 배열의 이름은 0번 요소의 메모리 주소에 대한 식별자이며 이름 그 자체가 주소이다.
	- 배열의 이름은 상수이다.
	- 배열[인덱스]는 변수이며 해당 인덱스에 존재하는 값을 불러옴
	- 문자열
		- char[] 이다
		- 문자열 상수란 쓰기가 허용되지 않는 이름이 없는 char[]
		- 문자열 끝은 반드시 null이 들어감!!
			- 즉, hello의 문자열 갯수는 6개이다 
			- h , e, l, l, o, null
	- 버블정렬
		- 효율이 좋지 않음
		- 기준점과 요소 하나하나 비교하여 교환 반복하여 정렬
		- 굳이 교환하지 않아도 되는 값을 교환하게됨
	- 선택정렬
		- 효율이 좋지 않음
		- 하나의 기준점에 대해 요소의 최소값이 담긴 인덱스만 기억하고나서 하나의 기준점에 대한 비교가 끝난 이후 해당 인덱스의 값과 기준값을 교환 반복하여 정렬
	- 다차원 배열
		- list, list[]둘다 주소값이 됨
	- Lookup 배열
		- Map처럼 쓰이는 배열
		- 많이 쓰이는 기법
		- 인덱스에 대한 어떠한 값을 주어져 의미를 부여
			- 나이(인덱스)에 대한 할인율(값)
		- 해당 lookup 배열의 값에 접근하여 바로 연산
- 함수
	- 실행의 단위
	- main()은 자동으로 호출됨
	- main()에서 add()라는 함수를 호출했을 경우 main()는 caller(호출자) add()는 callee(피호출)이라고 한다.
		- 이러한 함수들의 호출, 피호출 관계를 규정하는 것을 '바인딩'라고 부름
	- 호출된 함수에서 return을 만나면 호출자에게 제어의 흐름이 돌아감
	- 함수이름은 주소이다.
		- 실행코드(기계어)가 저장된 메모리 주소이다
		- 해당 메모리는 오직 읽기밖에 되지 않는다
	- 함수()에서 '()'는 함수를 호출하는 연산자이다.
	- 이벤트 루프
		- 사용자 인터페이스 출력 및 사용자 입력을 반복하는 구조
		- 메뉴 출력과 사용자 선택
		- ![[KakaoTalk_20240722_175818651.png]]
		- 응용프로그램이 이벤트 루프의 구조로 진행 중 무언가 연산이 길게 걸리고 입력대기가 일어나는 경우 운영체제에서 '응답없음'으로 표기됨
- 함수 원형 선언
	- 함수의 선언과 정의를 분리
	- ==컴파일러에게 함수의 존재를 알리기 위해== 코드 상단에 기술
	- 함수 시그니처라고도 함
	- 함수 원형 선언 시 매개변수의 이름은 필요없다
	- 코드 상단에 선언만 하여 해당 함수가 존재한다는 것을 컴파일러에게 알림 이후 밑에 함수에 대한 정의를 지정![[KakaoTalk_20240723_173250586.png]]
- 분할 컴파일
	- 한 프로젝트에 여러 소스코드 파일(.c)을 운영할 때 각각 개별로 컴파일
	- 변수나 함수 선언과 정의가 다른 파일로 분리됨
	- 이러한 분할 컴파일을 통해 다른 소스코드 파일의 함수를 호출하여 사용할 수 있다.![[KakaoTalk_20240723_173250586_01.png]]
	- 소스코드 파일이 각각 컴파일(분할 컴파일)을 통해 obj파일로 변환되고 그것들을 ==링크작업==을 통해 합치게됨
	- 합치는 과정(링크작업)에서 이름이 중복되는 함수가 존재할 경우 링크 오류가 발생
	- ![[KakaoTalk_20240723_173250586_03.png]]
- 전역변수
	- 함수바디 밖에 선언
	- 정적 메모리를 사용함
	- 변수 검색 우선 순위(변수 이름이 겹칠 경우)
		- 1. 지역스코프 (지역 변수가 최우선)
		- 2. 최대 함수 바디(가장 근본 함수 바디)
		- 3. 최대 로컬 바디(접근자 코드가 들어있는 소스파일 전역변수)
		- 4. 외부 파일
	- 다른 파일에 해당 변수가 존재하는 경우 전역변수 앞에 'extern'을 붙여주어 원형선언한다.
		- 기본적으로 전역변수 선언 시 'extern'이 생략됨
		- ![[KakaoTalk_20240723_173250586_04.png]]
- 메모리
	- CPU는 연산할 코드와 대상 정보를 모두 메모리로 가져옴
	- 메모리는 변수를 통해 사용
	- 모든 메모리는 고유한 주소를 가짐
	- 메모리 종류 (가상메모리)
		- stack (지역변수)
			- 일반적인 지역변수는 모두 자동변수
			- 생겻다 사라졌다를 반복
			- 쓰레드마다 고유의 stack영역을 가짐
			- 1MB정도의 크기이다 (넘으면 stackOverFlow 에러 생김)
		- heap(런타임 시점(동적) 메모리를 할당 받은 영역)
			- 대표적인 메모리 관리함수(malloc(), free())
				- OS에게 동적으로 메모리를 할당 받고 반납하는 함수
		- 실행코드(PE)
			- text 섹션(실행될 기계어 코드가 포함됨)
			- data 섹션
				- 정적 메모리 (전역변수)
					- 프로그램 시작시 확보되는 영역
					- 프로그램이 끝날 때까지 유지됨
					- extern
					- static
						- 신중히 써야함
						- 지역변수처럼 지정했지만 static이 붙으면 전역변수같이 작동함![[Pasted image 20240801211605.png]]
						- 값을 공유함
					- 동시성 이슈가 존재함
				- 읽기 전용 문자열 상수
					- hello world
- 포인터 변수
	- 메모리 주소를 저장하기 위한 전용 변수
	- 64비트 시스템에서 주소값은 8byte이다.
	- 문법 : 자료형* 변수이름
		- ex. char* data = 주소값 or &변수
			- data 포인터 변수의 주소값 안의 value를 가져오고 싶다면
			  '\*data' 이렇게 씀
			- ![[Pasted image 20240723225134.png]]
	- 어떠한 변수 앞에 '&'가 오면 해당 변수의 주소값을 가르킴 
	- 지정
		- 직접지정
			- 특정 메모리 공간을 상수로 지정
		- 간접지정
			- 특정 메모리 공간을 포인터 변수로 지정
			- \*\*변수값를 뜻함
	- 포인터 변수 메모리로 본 값
		- 이러한 코드가 있을 때 ![[Pasted image 20240723215103.png]]
		- nData의 주소값과 값![[Pasted image 20240723215041.png]]
		- pnData의 주소값과 값![[Pasted image 20240723215130.png]]
		- 리틀 엔디안을 쓰고 있기 때문에 반대로 읽음
	- 포인터와 1차원배열
		- 배열형식에 대한 포인터는 해당 배열 자료향으로 관리
			- char[] -> char*
			- int[] -> int*
		- int* pnData = aList   ===  int* pnData = &aList[0] 
		- 배열의 포인트 변수에 간접지정을 하면 배열값이됨.![[Pasted image 20240723222511.png]]
		- 배열에 대한 증감
			- 배열 주소값 자체에 1 증가
			- 즉, 증가된 만큼의 요소로 가르킴
	- 배열연산자와 포인터 연산
		- A[0] == \*(A + 0) 과 같다
	- 문자열 복사, 비교, 검색
		- 복사 : strcpy_s()
			- strcpy_s(복사받을 주소, 값 크기, 복사할 주소)
			- 깊은 복사
		- 비교 : strcmp()
			- strcmp(비교할 문자열 값 주소1, 비교할 문자열 값 주소2)
			- 0이면 같다는 뜻
			- 1, -1 이 나오면 같지 않다는 뜻
		- 검색 : strstr()
			- strstr(검색할 문자열 값 주소, 비교할 문자열)
			- 주소를 반환
	- realloc()
		- realloc(동적할당 받은 주소, 크기)
		- 기존에 할당 받은 메모리의 크기를 조정하여 다시 할당
		- 메모리 chunk(블록) 크기 조절에 실패할 경우 전해 새로운 위치로 이동
- 함수
	- 매개변수
		- C언어에서 매개변수 참조형은 포인터로 구현
		- 매개변수는 stack영역을 사용(단, 64bit인 경우 CPU의 register를 사용함)
		- 매개변수가 여러개인 경우 stack, register에 오른쪽부터 할당됨
		- 함수에서 리턴값이 하나밖에 없는 이유는 반환값은 eax라는 레지스터에 저장되는데 해당 레지스터는 하나 뿐이기 때문이다.
		- call by value
			- ![[Pasted image 20240802173756.png]]
		- call by Referrence
			- 주로 여러값들을 매개변수로 넘길때 사용(배열)
			- ![[Pasted image 20240802173715.png]]
	- 지역변수 주소 반환 오류
		- 함수의 지역변수는 함수의 반환과 함께 모두 소멸
		- 함수가 주소를 반환할 경우 stack의 주소값을 반환하지만 해당 값은 보장 받을 수 없다.
			- stack영역은 생성 소멸을 반복하기 때문에 처음에 10인 값을 담은 주소를 반환햇지만 이후 로직이 진행되면서 stack영역의 해당 주소에 5라는 값으로 덮히면 10이 아닌 5값으로 담겨있게됨
			- ![[Pasted image 20240802175249.png]]
			  stack영역의 특성(생성, 소멸)으로 인해 해당 주소를 반환받았지만 함수가 호출되어 지속적으로 생성 소멸이 반복하면서 그 주소의 값이 변경될 수 있음
	- 메모리 동적 할당 이슈
		- 포인터의 근본적 문제점이 존재
			- 할당된 메모리 크기에 대해 알 수 없음
				- 포인터는 그 주소를 가르킬뿐
				- 해결방법
					- 매개변수에 사이즈 값을 반드시 지정
			- 반환받은 값이 동적 할당 받은 포인터 인지 알 수 없음
				- 해결방법
					- 개발 문서를 잘써야함
					- 가비지컬렉터 구현
	- 재귀호출
		- 함수 코드 내부에서 다시 자신을 호출
		- 재귀호출은 같은 함수를 stack에 반복하여 계속 쌓기 때문에 논리 오류시 stack overflow가 발생함
	- 문자열 처리 표준 함수
		- strtok_s()
			- 문자열을 구분하여 구분값에 대한 문자를 null로 만듬
			- 대상문자열에 쓰기가 일어남 (원본 데이터가 변경됨)
		- strpbrk()
			- 문자열에서 지정한 문자의 위치를 찾아내어 주소 반환
		- strcat_s()
			- 두 문자열을 이어붙임
			- 뒤에 이어붙임
			- 성능을 보완하기 위해 문자열 끝 주소를 넣어준다 (함수 내부에서 문자열 끝을 찾기 위해 반복문을 돌리기 때문)
	- 가변길이 입력에 의한 stack frame 손상
		- 가변길이 입력으로 인해 stack 내에서 지역변수 주소값을 침범하여 지역변수 데이터가 변경됨
		- 함수![[Pasted image 20240803121517.png]]
		  결과![[Pasted image 20240803121558.png]]
		- 원인 : TestTest라는 값을 넣으면서 문자열 끝을 알리는 null값이 nData주소를 침범하여 오버라이트하게됨![[Pasted image 20240803121749.png]]
	- 유틸함수
		- atoi()
			- 아스킷 to integer
			- 문자열을 정수형으로 변경
			- atol(), atof() 도 문자열을 어떠한 다른 형으로 변경시키는 함수
		- time()
			- 1970.1.1일 이후부터 현재 몇초가 지났는지 알려주는 함수
			- localtime(), ctime() 을 통해 해당 초값을 알아볼 수 있는 시간 값으로 변경
		- rand()
			- 보통 rand()함수 매개변수에 time()값을 넣음
			- 특정 경우의 수를 구하고 싶다면 rand() % 개수 를 하여 한정된 경우의 수를 구할 수 있음
- 구조체
	- 특징
		- 여러 자료형을 모아 새로룬 하나의 형식으로 선언
		- 구조체는 여러 자료형들이 모인것 (배열은 같은 자료형만이 모인것)
		- 구조체는 새로운 사용자 정의 형식으로 작동
		- 구조체도 다른 구조체의 멤버가 될 수 있음
			- ![[Pasted image 20240803133608.png]]![[Pasted image 20240803133641.png]]
			- 자기 참조 구조체
				- 자기 자신에 대한 포인터를 멤버로 갖는 구조체![[Pasted image 20240803134034.png]]![[Pasted image 20240803134048.png]]
			- ![[Pasted image 20240803133557.png]]
	- 목적 
		- 단위로 데이터를 관리하기 위해 (DB의 1개의 레코드)
	- 구조체 정의![[Pasted image 20240803130228.png]]
	- 구조체 선언![[Pasted image 20240803130245.png]]
		- 선언과 동시에 멤버 초기화 가능
		- 정의 시 typedef를 붙이면 선언 시 struct를 안붙여도 됨
	- 메모리 동적할당을 통해 포인터로 관리할 수 있음
	- 구조체 멤버
		- 구조체를 이루는 요소
		- 멤버 접근
			- 구조체가 원시형 : ' . '![[Pasted image 20240803130455.png]]
			- 구조체가 포인터 : ' ->'![[Pasted image 20240803132104.png]]
	- 구조체 매개변수, 반환의 유의점
		- 구조체 자체가 메모리를 크게 잡기 때문에 매개변수, 반환으로 구조체 자체를 넘길 경우 stack 메모리를 많이 쓰게됨
		- 그래서 포인터로 해당 구조체의 주소만 넘기는 것이 좋음(주소로 넘겼기 때문에 반환도 필요없어짐)
	- 비트필드
		- 1바이트 정보를 쉽게 잘라 쓰기 위한 문법
		- 멤버는 비트 단위 데이터
		- 메모리의 오른쪽부터 왼쪽으로 메모리가 쌓임
		- 각 멤버는 숫자에 해당하는 비트를 가짐 (8비트이기에 3이 최대)
			- 1 : 2^1
			- 2 : 2^2
			- 3 : 2^3
		- 오버해
		- 예시![[Pasted image 20240803135123.png]]
	- 구조체 멤버 맞춤
		- 구조체를 이루는 멤버의 메모리 공간은 관리 편의를 위해 완전히 연접하지 않고 일정 단위로 메모리를 구성 (변수 사이 메모리 공백이 존재할 수 있음)
		- 변수마다 공백이 생김
		- 공백을 없애야하는 경우 전처리기로 설정
		- 컴퓨터는 단위마다 처리하는 것이 편하기 때문에 이런 현상이 생김
		- 10바이트 구조체지만 16바이트를 차지하게됨![[Pasted image 20240804110435.png]]
- 공용체
	- 한 대상에 대해 여러 자료형을 부여하는 문법
	- 하나의 변수를 여러 자료형으로 묶어서 사용 가능
	- 공용체 정의(4바이트 int형을 2바이트 2개의 short형 1바이트 4개의 char형으로 표시)![[Pasted image 20240804105411.png]]공용체 선언![[Pasted image 20240804105437.png]]
	- 
- 파일 시스템
	- 2차 메모리(보조기억장치)를 관리하는 방법 중 하나
	- 논리적 분할
		- 물리적으로 1개인 디스크를 논리적으로 여러 디스크로 분할
	- 디렉토리와 파일 존재
		- 경로 개념이 들어감 (절대 경로, 상대 경로)
	- 파일
		- data 단위
		- ==프로세스가 접근하는 대상==
		- 기본적으로 RWX (읽기, 쓰기, 실행)
		- 프로세스가 파일에 접근할 때 open을 하고 다 썻으면 다른 프로세스가 접근할 수 있게 close해야함
		- 여러 프로세스가 존재하는 시스템에서 파일에 대한 동시접근 시 데이터가 엉키는 문제가 생김
		- 일반적으로 장치를 추상화한 파일, 데이터 파일 등 2가지 종류가 존재
			- 장치를 추상화한 파일 (ex. 콘솔 == 모니터장치 + 키보드 장치)
		- 파일 생성 시 크기 지정 필요없이 생성 가능 (처음 생성할 때 크기가 0)
		- 파일에 write시 write한 크기만큼 크기가 늘어남
		- 한개 파일이 가질 수 있는 크기는 운영체제의 파일시스템에 따라 다름 (파일 시스템이 규정한 크기만큼 가능)
		- 파일은 스트림 구조이다
			- 파일 스트림
				- 파일 단위의 스트림
				- 스트림이란?
					- 1차원적인 선형구조이며 빈틈없이 연속되어 있음
					- 시작 지점과 끝 지점이 있음
					- ![[Pasted image 20240804120603.png]]
		- 파일명은 파일이름과 확장명으로 구성
		- 파일 형식은 바이너리와 텍스트로 나눔
			- 텍스트는 바이너리에 포함된다고 볼 수 있음
			- 텍스트 파일 
				- 문자열로 해석할 수 있는 바이너리만 담긴 파일
	- C언어 파일 접근
		- fopen()함수 사용
		- 접근 문자
			- ![[Pasted image 20240804122432.png]]
			- w와 a 차이 주의!!
		- 코드 예시![[Pasted image 20240804122741.png]]
		- 텍스트 파일 입출력 코드 예시![[Pasted image 20240804124302.png]]
	- 파일 플러싱
		- 플러싱
			- 버퍼에 채워져있는 데이터들을 다른 곳으로 옮겨 비우는 것
		-  각각 장치 파일마다 버퍼가 존재
		- 운영체제에서 해당 버퍼를 플러싱할때 효율을 생각함(잦은 I/O는 자원 소모)
		- fflush()함수
			- 버퍼를 사용자 지정으로 플러싱함
			- 코드 예시![[Pasted image 20240804131144.png]]
	- 파일 I/O 포인트 위치 제어
		- fseek()함수
			- 버퍼 I/O 포인트 위치를 제어할 수 있는 함수
			- 바이너리 모드로 열어야함(ex. rb)
			- fseek(파일주소, 기준에서 상대적 포인터 위치, 포인터 기준 위치)
			- 코드 예시![[Pasted image 20240804134134.png]]
- 형한정어
	- 변수에 적용하는 문법으로 컴파일러 최적화 깊이 관련
	- 선언 시 기술하면 어떠한 특성을 가짐 
		- const
			- 변수를 상수화
			- 개념상 읽기 전용으로 만듬
			- 변수 갯수가 줄어들기에 컴파일 성능 최적화 유리
			- 심볼릭 상수
				- 특별한 의미를 갖는 기준값에 대해 이름을 부여
				- 방법
					- 1. const
					- 2. #define 전처리기
			- const 포인터
				- 포인터가 가르키는 대상을 상수화
				- write 시 컴파일 타임에서 알려줌
				- 읽기 전용 문자열도 const char[]으로 볼 수 있다.
			- 열거형 상수
				- 여러개의 심볼릭 상수를 한번에 정의
				- 정수값으로 계산
				- 초기값을 정의하면 다음값은 +1
				- 초기값을 정의하지 않으면 0 
				- 코드예시![[Pasted image 20240805211448.png]]
			- 코드 예시(const + 심볼릭 상수)![[Pasted image 20240805210213.png]]
			  코드예시(전처리기 + 심볼릭 상수)![[Pasted image 20240805210405.png]]
		- volatile
			- 최적화 관련으로 해당 변수를 제외
			- 컴파일러의 최적화를 막음
		- extern
		- typedef
			- 새로운 자료형을 선언
			- C언어가 제공하는 기본 형식의 이름을 바꾸는  용도로 사용
			- 구조체, 공용체, 열거형 상수와 조합하여 사용하면 편의성 확보
			- 남발 시 어려운 코드 발생
			- 코드예시![[Pasted image 20240805212120.png]]
- 전처리기
	- 컴파일 전에 선행처리를 위한 문법
	- \\#기호로 시작
	- 사용처
		- 헤더포함(#include)
			- 헤더 파일을 소스코드에 합쳐주는 기능
			- <>로 포함 시 시스템 설정에 따라 헤더파일을 검색
			- ""로 포함 시 현재 경로에서 헤더파일 검색
		- 조건부 컨파일
			- 상수 정의 여부에 따라 실제 컴파일 되는 코드가 달라지도록 구성
			- 문법
				- \\#ifdef, \#else, \#endif
			- 코드예시![[Pasted image 20240806211746.png]]
		- 심볼릭 상수 정의(#define)
		- 매크로 정의(#define)
			- 함수처럼 보이지만 함수가 아님
			- 간단한 로직이 존재할 때 함수를 사용하는 것보다 매크로를 사용하는 것이 함수 호출에 의한 오버헤드가 없기 때문에 성능이 좋음
			- 컴퍼일러 최적화에 따라 사용빈도가 줄어듬
	- 
- 함수 포인터
	- 함수의 이름(상수)을 저장할 수 있는 퐁인터
	- 반환 자료형 형식으로 선언
		- (호출규칙 \*변수명)(매개변수)
	- 열거형 상수(enum)과 함수 포인터를 가지는 배열로 조건문 없이 함수호출을 분리할 수 있다.
	- 코드예시![[Pasted image 20240807211717.png]]
	- 함수의 동적호출이 가능해짐
		- 조건에 따라 주소값을 나누어 해당 포인터에 그 값이 할당되어 동적인 호출이 가능해짐
	- 콜백 구조
		- 함수가 호출되는 구조
		- 어떠한 함수에 함수의 이름을 전달하면 그 함수 내부에서 함수가 호출됨
		- 코드예시![[Pasted image 20240807214042.png]]
	- 