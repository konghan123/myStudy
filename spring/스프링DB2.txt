1. DB 키
- 기본키 선택 전략
-- 기본키 : 유일하며, 변해선 안되며 null이 혀용되지 않는 값

-- 자연키 : 비즈니스에 의미 있는 키
            (ex. 이메일, 전화번호, 주민번호)

-- 대리키 : 비즈니스와 관련없는 임의 키
  (대체키)  (ex. 오라클 시퀀스, auto_increment)

-- 자연키보다는 대리키를 권장


2. JDBC Template
- 스프링이 제공하며 SQL을 직접 사용하는 경우 
   편리하게 사용 가능
- 스프링 라이브러리에 포함되어있으며 복잡한 설정이 필요없다
   (Spring-jdbc 라이브러리만 추가하면됨)

- 장점 : 반복작업을 줄여줌

- 단점 : 동적SQL을 해결하기 힘듬
  
- 이름을 지정하여 파라미터를 바인딩하는 기능을 제공
   (이전에는 ?를 통해 순서대로 바인딩해주었는데
    해당 바인딩은 이후 sql문을 변경할 때 순서대로 바인딩하기 때문에
    매우 치명적으로 작용한다)

3. 테스트
- 데이터베이스 연동
-- @SpringBootTest라는 어노테이션이 있으면
    해당 테스트 실행 시 @SpringBootApplication을 찾아가서 설정으로 사용함

- 데이터베이스 분리
-- application.properties에서 개발 DB로 변경해줌

- 데이터베이스 데이터 롤백

-- 방법1. 테스트 클래스에 트랜잭션매니저를 주입받아서 사용
             (스프링 부트는 자동으로 적절한 트랜잭션 매니저를 스프링빈으로 등록해줌)

-- 방법2. @Transactional을 클래스단에 넣어줌
             (해당 어노테이션은 문제가 없으면 커밋을하지만 
              테스트에서 적용하면 테스트가 끝나면 자동으로 롤백함) 
              (서비스, 리포지토리 단에 적용한 @Transactional도 테스트에 트랜잭션과
               같은 트랜잭션을 사용한다)
              (만약 커밋된 상태를 보고싶다면 클래스단에 @Commit을 추가하면됨)

- 임베디드 모드 DB - 테스트 
-- DB를 애플리케이션에 내장해서 함께 실행한다고 해서
    임베디드 모드라고 함 (DB를 켜지않아도 실행됨)

-- 이렇게 만든 DB는 테이블이 없어서 테스트가 불가능하다
   
--- 스프링부트에서는 파일하나로 애플리케이션 실행할때
    테이블을 생성할 수 있다
     resources -> schema.sql이라는 파일을 생성하여
     그 안에 CREATE sql을 넣어준다 

--- 더 간단한 방법은 스프링부트에서는 test의 데이터정보를 넣지 않으면 자동으로 
     임베디드 모드로 설정되어 테스트를 원할히 진행할 수 있다.   

4. MyBatis
- jdbcTemplate이 제공하는 대부분의 기능을 제공해주고
  sql을 xml에 편리하게 작성할 수 있고 동적쿼리를 매우 편리하게 작성 가능하다.

- 단, Mybatis는 별도의 설정이 필요함

- 설정
-- implementation 'org.mybatis.spring.boot:mybatis-spring-boot-starter:3.0.1'을 추가
   (마이바티스 경우 스프링에서 버전을 관리하지 않기 때문에
    버전을 넣어줘야하며 버전은 스프링 버전에 따라 달라짐)

-- application.properties
--- mybatis.type-aliases-package=DTO객체주소
     xml에 쿼리를 작성할때 반환타입을 지정해줄 때 패키지명까지 써야하지만
     해당 설정을 하면 그 하위 패키지까지 자동 인식하여 생략이 가능해짐   
--- mybatis.configuration.map-underscore-to-camel-case=true
     언더바를 카멜로 자동 변경해주는 기능을 활성화 설정
--- mybatis.mapper-locations=classpath:mapper/**/*.xml
     이렇게 하면 resource패키지 경로를 맞출 필요없이 xml은 전부
     매핑파일로 인식하여 xml파일들을 모아둘 수 있다.

- 사용
-- 인터페이스 하나를 만들어 인터페이스단에 @Mapper을 추가
-- 그 후 쿼리를 매핑할 메서드들을 선언해줌
-- resources에 해당 매핑인터페이스와 경로를 같게 만들어서
   xml파일을 생성 (패키지명이 같아야함)
-- 생성 이후 <mapper namespace="해당 매퍼 패키지 경로">
    을 넣어주어 xml과 해당 인터페이스를 매핑시켜줌

- 원리
-- mapper는 인터페이스인데 어떻게 구현체가 생성이 되었는가?
   -> mybatis스프링 모듈에서 @Mapper을 조회하고 
        해당 인터페이스를 기반으로 동적프록시 구현체를 생성하여 그것을
        스프링 컨테이너에 넣는다

5. JPA
- 자바 진영 ORM 기술 표준

- ORM : 객체관계매핑

- 객체 중심적인 개발이 가능함

- 패러다임 불일치 해결
-- 자바단의 객체관계와 테이블간의 관계에 대한 불일치를
    해결한다 (JPA를 사용하면 자동으로 관련된 테이블의 값을 지정하여 CRUD해줌)

- 동일한 트랜잭션에서 같은 값을 조회하면 그 객체 주소값도 같다
   (두번째는 캐시를 이용하기 때문에 약간 성능 향상)

- 로직이 돌면서 사용되는 SQL INSERT문을 커밋하는 순간 모아서 보낸다
   (한번에 모아서 보내기 때문에 성능향상)

- 지연로딩과 즉시로딩을 지원함
  (실제 해당 객체의 프로퍼티값을 쓸때 SQL문으로 조회하는 지연로딩과
   한번에 조인해서 SQL문으로 한꺼번에 들고오는 즉시로딩을 지원)

- 사용
-- 데이터를 담을 객체에 @Entity를 추가하여 JPA에서 관리하는 객체로 설정
    (테이블이랑 매핑이되어 관리됨)

-- PK는 해당하는 필드에 @Id를 넣어줌

-- @Column(name="매핑할컬럼이름", 길이)
    (해당 필드가 해당 테이블에 어떤 컬럼과 매핑이되는지 설정)
    (생략할 경우 필드의이름을 테이블 컬럼이름으로 매핑함)
    (카멜케이스를 언더스코어 형식으로 자동 변환해줌)

-- 단, 해당 클래스는 기본 생성자가 필수!!!
    (기본 생성자 기반으로 프록시 기술을 사용하기 때문)

-- jpa 리포지토리를 생성할 때 
   해당 리포지토리는 @Transactional이 필수
    (일반적으로 비즈니스 계층에서 @Transactional가 걸려있기에 굳이 걸 필요없음)
   그리고 EntityManager라는 객체를 주입받아야함

-- INSERT할땐  EntityManager객체.persist(넣을 객체)

-- 한개 SELECT할땐  EntityManager객체.find(클래스, 식별자)

-- UPDATE할땐 EntityManager객체.find(클래스, 조건값)으로
    값을 불러온 후 해당 값의 객체.set프로퍼티를 통해 자동으로 쿼리가 날아감
    (날아가는 시점은 커밋이 될때 한번에 모아서 날아감)

-- 여러 데이터를 SELECT할땐 
   jpql이라는 문자열로 "select 클래스이름 from 클래스 클래스이름"
   이후 em.createQuery(jpql, 클래스).getResultList();
   를 통해 여러 값들을 리스트로 반환해서 가져옴
   
- JPA 예외변환
-- EntityManager은 JPA기술이기때문에 스프링과 연관이없다
    따라서 예외가 발생하면 JPA관련예외를 발생시킴
    하지만! @Repository가 붙은 클래스는 예외변환 AOP적용 대상이 된다.
    그래서 스프링은 JPA예외변환기를 등록하고 예외 변환 AOP프록시가 발동하여
    JPA관련 예외가 발생하면 예외변환기를 통해 발생한 예외를 스프링 데이터접근 예외로
    변환시킨다!

- 스프링 데이터 
-- 데이터를 CRUD하는 로직들에 대한 인터페이스를 만들어
    통합하여 해당 기술을 편리하게 사용할 수 있는 기술 

-- 스프링 데이터 JPA, 스프링 데이터 몽고, 스프링 데이터 레디스 등등 존재

-- 스프링 데이터 JPA
--- 주요 기능
---- 공통화 가능한 모든 기능이 포함되어 있음
      (ex. CRUD)

--- 사용법
---- JPARepository<엔티티, 엔티티ID>인터페이스를 상속받는 인터페이스를 만들어서
     거기에 메서드를 만들어 사용하는 방식
---- 인터페이스에 메서드만 적어두면 메서드이름을 분석하여 쿼리를 자동으로 생성해줌
      [데이터접근기술 4쪽 참고]
---- @Query(jpql)을 통해 해당 메서드에 대한 jpql을 직접 작성할 수 있다.

- Querydsl - jpa
-- JPQL을 type-safe하게 만들어줌

-- 엔티티 클래스에 대한 메타 클래스를 생성하며
    실행 시 Querydsl -> JPQL -> SQL 순으로 변환하여 DB에 넘겨줌
    
-- 동적 쿼리를 쉽게 짤 수 있으며 타입 세이프를 해줌

-- 단, Q코드(메타) 생성하기 위한 APT 설정이 어려움

-- 컴파일 시점에서 오류가 발생하여 코드 오류를 잡기 좋다.

-- 사용법
--- Querydsl을 사용하려면 JPAQueryFactory라는 객체를 선언해야함
     (JPQL을 만들어주는 객체이다)

--- 그리고 그 JPQL을 SQL하기 위해 JPA의 EntityManager이 필요

--- 동적 쿼리 > BooleanBuilder객체를 통해 조건문을 추가해줄 수 있다.

--- where(A,B)는 AND조건으로 처리되며 null값으로 파라미터가 들어오면
     해당 조건은 무시함


6. 스프링 트랜잭션

- 트랜잭션 적용 확인법
-- TransactionSynchronizationManager.isActualtransactionActive()
    를 통해 확인 가능

- 트랜잭션 어노테이션을 포함한 빈은 빈 등록때부터
  실제 객체 대신 프록시 객체가 스프링빈으로 등록된다.
  (프록시는 실제 객체를 상속해서  만들어지기에 다형성이 활용해지기에
   프록시 객체로 주입이 가능해짐)
   그 후 메서드의 @Transactional을 여부를 확인하여 트랙잭션 시작을 정함

- 스프링에서 우선순위는 구체적이고 자세한 것이 우선순위가 높기 때문에
  메서드와 클래스에 @Transactional이 있다면 메서드 우선순위가 높다.
  (인터페이스에도 @Transactional이 가능하지만 우선순위가 가장 낮다)
  (AOP생성 시 인터페이스의 경우 인식을 못할 수 있기에 비추)

 
 