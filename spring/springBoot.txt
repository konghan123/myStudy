1. 스프링빈 추가하기
- @springBootApplication 이라는 곳의
패키지에 등록이 되면 해당 패키지를 찾아서
컴포넌트 스캔을 함 (스프링 빈에 추가)

- @Configuration의 어노테이션을 쓰는 클래스를 만들어서
그리고 매서드에 @Bean를 추가하여 원하는 생성자를 추가한다
-- 상황따라 받아야하는 구현클래스가 다르다면 추천

2.AOP
- 공통의 로직을 모든 매서드에 적용시키는 기술
- 해당로직을 어디에 적용할 지 
  @Around("execution(적용할범위(패키지,클래스))")


3. 객체 지향 설계의 5가지 원칙 (solid)

-SRP : 단일 책임원칙
-- 한 클래스는 하나의 책임만 가져야함 (허나 실무에선 힘듬)
-- 책임의 범위를 잘 조절해서 설계해야함!
-- 변경이 있을 때 해당 변경으로 인한 파급효과가 적으면
    단일 책임 원칙을 잘 따른 것!!
-OCP : 개방 폐쇄 원칙
-- 가장 중요한 원칙
-- 확장에는 열려 있으나 변경에는 닫혀있어야함
-- 기존 인터페이스를 구현한 새로운 구현체 생성
-- 문제점
--- 다형성을 사용했지만 OCP원칙을 지킬 수는 없음 
( 구현 객체를 변경하려면 생성자 코드를 변경해야함) 
--- 문제의 해결로 스프링이 해결해줌 (DI) 
-LSP : 리스코프 치환 원칙
-- 다형성에서 해당 인터페이스를 구현한 클래스들은 해당 인터페이스의 규약을
지켜야함
-ISP : 인터페이스 분리 원칙
-- 특정 클라이언트를 위한 인터페이스 여러개 가 범용 인터페이스 하나보다 낫다
-- 자동차 인터페이스 >> 운전 인터페이스, 정비 인터페이스
-DIP : 의존관계 역전 원칙
-- 중요한 원칙
-- 구현 클래스에 의존하지 말고 인터페이스에 의존해야함
-- 역할에 의존해야함!!
--문제점
--- 구현체 없이 기능이 불가능함!
--- 이 문제를 스프링이 해결

**'의존한다'의 의미
해당 클래스 내에서 클래스,인터페이스를 선언했을 경우 
해당 클래스, 인터페이스에 의존하고 있다고 말함

**객체 지향적 앱 개발 
- 각각의 객체는 자기가 해당하는 일만 함
  ex. 배우는 연기, 공연 기획자는 배우기획
       배우가 연기와 배우기획을 하면 안됨 
-구성 과 사용에 대해 구분하여
-- 구성에서는 관련 구현객체들을 생성
-- 사용에서는 인터페이스만을 선언하여 구성에서 
   선언된 구현객체만을 사용

4. IOC
- 구성 객체를 따로 둠으로 사용 객체들은 어떤 객체들이
   자신에게 적용되었는지 모른 채 묵묵히 자기 로직만 실행한다
   즉, 프로그램 제어 흐름이 외부에 존재하므로 제어의 역전이다
5. 스프링빈
- 스프링컨테이너(@Configuration)에 등록된 모든 객체
  getBean을 통해 불러올 수 있으며 이때 name은 지정하지 않으면
  @bean의 메서드 이름이며 아니면 @bean(name= )을 통해 지정가능

6.스프링 컨테이너
- Application Context, BeanFactory가 스프링 컨테이너이다
- 어노테이션 기반, xml기반으로도 스프링 컨테이너 만들 수 있음
- AnnotationConfigApplicationContext라는 클래스는
  ApplicationContext 인터페이스의 구현체이다.

- 생성방식 : 
 1.스프링컨테이너를 생성할때 구성정보(appConfig)를 지정해주어야함
 2.appConfig에 @Bean 메서드를 보고 호출하여
   빈저장소에 메서드 네임을 빈이름을 가지고 리턴값을 빈 객체로 가짐
   (빈이름의 경우 직접 부여가 가능함)
   (빈의 이름은 항상 다른 이름을 부여해야함) 
 3.스프링 빈 의존관계 설정하여 설정정보를 참고하여 의존관계 주입

7. 스프링빈
- 스프링빈 조회 
 1. getBean(빈이름, 타입)
  ex. Service service = ac.getBean("service", Service.class)
 2. getBean(타입)
  (만약 동일한 타입이 두개이상이면 빈이름을 지정해야함)
 3. geBeansOfType(타입) >> 해당 타입 모든 빈을 가져옴 (리턴값은 Map)
  - 스프링빈 상속관계 조회
  -- 부모타입으로 조회하면 자식타입은 다 조회됨

8. BeanFactory, ApplicationContext
 - BeanFactory는 스프링컨테이너의 최상위 인터페이스
 -- 스프링빈을 관리하고 조회하는 역할(대부분 빈조회기능은 이 인터페이스가 담당)
 - ApplicationContext
 -- BeanFactory기능을 상속받아서 제공
 -- 그 외 수많은 부가기능(편리기능)이 추가됨 (BeanFactory만이 아니라 여러 인터페이스를 상속받음)
 -- 부가기능
 --- 메세지 소스를 활용한 국제화기능(MessageSource)
 --- 환경변수 (EnvironmentCapable)
 --- 애플리케이션 이벤트
 --- 파일 리소스 조회

9. 스프링 빈 설정 메타 정보
 - 빈 설정 형식 지원하는 것 : BeanDefinition
 - @Bean 하나 당 각각의 메타정보가 생성
 - 스프링 커테이너는 이 메타정보를 기반으로 생성됨

10. 싱글톤
- 객체를 2개 이상 생성하지 못하게 하는 디자인 패턴 
-만드는 방법
-- PRIVATE의STATIC으로 자기자신을 자신 클래스에 상수로 선언 후 생성함
-- PUBLIC의 STATIC 으로 해당 선언된 변수를 리턴해주는 메서드를 만듬
-- PRIVATE으로 생성자를 만듬( 외부에서 객체 생성을 못하게끔)

11.싱글톤 컨테이너
- 스프링컨테이너는 싱글톤 컨테이너 역할을 하며
  싱글톤의 단점을 모두 해결하며 객체를 싱글톤으로 유지

12.싱글톤 방식 주의점
- 무상태로 설계해야함(stateless)
-- 특정 클라이언트에 의존적인 필드가 있으면 안됨
-- 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면안됨
-- 가급적이면 읽기만 해야함
-- 자바에서 공유되지 않는 지역변수 파라미터 ThreadLocal등을 사용해야함
    (지역변수, 파라미터로 값이 공유되지 않게끔)

13. @configuration
- 스프링 빈을 싱글톤으로 유지시키기 위해서 
 CGLIB이라는 바이트코드 조작 라이브러리를 사용하여
 configuration의 클래스를 상속받는 새로운 클래스를 만들고 
 그 클래스를 스프링빈으로 등록시킴 (@configuration가 없으면 라이브러리를 쓰지 않음)
 그래서 해당 클래스의 인스턴스를 꺼내면 새로운 클래스인 것을 확인가능하다
 그래서 빈이 이미 컨테이너에 등록되어 있으면 
 스프링 컨테이너에서 찾아서 반환할 것이다.

14. 컴포넌트 스캔
- @ComponentScan >> @Component라고 붙은 클래스를 자동적으로 스프링빈으로 저장하는 어노테이션
-- 그리고 excludeFilters를 통해 필요없는 타입의 클래스는 걸러서 등록 시킴
   (ex. excludeFilters = @Filter(type = FilterType.ANNOTATION, classes = Configuration.class))
- @Autowired >> 자동 의존관계 주입 
   (주입할 대상이 없으면 오류 발생, 없어도 동작하려면 @Autowired(required=false))
   (getBean() 메서드 처럼 동작한다 생각하면됨)
   (@Bean으로 직접 설정정보를 작성하고 의존관계도 명시햇다면 이 어노테이션들을 통해서
     자동으로 주입하고 설정해줌)
   (의존관계자동등록은 스프링컨테이너가 관리하는 스프링 빈이여야지만 가능)
- 빈 이름을 임의로 지정하고 싶다면 @Component("지정할 이름")
- 기본 적인 빈이름은 클래스 명에서 앞글자가 소문자임
- 통상적으로 의존 주입할 빈 조회는 타입을 기준으로 함

- 컴포넌트 스캔의 탐색위치
-- basePackages를 통해 스캔 시작 위치를 지정가능
-- basePackageClasses는 지정한 클래스의 패키지를 시작점으로  스캔시작
   (ex.	basePackages = "hello.core"  
	excludeFilters = @Filter(type = FilterType.ANNOTATION, classes = Configuration.class))
-- 기본 탐색위치(지정하지 않을 시)는 @Configuration을 붙인 클래스의 패키지부터 스캔시작함
--- 권장방법은 설정 정보 클래스의 위치를 프로젝트 최상단에 두는것이 좋다
--- 부트를 사용한다면 @SpringBootApplication가 있는클래스의 패키지를 스캔시작이 관례

- 컨포넌트 스캔 기본 대상
--@Component, @Controller, @Service, @Repository, @Configuration 

- 필터
-- includeFilters >> 포함할 필터
-- excludeFilters >> 포함하지 않을 필터
-- 필터타입 옵션 (FilterType)
--- ANNOTATION >> 기본값, 어노테이션을 인식해서 동작
--- ASSIGNABLE_TYPE >> 지정한 타입과 자식 타입을 인식해서 동작
--- ASPECTJ >> AspectJ패턴사용
--- REGEX >> 정규 표현식
--- CUSTOM >> TypeFilter이라는 인터페이스를 구현해서 처리

- 중복등록과 충돌
-- 컴포넌트에 같은 빈 이름을 동록하면??
-- 자동빈 VS 자동빈 >> 익셉션을 일으킴
-- 자동빈 VS 수동빈 >> 수동빈이 우선권을 가짐
    (스프링부트에서는 충돌나면 오류가 나게 끔 기본값을 바꿈)

15. 의존관계등록방법
-생성자주입
--생성자 호출시점에 딱 1번만 호출
--불변, 필수 의존관계에 사용
--생성자가 하나면 @Autowired 생략가능
-수정자주입(setter)
--세터값을 이용해 자동적으로 의존관계를 등록
--선택적으로 의존관계를 등록가능 ex. @Autowired(required=false)
-필드주입
--코드가 간결하지만 좋은 패턴이 아님
--주입할 대상에 대해 유연하게 지정할 수가 없음
--테스트할 때 순수한 자바코드로 테스트가 불가능해짐 (스프링컨테이너 내에서 테스트가 가능)
   (DI프레임워크에서 지원하는 것이기 때문에 스프링에서만 동작함) 
-일반 메서드주입
--아무 메서드에 @Autowired 추가

16.의존관계등록옵션
-@Autowired(required = false)
--기본값은 true임 
--자동으로 주입할 대상이 없다면 해당 메서드를 호출안함
- 매서드(@Nullable Meber meber)
-- 자동으로 주입할 대상이 없다면 익셉션대신 null로 값이 주입됨
- 매서드(Optional<Meber> meber)
-- 자동으로 주입할 대상이 없다면 익셉션대신 empty가 주입됨

17.생성자주입을 선택하는 이유
-의존관계 주입은 애플리케이션 시작부터 종료까지 의존관계를 변경할 일이 없다
 즉, 불변해야함. 그런데 수정자 주입을 사용하면 set메서드가 public이기 때문에
 변할 수 있음!! 생성자 주입을 사용하면 객체 생성할 때 1번만 호출되기에 이후 호출될 일이 없음
- 프레임워크 없이 순수한 자바코드 단위로 테스트하는 경우가 발생하는데
  필드주입의 경우 스프링컨테이너 없이 불가능
  수정자주입의 경우 가능하지만 order o = new order이렇게만
  객체를 생성하기 때문에 안에 어떤 의존관계가 있는 확인해야함
  생성자주입은 컨파일오류로 생성자안에 넣어야할 객체들을 알수있음
- 생성자주입을 쓰면 필드값에 final을 쓸 수 있으므로 처음 생성자에서만 값을
  받을 수 있기에 불변유지 및 받을 값이 없는 경우 컨파일 오류 발생해서 실수캐치

18.롬복
-어노테이션을 통해 게터,세터,생성자까지 직접 코드를 짤 필요없이
 간단하게 구현해주고 사용할 수 있음
-@RequiredArgsConstructor 이라는 어노테이션을 통해
 final이 붙은 필드에 대한 생성자를 만들어줌 (더이상 생성자를 만들 필요가 없음)
 
19. 조회 빈이 두개 이상일때???
- 같은 인터페이스 구현체가 2개일 떄 둘다 @Component로 빈으로 등록되면
  불러올 때 어떻게 되는가? -> 익셉션 발생
- 스프링 빈을 수동으로 등록하여 문제 해결이 가능하지만 
  자동 주입에서도 해결 방법이 존재
-방법
--@Autowired 필드 명 매칭
--- @Autowired는 타입매칭을 시도 후 여러 빈이 있다면 필드이름, 파라미터 이름으로 추가 매칭함
--- 생성자 주입할때 파라미터의 이름을 보고 결정함
--@Quilifier사용
--- 추가 구분자를 붙여줌 (단, 주입 시 추가적인 방법을 제공하는 것이지 빈이름을 변경하는 것은 아님)
--- 해당 구체 클래스에 @Quilifier("mainPolicy") 이런식으로 지정하고 난 후
    생성자 주입할 때 파라미터 앞에 @Quilifier("mainPolicy")를 넣어주면 해당 어노테이션이름에
    부합하는 구체 객체를 주입해줌!
    (만약 못 찾을 경우 스프링빈에서 해당 이름과 같은 객체를 주입함)
--@Primary사용
--- 우선순위를 지정하는 방법
--- 여러빈이 매칭되면 @Primary를 해당 구체 클래스에 추가
--- 주입 시 @Primary가 있는 구체 클래스를 주입시킴
-@Primary vs @Quilifier
-- 우선순위는 자세한 것이 높기에 @Quilifier가 더 높다

20. 어노테이션 직접 만들기
- @interface로 만듬
- 어노테이션에는 상속이라는 기능은 없으며
  여러가지 어노테이션의 조합으로 함께 쓰일 수 있다.

21. 동적으로 빈을 선택할 때 List와 맵을 활용할 수 있음!!
     자세한건 참고자료 참고

22. 자동 수동 실무 운영 기준
- 업무 로직 빈의 경우 컨트롤러 서비스, 리포지토리처럼 유사한
패턴이 잇기에 자동 기능을 적극 사용
- 기술 로직은 애플리케이션 전반으로 광범위하게 영향을 미치기 때문에  
  가급적으로 수동 빈으로 등록하는 것이 좋다.
- 기술 지원 객체는 수동빈으로 등록하여 설정 정보 클래스(@Configuration)에 나타나게 하는 것이 좋다
- 업무 로직에서도 수동으로 이용하는 경우는 다형성을 적극 이용할 때임
   (동적 빈으로 사용하여 List, Map을 사용할때)
-- 별도의 설정 정보 클래스를 만들어서 어떤 빈들이 주입되는 지 파악하기 좋음(유지 보수)

23. 빈 생명주기 콜백
- 스프링빈은 객체 생성 -> 의존관계 주입 의 사이클을 가짐
  (단, 생성자 주입은 예외, 생성될때 주입됨)
- 객체 생성 후 의존 관계가 주입이 되면 해당 객체의 초기화 작업이 일어남
   (주입이 끝나서 필요한 값들이 다 연결이 되어 있고 외부와 연결이 가능해서 일을 시작 가능한 상태)
- 스프링에서는 빈에게 콜백 메서드를 통해 초기화 시점을 알려주는 기능이 존재
- 스프링 컨테이너가 종료되기 직전 소멸 콜백을 받을 수 있음, 그래서 안전하게 종료가능
- 스프링빈 이벤트 라이프 사이클(싱글톤)
  (스프링 컨테이너 생성 > 스프링 빈 생성 > 의존관계 주입 > 초기화 콜백 > 사용 > 소멸전 콜백 > 스프링 종료)
- 객체 생성과 초기화 작업은 따로 분리하는 것이 좋음
  (내부 값을 약간 변경하는 정도는 생성할때 초기화해도 되지만
   외부와 연결하는 무거운 작업은 초기화 메서드를 따로 나누는 것이 좋다)
- 생명주기 콜백 지원방법
--인터페이스 (InitializingBean, dispoableBean)
--- InitializingBean 해당 인터페이스를 구현 받으면 afterPropertiesSet()이라는
     메서드를 구현 받는데 이 메서드가 초기화 작업을 해줌( 의존관계 주입끝나고 해당 메서드가 실행)
--- dispoableBean 해당 인터페이스를 구현 받으면 destroy()이라는
     메서들르 구현 받는데 이 메서드가 스프링 컨테이너가 종료되면서 빈 소멸 직전에 작업을 해줌
--- 단점 > 스프링 전용 인터페이스이기에 스프링에 의존적이다.     
            > 초기화 소멸 메서드 이름을 변경할 수 없다
            > 외부 라이브러리를 적용하기 어렵다
-- 빈 등록 초기화,소멸 메서드
--- @Configuration 클래스에서 해당 하는 빈에 대해
     @Bean(initMethod = "해당 초기화메서드 이름", destroyMethod = "소멸 작업 메서드이름")
     (해당 이름에 해당하는 메서드들이 각각 초기화 소멸직전 작업을 진행함)
--- 메서드 이름을 자유롭게 줄 수 있고 스프링에 의존적이지 않다
--- 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메서드를 적용 가능
     (해당 라이브러리에 맞는 이름을 바꿔서 적용시키면됨)
--- destroyMethod에는 특별한 기능이 있는데 기본값이 (inferred) 추론 으로 등록되어 있다.
     대부분 라이브러리의 종료메서드의 이름이 close, shutdown이기 때문에 해당 라이브러리에 맞게
     추론하여 종료 메서드를 호출한다.
-- 어노테이션으로 적용(@PostConstruct, @PreDestroy)
--- 이방법을 가장 많이 씀(매우 간단하며 편리)
--- 해당 빈 클래스에서 초기화 작업을 할 메서드 앞에 @PostConstruct
     소멸 직전 작업을 할 메서드앞에 @PreDestroy를 써줌
--- 패키지 명이 중요 (javax.annotation)
--- 스프링 종석적 기술이 아닌 자바표준임
--- 단점 > 외부 라이브러리에 적용하지 못함
               (외부 라이브러리를 사용할거면 2번째 방법을 쓰자)

24. 빈스코프
- 빈이 존재할 수 있는 범위
- 스코프 종류
-- 싱글톤 >> 스프링 컨테이너의 시작과 종료까지 유지되는
                   가장 넓은 범위의 스코프
    @Scope("singleton")
    (빈을 조회하면 항사 같은 인스턴스의 스프링빈을 반환)
-- 프로토타입 >> 생성 의존관계 주입 후 초기화까지만 관여하고
                         이후 관리하지 않는 매우 짧은 범위의 스코프
    @Scope("prototype")
    (빈을 조회하면 새로운 인스턴스를 생성해서 반환)
-- 웹관련 스코프
--- request >> 웹요청이 들어오고 나갈때까지 유지되는 스코프
--- session >> 웹 세션이 생성되고 종료될 때까지 유지되는 스코프
--- application >> 종료될때까지 유지되는 스코프

25. 프로토타입 스코프
- 해당 빈을 요청하면 그 시점에 새로운 빈 인스턴스를 생성하고 의존성 주입 이후 반환하고 버림(관리하지않음)
- 같은 요청이 오면 항상 새로운 프로토타입 빈을 생성
- 프로토타입 빈을 관리할 책임은 클라이언트에게 있다. (그래서 소멸(종료) 메서드가 호출되지 않음)

- 싱글톤 빈과 함께 사용 시 문제점
-- 싱글톤스코프 빈 안에 프로토타입스코프 빈을 주입해서 사용한다고 가정하면
    해당 싱글톤 빈은 스프링컨테이너가 생성될 때 같이 생성이 되면서 
    해당 싱글톤 빈이 생성될 때 프로토타입 빈에 대한 주입 요청이 일어나게 되고
    그 시점에 프로토타입 빈이 생성된다. 이후 해당 싱글톤 빈을 호출하여 프로토타입 빈의
    로직을 요청한다면 프로토타입 빈이 새로 생성되지 않고 싱글톤 빈이 생성될 시점에 생성된
    프로토타입 빈의 로직이 들어가게된다
    하지만 프로토타입빈의 경우 사용할 때마다 새로 생성되어야 의미가 있는 빈 스코프이기에
    문제가 생김
     (단, 여러 빈에서 같은 프로토타입 빈을 주입받으면 그 시점에서 새로운 프로토타입 빈이 생성되는 것이기 때문에
      빈마다 생성된 프로토타입 빈은 서로 다르다)

- 싱글톤 빈과 함께 사용 시 문제점에 대한 해결법(Provider)
-- DL >> 직접 필요한 의존관계를 찾는것(의존관계를 외부에서 주입 받는 것이 아님)
   (Dependency Lookup) 의존관계 탐색
-- ObjectProvider >> 지정한 빈을 스프링 컨테이너에서 대신 찾아주는 DL서비스를 제공하는 클래스
   (해당 ObjectProvider <프로토타입빈>으로 필드로 선언 후
    프로토타입의 로직이 필요한 매서드에 .getObject()를 통해 해당 빈을 탐색)
--- ObjectFactory >> ObjectProvider의 부모 인터페이스이며 getObject만 존재
    (ObjectProvider는 많은 기능을 제공함)
--- ObjectProvider의 단점은 스프링에 의존적이다
--- javax.inject:javax.inject:1의 provider 라이브러리를 써서 스프링에 의존적이지 않게 가능
 
26. 웹 스코프 (웹 라이브러리 필요)
- 웹 환경에서만 동작하는 스코프
- 스프링이 종료시점까지 관리하기에 소멸 메서드가 호출됨
- request >> http요청 하나가 들어오고 나갈때까지 유지되는 스코프, 요청마다 빈 인스턴스가 생성됨
   (@Scope("request")를 해줌)
- session >> 세션과 동일한 생명주기를 가짐
- application >> 서블릿 컨텍스트와 동일한 생명주기 가짐

27. 스코프와 프록시 (진짜 객체 조회를 꼭 필요한 시점까지 지연처리하는 점이 중요)
- 스프링 실행 시 빈을 주입할 때 request스코프의 경우
  http요청할때 빈 생성되기 때문에 주입할 수 있는 빈이 없게되어
  오류가 발생하게 된다 그래서 provider을 이용하여 빈이 주입될 수 있는
  시점을 지연하여 정상작동할 수 있게 되었다
- 프록시를 통해 이보다 더 간결한 코드로 로직을 작성할 수 있다.
- 프록시
-- @Scope(value="웹스코프", proxyMode = ScopedProxyMode.TARGET_CLASS)
   (적용대상이 클래스면 TARGET_CALSS
    적용대상이 인터페이스면 INTERFACES )
-- CGLIB 라이브러리로 해당 클래스를 상속 받은 가짜 프록시 클래스를 만들어주고 주입시킴
    (스프링 컨테이너에서 싱글톤으로 가짜 프록시 객체가 생성되고 주입됨)
-- 가짜프록시객체는 요청이 오면 그때 내부에서 진짜 빈을 요청하는 위임 로직이 들어가있음

 








