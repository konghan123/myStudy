프로그램은 우리가 사는 세상의 문제를 해결하기 위한 하나의 장치 >> '솔루션'
버퍼 > 데이터들의 임시 저장 장소
버퍼링 > 버퍼에 데이터들을 담는 중이라는 뜻
0과1로 된 이유 > 전기신호
기계어를 번역하는 방법 1.컴파일 >> 한번에 통채로 번역함 2.인터프리트 >> 차례대로 번역 
하드웨어와 소프트웨어를 연결해주는 중간자 역할이 운영체제이다.
자바는 운영체제에 맞추지 않고 따로 젠더를 만들어 운영체제에 맞춘다 >> 그 젠더가 바로 자바 버츄얼 머신
자바는 운영체제에서 움직이지 않고 자바 버츄얼 머신에서 움직인다. / 자바 버츄얼 머신은 기계어를 읽지만 자바는 바이트코드를 읽음
그래서 자바 >자바버츄얼머신>운영체제 이렇게 두번 번역이 된다. >> 그래서 다른 언어들에 비해 느리다
하지만 운영체제에 따라 여러버전을 안만들어도 되기 때문에 경제적이다.
자바 > 바이트 코드 > 자바 버츄얼 머신 > 기계어 > o/s    // 자바 아버지 > 제임스 고슬림
스탠다드 에디션 >> 로컬환경에서 쓸때(개인) >>코어자바
엔터프라이즈 에디션 >> 웹에서 쓸때 (기업)
마이크로 에디션 >> 모바일에서 쓸때 
자바소스코드는 ~~~~.java로 저장됨(jvm상태이다) >> 그래서 실행할땐 바이트코드로 옮겨야하는데 그 명령어가 'javac 소스코드이름' 이다.
그렇게 해서  ~~.class가 만들어짐. 그 이후 실행을 할땐 'java 소스코드이름(확장자빼고)'이다.  
자바소스코드는 클래스단위(구성단위)이며 만들때 클래스를 만들어줘야한다.
main이란?? 프로그램을 시작할때 출발점 (컴퓨터가 자바에서 움직일떄 먼저 메인메소드를 찾아서 움직인다)
프로그램을 만들기위해서는 1.class단위로 구성을하고 2. 실행하기위한 main 메서드가 필요하다. 3. 그리고 클래스명과 소스코드이름이 같아야한다.
';' > 문장의 끝을 나타냄
api >> 자바 프로그래밍할때 사용할 수있는 언어적인 도구들
jre >> 자바 실행환경
jdk >> 자바 개발환경 (jre도 포함됨)

클래스명을 결정할떈 첫글자는 무조건 대문자로 시작 즉, System.out.print  >>  이것도 클래스임 >> 이것이 api (메서드에는 첫글자에 대문자x)
" " >> 문자열이다. (복수단위 , 순서)
다른이름으로 저장할때 한글을 표현하고 싶다면 인코딩을 ANSI로 바꾸고 저장한다.
실제로 실행할땐 .java파일이 아니다. class 파일로 실행한다.  ( 컴파일을통해 .java 파일에서 .class를 생성) (한 소스파일에 class가 여러개라면 .class 파일이 여러개 생김)
javac 소스코드이름.java  //  java 클래스이름 
**클래스 앞에 public이 붙는다면 파일이름을 public이 붙은 파일이름으로 저장한다. (public 클래스는 무조건 하나만 들어간다)
소스코드 하나에 클래스는 하나인것이 좋다 >> 왜?? 여러 소스코드파일중에 클래스가 2개인 것이 있다면 그 클래스파일이 어딧는지 일일이 찾아봐야함 
메모남기기 >> '//' >> 주석 (코드가 길때 주석을 남김으로써 저 코드의 목적을 남길 수 있다)
variable >> 변수 (ex. int x) >> 변경이 가능한 값 (재사용가능) >> 변수명이 존재하는 이유는 재사용하기 위해서이다.
데이터타입은  종류, 크기를 합친 단어이다.
코드 상에서 뭔가를 쓰기위해선 메모리에 올려야한다
선언한다 >> 이 선언한 것을 쓰기 위해 메모리에 올린다는 뜻 (메모리 공간을 미리 확보함)( ex. int x >> int크기만큼 메모리를 확보한다는 뜻)
x=100 >> '='는 우항의 값을 좌항에 대입하라는 뜻 (초기화, 정의라고 한다) (확보한 메모리 공간에 값을 넣음)
즉, 선언과 초기화를 거쳐서 메모리에 올라가고 그때부터 사용할 수 있다.
프로그램이 실행되고 목표에 도달하면 프로그램이 종료되고 메모리에서도 삭제된다. 
**동일한 블럭 안에서 이름이 같은 변수는 존재할 수 없다 >> 왜?? 구분이 안되기 때문
정수데이터 타입 > byte(파일 읽기쓰기) , short(작은수), int, long(시간을 나타낼때) (오른쪽으로 갈수록 큰숫자를 담을 수있다.)
실수 >> float, double (오른쪽으로 갈수록 보다 정밀한 소숫점으로 나타낼 수 있다) 
글자 >> char
논리 >> boolean

유니코드 >> 전세계 언어를 모두 표현할 수 있음. >>
변수의 이름 >> 유니코드와 숫자,_ $ 로 가능 / 첫글자로 숫자만 x ,특수기호는 _ ,$ 정도는 가능
                 >> 대소문자 구별 / 
식별자 관례 >> 클래스명: 첫글자는 대문자(두번째 단어도 대문자) / 변수,메서드: 첫글자 소문자(두번째단어는 대문자)
                 >> 상수는 모든 글자 대문자(final이 붙으면 상수가 됨)
변수에 새로운 값이 대입되면 기존 값은 사라짐
java home >> jdk 경로 
%JAVA_HOME%\jre\lib\rt.jar;. >> 마지막 .을 통해 현재위치에 있는 클래스파일들을 찾아본다는 뜻 (즉, 자기가 만든 클래스는
                                                 classpath에 없기 때문에 위치를 정해줘야하는데 귀찮으니까 .을 통해 자동적으로
			        현재위치에서 클래스 파일을 찾는다.
package >> 이름이 겹치는 파일들이 있을때 위치를 다르게해서 이름이 중독되는 파일들을 존재하게 할 수 있는데 그 경로가 package이다.
package 이름 규칙 >> 유일한 문자열 URL(도메인네임) EX. NAVER.COM (고슬링형이 만든 PACKAGE를 제외한 모든 PACKAGE는 도메인을 뒤집어서 쓴다)  
.jar >> ==apk랑 같다 (압축파일이라 보면된다.) 압축파일이라서 클래스를 불러올때 rt안에 있는 java.util.Scanner 이런식으로 불러온다.
PATH란?? 내가 원하는 파일이 현재 폴더에 없다면 PATH에 적힌 경로를 가서 찾아봐라는 뜻 (즉, 어디든 그 파일을 열 수있게함) 
              (실제 쓰임새: BIN파일안의 컴파일과 실행)
JAVA_HOME >> JDK가 설치된 경로를 정해줌 그래서 한번만 바꿔도 CLASSPATH, PATH 다 바뀜
	        (원래라면  자바 설치경로가 바뀌면 CLASSPATH, PATH 둘다 바꿔줘야함) 
CLASSPAHT 프로그래밍시 필요한 클래스파일들을 찾는 경로이다. (.class 파일을 classpath라는 곳에서 찾는다 (위치를 알려주느 역할) )
PATH > 어디서든 실행할 수 있게 해준다.
참조형 데이터타입들은 값을 가질때 값 앞에 new를 붙인다. 
System.out >> 표준출력장치 (콘솔)//System.in >> 표준입력장치: 키보드
Scanner(System.in) >> 키보드 입렫을 읽는 녀석
netxInt >> 키보드 입력을 정수로 바꿔준다.
System은 왜 안 불러와줘도 되나?? >> java.lang에 있으며 컴파일될 때 자동적으로 import java.lang.*이 포함된다.
java.lang.* >> 자바 프로그래밍하면서 자주쓰는 것들을 모아놓음
printf >> ("abc %dxyz", 3) >> abc 3xyz  %d >정수   $f > 실수  %s > 문자열 
 \n >> 줄바꿈 \t >> 탭  \" >> 글자 "   \\ >> 글자 \
변수를 쓰는 이유 >> 보다 편한 수정을 위해
컴파일 에러>> 문법적인 문제 >> 젤 쉬운 에러
런타임 에러  >> 컴파일은 가능한데 실행하면서 발생하는 오류 >>예외에러
논리 오류 >> 컴파일과 실행이 가능한데 결과가 예상과 다른 오류 >> 가장 찾기 힘든 에러

리터럴 >>  이름이 없어서 변경이 불가능 한것 ex. 4  , 바보 / 상수의 일부분 (상수 안의 부분집합이다)
final >> 이름이 있는데 변경이 불가능 한것 
앞에 0으로 시작하면 8진수로 계산된다.
앞에 0x로 시작하면 16진수
정수형상수의 경우 4l >> long타입형으로 저장   실수형 상수의 경우 3.14f >> float타입형으로 저장
논리형 boolean >> true 와 false 만 가진다  ex. boolean result = num1 (3) > num2 (5)  >>>> false  
== 같습니까?  != 다릅니까??       >< 큽니까??  
(자바는 0,1처럼 true false를 나타낼 수 없고 boolean만 이용해서 true false를 나타낸다.)
! >>> not이라는의미   !result
그룹 탭 가능!!  shift + tap하면 백 탭 가능!!
num++, ++num >> 1씩 증가
num++ >> 출력하고 증가  ,  ++num >> 증가하고 출력  // 팁: 단독으로 써라 (다른 연산과 합쳐서 쓰면 헷갈림)
AND OR >> 논리연산자 // 논리연산자는 양쪽항에 boolean만 올 수 있다.
AND 는 양쪽이 참 
OR 은 한쪽만 참이어도 참
a += b  >> a = a + b
a % b >> 나머지 값이 나옴
형변환 >> cast >> 작은곳에서 큰 곳으로 변환은 언제나 가능!! ex. byte > int 가능 !! (하지만 큰곳에서 작은 곳은 값이 회손될 수 있다)
 byte b = 100;   int a = b;  >> 즉 byte타입을 int타입으로  바꿈
int b = (byte)a >> 강제 형변환 (회손되는 걸 감안)  // boolean은 형변환 불가(나머지 기본 데이터형은 서로서로 가능)
byte <char <int <double 이런식으로 많이 쓰인다 ('<'은 크기) 
작은 타입 과 큰 타입이 연산을 하면 결과는 큰 타입이 나옴 !! ex. char + int = int     int / int = int
만약 4 / 3 을할 경우 4는 int, 3도 int 이기 때문에 값은 int인 1로 나온다 그래서 소수점이 나오게하려면(형변환을 하려면)
하나를 4.0으로 바꾸던가 앞에 (double)을 붙여준다. (중요!!!)
?  >> 삼항연산자   // boolean x = y == z ?  A : B;  >> TRUE일경우 A , FALSE 일경우 B
 
if (조건(boolean형태)) 조건형태가 참이면 if중괄호 안으로 들어가고 거짓이면 if 중괄호를 생략한다.
else가 붙으면 조건이 참이 아니라면 else 중괄호 안으로 들어간다.
else if >> 조건이 여러개라면 else if를 써준다. 여러 else if문이 있다면 해당하는 하나만 들어간다.
중괄호 안이 한문장 뿐을때 중괄호를 생략가능하다 >>안한는게 나음
변수랑 상수의 차이 >> 변수를 넣엇을 떄 컴파일러는 변수가 값이 바뀔 것도 생각하기 때문에 if조건문에 변수를 넣으면 
값이 바뀔수도 있다며 true false 모두 생각해서 컴파일이 에러남 ! (else를 넣는다면 둘중 어느 하나는 실행이 되니까 컴파일됨)
 상수를 넣으면 바뀔일이 없어서 else를 안넣어도 컴파일 에러가 안남  그래서 블럭이 나오면 반드시 실행 보장이 되는지 여부를 따져봐야함 (조건문이면 if뒤에 else가 붙어있는지)
switch( 정수만 가능(long은 불가능) (String은 1.7부터 가능) ) {
	case 1:
	    a;
	case 2:
	    b;
	    break;
	default :
	    c;
만약 조건에 1이 들어가면 case1만 가는게 아니라 쭉 내려간다. (즉 case2도 들어감)
default : 를 넣으면 모든 case가 일치하지 않을때 이곳에 들어간다.  얘는 위에서부터 차례차례 검사하지 않는다.
break; >> 하위 문장들을 다 실행하는 것을 막는다 // break 밑의 문장들은 실행되지 않는다.
 
반복문
while (조건(boolean형태)) { } 조건이 참이면 중괄호를 수행하고 다시 조건으로 간다 
while문을 만들때 어느정도로 반복하게 할건 지 계획이 필요함. (ex.num++)
연속되고 규칙적인 연산의 중복을 없애기 위해 반복문을 쓴다.
반복문을 해석할 때 변수를 추적해서 표로 그려보면 해석하기 쉽다.

do while >> do { } while (조건); 먼저 하나를 수행하고 while문의 조건으로 참 거짓을 보고 반복할지 본다

for문 >> for(초기값 ; 조건(boolean) ; 증감식) { }       초기값을 수행하고 조건을 검사후 조건이 참이면 중괄호로 내려온다 
		                                           수행 이후 끝나면 증감식을 받는다. 그후 다시 조건 
while vs for >> while : 반복횟수를 예측할 수 없을때 (lettergame)    for : 반복횟수 예측 가능할 때

중첩for문 >> for문안에 for문을 넣는 방식      for문안 for문의 초기값은 for문이 false일때 소멸되고 다시 그 for문에 들어오면 리셋됨.
**********for문 속 코드들은 한번 루프가 지나면 초기화된다.
반복문 안에 if문안에 break가 있을 경우 반복문을 빠져나옴
break outer_loop; >>> outer_loop: 라인으로 나온다 >> 사실상 가독성때문에 안쓰임
continue; >> for문 안에 if문 안에 continue가 있을 경우 for문의 증감식으로 간다   // break , continue 둘다 잘 안쓰임

객체 >> 세상을 구성하는 모든 요소(이미지,개념)들 +실체가 없는 것들(감정,프로세스, 약속) 
객체 지향 >> 현실세계에서 생긴 문제들을 구성하는 객체들과 그 관게를 찾고 컴퓨터 세상에서 그대로 따라 만들어서 해결(또는 흉내내는 무언가) 
직접 현실에서 부딪힐 필요 없이 컴퓨터에서 똑같은 상황의 시뮬레이션을 만들어서 해결하는것 ( 즉, 모든 문제들을 객체로 해결하겟다)
현실의 객체를 컴퓨터로 옮길때 상태와 동작으로 구성 ex. 아이유 (가수,노래잘함, 예쁨, 연기도함, 키, 나이) >>이게 모여서 아이유가됨.
사람이 사물을 머리속에 받아드릴때 값과 기능으로 받아드린다.(수치 값 데이터,  그리고 기능)
상태(명사,형용사) >> 멤버변수   기능(동사) >> 멤버메소드        로 표현
클래스 > 붕어빵틀      객체 > 붕어빵
객체를 사용 >> 즉, 메모리에 올라감 (눈에 보이지 않는다.)
인스턴스 >> 사용할 준비가 끝난 객체 (즉, 메모리에 올라가 있는 객체)    
객체를 사용함에도 불구하고 객체는 눈에 보이지 않기 때문에 눈에 보이는 클래스(객체의 틀)를 통해 확인함 
중요!!! 우리는 객체가 필요한것!! (클래스가 필요한 것이 아니다 !! 단지 객체를 파악하기 위해 클래스를 보는것!)
**가상머신은 바이트코드를 읽음
논리세계(상태,행동) >> 물리세계(멤버변수,멤버메서드)
객체생성과정: 1. 대상선정  2.특징을 뽑아냄  3.상태 행동으로 분류 (논리세계) 4. 클래스를 구현(물리세계)(멤버변수,멤버메서드) 5.객체를 생성,사용  
Car myCar = new Car();    new Car() >> 객체를 만들겟다(메모리에 올림)       myCar >> 참조형 변수
myCar.color = "red";        . >> 참조연산자 ~안으로 들어가라
클래스의 변수와 매서드를 사용하기 위해서는 객체가 생성되어야 한다.   
참조란??  여러가지를 알려줘야 할때 /  원칙은 변수하나에 값 하나 1대1비율이다. 그래서 기본데이터형은 변수 값 1대1비율이다.
하지만 참조형은 1대 다수여야하지만  하지만 그것은 원칙상 불가능!! 그래서 다수들이 모인 것이 객체이고 참조형은 객체의 '위치'를 알려주게 됨.>> 참조형이 위치를 알려주게 된 이유
메소드 >>  work의 집합!!을 모아서 이름을 정해준 것 + 메서드는 소유자(객체)가 존재한다. (함수는 존재x)  
파라미터의 갯수는 다수 가능하지만 리턴(일의 결과로 돌아나오는 값)의 갯수는 없거나 하나만 가능
입력값과 결과 값에 맞게 메서드를 써준다. ex. int값을 리턴하면 int functuin() {  }    /  정수를 입력 받고 싶으면   int functuin(int num) {  }
return >> 일의 끝을 의미하기 때문에 이 밑 코드들은 실행안됨.
일의 결과가 없을 경우 데이터타입 대신 void를 쓴다 (즉, 돌려줄 값이 없다는 뜻)  

힙 >> 객체들이 저장되는 메모리공간
가비지 컬렉터 >> 사용이 끝난 객체를 수거해감 (수거하는 순간 소멸한다고 함)      쓰는 이유 >> 메모리를 재활용하기 위해
car1 = null; >> car1이 가지고 있는 값을 없애는 값(null은 나타내는 주소가 없다는 것) 그리고 모r든 참조형이 공통적으로 가질 수 있는 유일한 값
객체를 가르키는 변수가 없을 경우 쓰레기가 됨. 그것을 가비지 컬레터가 객체를 수거(소멸)함.
기본형은 직접 값을 가지고 참조형은 주소를 가진다.
**초기화 되지 않은 멤버변수의 경우 객체가 생성되면서 자동적으로 초기값을 가짐 (기본데이터형: 0, boolean 은 false) (참조형 : null) 

return 메서드를 만들 땐 그 일의 결과로 돌려받는 것이 있어야함 

변수는 타입과 가용범위로 나뉨   타입 > 기본, 참조    가용범위 > 멤버변수 ,(지역변수,파라미터)
지역변수와 멤버변수는 이름이 같을 수 있다 (구분이 가능함!!) 지역변수와 멤버변수의 차이 : 멤버변수는 초기값이 있다.
메서드 내에서 멤버변수와 지역변수가 이름이 같을 경우 메서드 내에서 그 이름을 부를 때 지역변수가 불려진다.
그래서 그 메서드 내에서 멤버변수를 부르고 싶다면 'this.변수이름'을 하면 멤버변수가 불려짐!
메소드 앞 this는 생략 가능하다!
public >> 접근제한자 중 하나 > 누가 사용할 수 있고 누가 사용할 수 없는지 제한하기 위해서 씀 
접근제한자는 4개가 존재 >> private, public, 생략, protected 
public >클래스 앞, 멤버변수 앞, 메서드 앞에 붙는다 (단, 현재 우리가 배운 클래스에는 생략하거나 public밖에 못쓴다)(멤버변수나 메서드에는
                 4개 다 쓸 수 있다.)
public >>  모두 사용 가능
private >> 자신만 쓸 수 있슴. 즉, 객체 자신안에서만 사용 가능 
ex b.num2(다른 클래스에서 nun2를 직접 부름)(불가능)  vs b.printNum2다른 클래스에서 같은 클래스의 메소드를 통해 부름)(가능)
접근제한자 선택기준 >  멤버변수 : 특별한 이유가 없으면 private     메소드 : 특별한 이유가 없으면 public       
private, 생략 , protected, public  오른쪽으로 갈 수록 제한이 줄어듦
멤버변수는 값을 나타내고  메서드는 연산을 나타냄 
즉, 값은 변경될 가능성이 있기 때문에 (다른 곳에 불럿다가 변경되기 매우 쉬움) 그래서 처음의도 했던 값이 달라질 수 잇다.    >> private 쓰는 이유  
연산은 변경이 불가능함(메소드를 부른다고 해서 바뀌지않는다) 그래서 보호하지 않아도 되서   public이다
바뀔 가능성이 있다 (private으로)  바뀔 가능성이 없다 (public으로)
get >> 뭔가 가져온다(리턴존재)        set >> 뭘로 바꾸는가 (파라미터존재)(void)
getter setter  >> 변수하나당 한묶음씩 나와야함   >> private에 접근할 수 있는 방법!! >> 외부에서 무자비한 값 변경을 막기 위해
get할때 메서드이름은 'get변수이름' 이렇게한다. (boolean일 경우 겟터는 'is변수이름') (return은 변수이름이랑 똑같이)
set도 비슷 (파라미터는 해당 변수이름이라 똑같이)
그리고 메인메소드에 'set변수이름'으로 해서 private값을 변경 가능하다. 
값을 들고올땐 'get변수이름'으로 들고올 수 있다.
왜 저렇게 get set을 쓰면서 private붙여서 들고오고 바꿀수 있게 만드는 이유 >>  값이 어디서 바뀌는가 누가 바꾸는가가 중요하기 때문
public은 외부사람이 들고오거나 바꾸거나 결정권한을 가짐  private은 그 클래스가 만든사람이 들고오거나 바꾸거나 결정권한을 가짐(바꾸려고할때 set메소드에서 제한을 둘 수 있다)
지역변수 : 클래스 일부에서만 쓸 수 있는 변수

변수를 비교할 때 기본형은 실제 값을 비교하고 참조형은 주소값을 비교 ('같다'의 관점은 사람마다 조금 다르며 한국어 '같다'라는 말이 다 같은 말이 아니다 영어로는 equal, same 나뉨)
= >> 복사가 되는 것!!  참조형은 주소값이 복사됨!!
callex2
파라미터가 참조형이면 주소안의 값이 바뀌기 때문에 지역변수와 상관없이 값이 바뀜
callex1
파라미터가 기본형이면 지역변수의 값이 복사되어 연산을 수행하므로 지역변수는 해당 메소드가 끝나면 사라지기 때문에 값은 그대로 
반드시 리턴값을 쓸 필요는 없다.
객체지향의 특징 1. 추상화 2캡슐화 3 상속 4다형성
추상화 >> 물체의 이름 만들기 (클래스 이름 만들기)  ex. 여러가지 변수들을 모아놓고 일일이 하나씩 부르기 귀찮으니까 클래스로 묶어 하나의 이름으로 정해줌
캡슐화 >> 1. 내용물보호 -> 접근제한자로 보호(시각적으로 가시성을 없애므로 보호)  3. 감출수 잇는 부분을 감추고 필요한부분만 노출하여 사용자가 편하게함(private 감춤 public 보임)
메소드(기능)를 분류 해놓는 이유 > 수정할 때 그 부분만 빠르게 찾아서 고칠 수 있다.  

자바에서 메소드를 구분하느 방법 > 1. 이름   2. 파라미터 - 타입, 갯수, 순서     (리턴정보, 접근 제한자는 구분기준이 아님)
구분 기준이 왜 이런가?? >> 파라미터로 구분하는 이유는 이름하나로 편하게 쓸 수 있게됨. (서로 이름이 다른 메서드를 기억하기 힘들기 때문에 이름은 비슷하지만 파라미터의 차이로 쓸 수 있음) 
오버로딩 >> 클래스 내부에 이름이 같은 메소드가 복수로 존재하는 현상  ex. System 클래스 (데이터타입마다 만들어놔서 이름이 같으므로 기억하기 좋다)
*세터는 일반적으로 오버로딩을 잘 하지 않는다.  
uml  > 여러가지 다이아그램이 존재 그중 우리는 클래스 다이아그램을 주로 쓴다. 첫번째 클래스이름  /두번째 변수이름  - name : String = "춘식"  
/ 세번째  메소드이름  +getName() : 리턴타입   ex. +getAge(void) : int  , +setName(name:String) : void
접근제한자 표시 public -> +  , 생략 -> ~    , protected -> #   ,   private -> -    
sourceforge사이트 기억!+   스택오버플로우기억
참조변수를 출력하면 type@메모리주소(16진수) 가 나옴
객체를 화면에 출력할때 객체를 문자열(toString)로 하는 것이 좋다 (문자열로하면 출력과 함께 많은 것들을 할 수 있다)
객체의 정보를 문자열로 표현한것
toString메서드 헤더는 변경 x  public String toString() 여기까지 외움
문자열에 연산을 넣으면 그게 앞뒤가 무슨 타입이든 문자열이 됨
System.out.println(m) 하면 자동적으로 System.out.println(m.toString)이 됨

set x,y 메소드가 있다고 가정 하에 
public void set(int x , int y) {
	this.x= x;
	this.y= y;   >>>이거보다
	setX(x);
	setY(y);     >>> 이게 나음 ( x,y범위를 정해줄때 한번만 일해도됨) 
}

생성자(constructor) >> 객체 생성 시 할일을 정의함.  할일 >> 멤버변수 설정! (객체를 생성할 시에 원하는 값을 넣어서 운용가능)
생성자의 규칙 >> 클래스 이름과 같아야함!(첫글자도 대문자다) , 리턴이 없다(애초에 값을 돌려주는 기능이 없다),  객체 생성 시에만 호출가능 ,오버로딩가능(설정을 강요가능)
new + 생성자 호출 >> 객체생성  
컴파일 시 클래스 내부에서 생성자가 존재하지 않으면 컴파일러는 기본 생성자(파라미터도 없는 생성자)(아무일도 안함)를 만들어준다.
생성자의 갯수는 객첼르 만들어낼 수 잇는 방법의 수이다.  생성자1을 쓰든지 생성자2를 쓰든지 >> 즉, 객체 생성 시 파라미터를 강제할 수 있다.
생성자가 호출 되었다 >> 적어도 1개의 객체는 만들어졌다고 보장됨.
this(...) >>> 자신의 생성자를 호출한다는 뜻! (단, 생성자 내에서 첫번째 연산으로 와야한다)(생성자 내부에서만 사용가능)
클래스간의 관계
A use -a  B >> B가 A의 지역변수로 사용
A has -a  B >> B가 A의 멤버변수로 사용

클래스를 이용하면 값 연산을 동시에 중복을 없앨 수 있다.
중복 - 값(변수)
       - 연산(반복문, 메서드)
정적(고정,변경불가) > 메모리에 올라가는 시점을 바꿀수없다 . >> static 변수/메소드  
						  >> 객체생성를 통해 메모리에 안올려도 이미 메모리에 올라가있어서 객체생성필요없이 바로 호출가능
							(static은 프로그램 실행할 때 메모리에 올라간다.)
							(static은 객체의 구성요소가 아님 즉, 클래스와 아무 관계가 없다)
							{** static안에 다른 함수를 쓰려면 객체를 생성 받아야한다.}
							static은 만들자마자 메모리에 올라가서 바로 실행된다. 즉, 메모리에 제일 먼저 올라감
							(우리가 무슨짓을 해도 static보다 먼저 못올림)
							static함수를 불러오고 싶다면  클래스이름.static메서드  이런식으로 쓴다.
							(문법적으로는 객체이름.변수/매서드 해도 상관없지만 객체와의 관계에서 가독성이 떨어지기에 반드시 클래스이름.을 써준다)
							static의 역할 : 객체의 소유물이 아니므로 각각의 객체에 static변수/매서드를 공유가 가능
							얘는 독립된 하나여서 누군지 바로 알 수 있어서 부를 수 잇음 ex. 강사
							static > 강사     non-static > 학생1 학생 2 학생 3
							static 하지 않은 녀석은 static한 녀석을 구분할 필요가 없기 때문에 바로 부를 수 있슴
							static이 static을 부르는 것도 바로 부를 수 있다.
							전부 static으로 쓰지 않는 이유 >> 여러 객체들에 공유가 되기 때문에 무엇때문에 논리오류가 났는지 찾기 힘들기 때문!!
							정적변수는 최대한 안쓰는게 좋다.
동적(변경가능) > 메모리에 올라가는 시점을 바꿀 수 있다.  위에서 아래로 읽어서 순서를 볼 수 있다.
기준이 무엇????? 메모리에 올라가는 시점  
멤버변수로 파이널을 넣으면 무조건 바로 초기화 시켜야 하지만  생성자 안에서 초기화를 하면 객체를 생성할 때 나오므로 가능하다 단, 생성자가 여러개라면 생성자마다 초기화가 들어가야함
(멤버변수 상수는 무조건 public으로 한다 (왜?? 바뀔일이없으니까)  
특정한 값이 정해져있다면 static을 통해서 만들고 (하나만 만들어서 공유하면됨)(상징적인 값을 적을때) 특정값이 정해지지 않았다면 static이 아니라 생성자를 통해서 값을 정해주면 된다.
생략 접근제한자  >>> 패키지 안에서 쓸 수 있다는 뜻 (ex. java.util)
static + 멤버변수 >> 필드    (static도 초기값을 가진다)

상속 >> 상하개념 
        상위 >>  
        하위 >> 상위의 특징들을 가지고 있으면서 다른 특징들(상위에서 가지고 있지 않는 특징)(+a)도 가지고 있다.
상속에는 상하개념과 +a가 있어야지 쓰는 것이 옳다. (둘다 true일때만 상속)
상속은 받는다는 개념만 존재함!! (해준다는 말은 없다)   a -> b  (자식이 부모를 상속 받는다)
상속쓰는법 > extends (확장)    클래스 a extends b {   }   b를 확장한 것이 a이다.
상속받는것 : 멤버변수 , 메서드 , 추가 생성자
상위: 슈퍼클래스 하위:서브클래스 
상위 하위를 나눌때 정의를 내려보면 정하기 쉽다. (특징을 뽑기)
상속을 통해 중복을 제거하고 시간을 아껴줌 그리고 버그를 줄여줌(새로운것을 만들기보단 기존에 완성된 클래스에서 추가하기에 버그가 줄어든다)
쓰고싶은 변수와 메소드가 있는 클래스가 있다고 무작정 상속받아서는 안된다.(재사용성만 고려하는게 아니라 상하관계도 생각해야함)
슈퍼클래스에서 public이라면 서브클래스도 public 이다
메소드는 슈퍼클래스가 private이면 상속에서 배제된다!
부모클래스는 자식클래스를 모르기 때문에 부모가 바뀔때 자식을 고려하지 않는다. 그래서 부모가바뀌면 자식도 바뀌게 된다.
상속은 의존성이 높은 기술이다.(주의필요)
자바는 밑으로 내려가는 상속에 제한이 없음(다중상속은 불가능)
다중상속의 문제점 : 신경써야할 점들이 많아지기 때문에 (복잡해짐)
has-a관계도 상속처럼 만들 수 있긴함! 
접근제한자
private :클래스 내부만
생략: 클래스 내부 그리고 동일 패키지(경로)
protected: 클래스 내부 , 동일 패키지, 상속관계면 사용가능
public : 다 가능!

오버라이드>> 부모클래스에서 정의된 메서드를 재정의 하는 것!! 
               >> 무엇을 하는가?(what)은 동일 , 어떻게하는가(how)가 변경
               >> 규칙 메서드 헤더(리턴타입 이름 파라미터 정보)는 변경할 수없다     단, 접근제한자는 변경가능하지만 더 좁아질 수 없다 (private은 아예 변경불가)
               >> 물리적으로 동일하게 인식할 수 있는 메서드를 만드는것(목적) 
               >> 오버로딩 > 물리적으로 다른 메서드를 만드는 것!!(목적)
@.... >> annotation 많은 어노태이션이 있지만 제일 많이 쓰인느 것이  @override이다. 
@Override >> 오버라이드가 되었는 지 확인할 수 있다!!( 검증 : 컴파일타임) (검증이 필요한 메서드 하나하나마다 붙여야함)
오버라이딩은 에러가 났는지 확인이 불가능하기에 어노태이션을 쓴다 (오버라이딩은 틀려도 실행이됨)
super 1. 부모의 참조
        2. 부모의 생성자
this  1.  자신을 참조
       2. 자신의 생성자
필드 재정의라는 말은 없는 말이다 (변수는 바꿀 수 있기 때문에 새로 만들 이유가 없다) s.age = 20;
**자식 객체가 생성이 되면 부모객체가 먼저 생성이 되고 자식 객체가 생성됨.
자식객체 : 부모의 구성요소(생성자는 포함 x) + 추가된 개념 -> 자식 객체를 생성하려면 먼저 부모객체부터 생성해야함.
super은 자기 바로 위 부모만 가능!!
super은 오버라이딩으로 겹쳐진 부모의 메소드를 불러올 수 있다.
부모생성자의 선택 여부가 없는 경우(즉, 부모쪽에 기본생성자만 있을때) 컴파일할때 자동적으로 자식생성자에 super()을 집어 넣어준다. (자식의 생성자에 부모의 생성자가 없다면 에러다)
부모의 추가생성자가 있는 경우(기본 생성자가 없다면)(부모생성자를 결정해줘야함) 자식에게도 그 추가생성자를 넣어줘야함 ex. super(3) << 부모 추가생성자는 파라미터를 정수로 받음
그리고 super()은 첫번째 자리에 들어가야하기 때문에 this()랑 같이 쓰지 못한다.
**this. 는 처음에 들어간 객체를 의미함 (부모의 메서드안이라고 해서 this가 부모는 아니다)
object >> 모든클래스의 최상위 클래스 (우리가 만든 클래스 포함)
toString 메서드도  object의 메서드이다 즉, 우리는 오버라이드들 통해 object 메서드를 재정의해서 쓰는 것이엿다!!!
종단 클래스, 메서드 >> final             변수 : 대입이 마지막      메서드 : 오버라이드 금지       클래스 : 상속 금지
tree >> 노드들과 노드들을 연결하는 하나의 그래프  
root >> 최상위 노드

추상클래스 >> 추상메서드가 존재할 수 있는 클래스.(반드시 가져야하는 것은 아님)(객체생성을 할 수없음)(일반메서드 생성자 멤버변수 다 가질 수 있다) >> abstract class some {  } 
추상메서드 >> 바디가 없는 메서드   >>  abstract public void todo(); >> 바디가 없음(일을 할 수 없음)
추상클래스가 객체를 못만드는 이유 >> 추상 메서드를 가질 수 있는데 추상 메서드를 불렀을 때 아무것도 못하기에 못만듬
추상클래스의 목적 이유 >> 상속관계에서 상위 개념을 나타낼 떄 쓴다.
예를 들어 공격몹이라는 상위 클래스가 있다면 밑에 하위클래스 몹들은 공격에 대해 기능들을 자세하게 표현할 수있지만 
공격몹이라는 클래스에선 그것을 표현하기 애매하다.(목적 1)(어떻게 공격하는지) 그래서 상위클래스(공격몹)에선 완전히 공격에 대한 기능 메소드를 작성할 수 없다 
그래서 그 메소드는 바디가 없는 추상메소드로 만들어지고 자연스럽게 그 클래스는 추상클래스가 된다.
상속을 쓰면 자연스럽게 상위객체도 만들어진다 그런데 상속을 쓰는게 하위 클래스를 사용하는데 중복을 제거하기 위해서였다.
그래서 결국 중요한건 하위클래스인데 어쩔수없이 상위클래스 객체도 만들어지게 된다. 만약 나는 상위클래스 객체를 만들게 하기 싫다면(다른 사용자가 내가 의도하지 않게 상위객체를 쓸 수도 있기에) 
객체생성이 불가능한 추상클래스를 통해 그것을 막을 수 있다.(목적2 :상위 객체생성을 제한하는 것!)(추상메소드가 없음에도 저 목적을 위해 만듬)
규칙: 추상메소드를 가지고 있는 추상클래스를 상속받는 하위클래스들은 추상메소드에 대해서 무조건 오버라이드를 해야한다!!
추상메소드를 쓰는 이유 : 오버라이드를 강제시킬 수 있다(목적3)(각 자식들마다 재정의를 강제), 기능의 통일(목적2)(추상메소드만 쓰면 되는 것으로 통일됨) area() , printArea 이런 같은 기능들이지만 통일이 안됨. 
추상클래스: 상위개념을 표현

다형성 >> 여러가지 타입을 가짐 (객체 한개가 있으면 다양한 타입을 가질 수 있다)
(즉, 다른타입으로 형변환이 가능) ex. 바지와 티가 있다면 바지는 바지타입이기도 하지만 옷타입이기도하다! 
형변환할때 설명한 컵크기랑 같다 (즉, 상위 타입일수록 컵크기가 크다)(하위에서 상위로 가능하지만 반대는 안됨) (상속일때만 가능하다) 
(object클래스도 상위에 포함-> 어느 참조형이든 타입을 2개이상 가질 수 있다) 그래서 바지의 타입은 3개다
다형성을 할떄 (머가 큰건지 작은건지 판단해야함!)
상위타입으로 변환하면 자식타입의 변수와 메서드에 접근할 수 없다. 
형변환하는거 처럼 객체도 강제 형변환이 가능하다.(큰곳 ->작은곳)  
처음부터 상위객체로 parent p = new parent() 만들고 형변환 child c2 = (child)p 은 불가능하다 (child에서 parent로 그리고 다시 child로는 가능)
왜?? child만들면 1과2가 있지만 parent로 만들면 1만 있씀 그래서 child부터하면 2를 숨겨서 왓다갓다 할 수 있지만 parent부터하면 1만있기때문에 child로 변환하기위해서는
2가 필요하기에 컴파일은 가능하지만 실행이 불가능하다.
child c => c는 child만 담을 수 있다!
a instanceof b >>  a는 b의 인스턴스가 맞다면 참  >>>> 형변환의 안정성을 보장함!! if문으로 instanceof를 쓰고 참이면 if바디에 형변환하는 식으로!
a.equals(b) >> 서로의 객체(참조형)가 가진 내용이 같을때 참 (그냥 쓴다면 주소가 같은지 체크하게됨 그래서 우린 오버라이드를 통해 우리가 비교할 것을 정해줌)
public boolean equals(Object o) {    }    > 이렇게 오버라이드해준다 (파라미터가 Object라서 자연스럽게 형변환이됨)
파라미터가 Object이므로 아무객체나 다 들어올 수있게 되면서 파라미터로 대입될 값을 지정해줘야함!! 
그걸 if( o == null || !o instanceof 원하는 클래스) 표현해서 참이면 return false로 써줌
그다음에 원하는 비교를 위해 다시 형변환을 해준다 
ex. Car temp = (Car)o; 형변환 후 비교 >> return price == temp.getPrice( ); >> 기본형  color.equals(temp.getColor()) >>참조형

인터페이스 >> interface 이름 {      }   >> 바디안에 들어갈 수 있는 요소 : 추상메소드 , 상수(static final) (접근제한자는 무조건 public)
인터페이스는 객체 x 
인터페이스는 설계 단계에서 가장 중요함 / 인터페이스는 구현해줄 일반 클래스가 필요!! / 인터페이스는 '구현한다'라고 한다
클래스 implements 인터페이스 이름  (is-a관계 - 상속, 구현)
인터페이스 이름을 지을 때 앞에 대문자 i를 쓰고 이름을 만든다 ex. ISome
인터페이스 상수(public static final int MAX= 5)를 int MAX = 5로 생략가능하고 
                추상메소드(public abstract void todo();)를 void todo();로 생략가능 (오버라이드되는 메서드 접근 제한자는 public 고정)
인터페이스의 특징 1. 객체 생성 불가 2. 상수,추상메소드만 포함할 수 있다. 3. 구현한다 라고 표현  (implements)(is-a관계)
                          4. 관례상 네이밍할 때 첫글자를 I로 시작 5. 다중상속가능 
                          6. 다중구현이 가능(왜 가능?? 일반클래스가 다중상속이 불가능한 이유는 부모클래스가 
                              중복되는 메서드,멤버변수가 있을 경우 어떤걸 불러와야할 지모름. 모르는 이유는 메서드, 멤버변수 값이 다르기 때문!!)
                          7. 상속과 구현이 동시에 가능 8. 클래스다이어그램 그릴때 점선으로 표현
객체에서 타입은 사용 할 수 있는 정보를 결정한다!!
상속과 인터페이스를 통해 클래스를 분류할 수 있다!! (계층구조를 다양화 가능)
단순히 분류로 쓰이는 인터페이스를 mark interface라고 하며 바디안에 아무것도 없는 인터페이스이다.
이떤 제품이 있다면 우리는 인터페이스(ex.버튼)를 통해 자세한 작동방식을 몰라도 제품을 편하게 쓸 수 있다. (사용자가 사용하기 쉽게 해주는 매개체)
인터페이스를 쓰는 이유 >> 협업할때 의존성이 있는 작업이 있을경우 인터페이스를 활용해서 독립적으로 작업가능
인터페이스는 기능!! 

배열 >> 1. 같은 타입의 복수 데이터를 표현    2. 길이(데이터 수 )는 한번 정해지면 변경이 불가능하다.(만들때 길이를 정해줘야함) 3. 원소구분 > index (0번부터 시작)
            4. 자바는 배열을 객체로 판단함 (참조변수)(클래스가 존재하지 않는 유일한 객체),(메소드가 하나도 없다(Object메소드는 가능))
배열을 만드는 방법 1. int[] arr = new int[3] >> 정수를 3개 담을 수 있는 배열생성  arr[0] = 3  >> arr이라는 배열의 0번째에 3을 대입!
                           arr[0] = 3;           1번을 쓸때 >> 원소 갯수는 아는데 뭐가 올지 모를때, 그리고 가장 많이 쓰임
                           arr[1] = 5;
                           arr[2] = 8;
	             2. int[] arr2 = {3, 5, 8};    >> 선언, 정의를 분리할 수 없다. 2번을 쓸때 >> 이미 원소를 다 알고 생성할때
                           3. int[] arr3 = new int[] {3, 5, 8}    3번을 쓸때 >> 이름없이 사용할 때(원소내용을 알고 있슴) new int[] {3, 5, 8} << 이것만으로도 배열이 생성됨
lenth에서 1을 빼면 마지막 인덱스이다  int [] sc = new sc[6]  >> (0~5)                               
foreach for(자료형 변수 : 배열이름) {               };  >> 배열이랑 같은 타입의 자료형 변수를 안에서 만들어준다   
                                                                    >> 인덱스로 접근을 하지 않기 때문에 대입연산이 어렵다.  (대입연산할거면 걍 for문씀)                     
                                                                    >> 접근방향을 변경할 수 없다. (선택적으로 접근이 불가능 ex. 0번째 다음에 2번째를 호출)
                                                                    >> 정방향으로 0번째부터 차례대로 다 뽑을 때 사용함
메서드에 배열을 파라미터로 >> 배열을 파라미터(동이한 타입)로 둔다면 파라미터의 갯수에 대해서 자유로워짐 (배열도 참조형이라서 값이 바뀜)
리턴값을 줄때도 return new int[] {1,2,3}을 하면 리턴값을 여러개 가능!
객체들에 대한 배열도 가능 ex. Marine[] list = new Marine[3] >> 아직까진 list[0] = null 상태임 (멤버변수 초기값이 들어감)
list[0] = new Marine(); 이렇게 해주면 주소값이 들어감!
2차원배열 >> 그런거 없다  다 1차원 배열이랑 똑같다! 
int[][] arr = new int[2][3];    >> 뒤에 [3]은 큰 의미가 없다  그냥 정수배열이면 된다!!    그냥 초기값일때 3개 가지고 있다는것(없다면 null이 뜨거나 예외가 뜬다) 
                                     >> [3]이 그 안에 3개만 온다는 뜻이 아니라 후에 대입할때 3개보다 더 많은 갯수를 넣을 수 있다. (주소를 받는거기 때문에 몇칸을 넣는지 강제할 수 없음)
                                     >> 아무리 많은 배열이 있어도 타입이랑 제일 앞에 몇개만 담는지만 넣어준다면 돌아간다!
                                           ex. double[][][][][][][][][][][][][][][] list = new double [2][][][][][][][][][][][][][][];

복수 date의 특징 : 내가 원하는 객체를 찾을 수 있어야함(검색할 수 있어야함) >> 그래서 식별자를 가짐(중복이 되지 않으며 null을 가질 수 없다) >> 나중에 key에서 나옴
                       (내가 원하는 객체를 찾기위해 자바에서는 equals를 쓴다)
배열은 length말고는 제공하는 기능은 없다. >> 고슬링형이 배열의 도우미 클래스를 만들어줌 : Arrays > 배열로 할 수 있는 빈도가 높은 연산들을 제공
Arrays > static 메소드를 기능으로 제공한다!
specified >>파라미터를 의미한다.
binary search > 절반씩 나눠서 줄여나가면서 찾아냄 (검색에는 정렬이 필수 >> 그래서 정렬이 필요함 (오름차 , 내림차))
기본 정렬은 오름차순이다!  
객체끼리 정렬하기에는 비교하기 위한 기준이 없고 무엇이 큰지 작은지 알 수 없다 그렇기에 에러가 뜸!! >> comparable이라는 인터페이스 필요!
제네릭 >> 일반화시킴 >> 객체를 생성할 때 데이터타입을 결정한다 , 인터페이스는 구현하는 클래스에서 데이터타입을 정해줌
a.compareTo(b) 
1.기준 >> 객체의 멤버변수를 기준으로 한다!!
2.누가크다 누가 작다        a>b=양수 , a<b=음수 , a==b = 0 (오름차순 기준)   왜 이런 기준일까??? 
if문에서 양수일때 음수일때 0일때 로 각각 조건을 달아줄 수도 있지만 간단하게 return num - other.getNum() 이거랑 같다!
nautural ordering 객체가 태어날때 comparable을 이용해서 정렬된것
Arrays.sort(carList); 전부 정렬
Arrays.sort(carList, 1, 4); // 부분정렬 (1번째부터 4번째미만까지)    즉, Arrays.sort(carList, 1, 5); 라고 해야 1~4까지 정렬
binary search >> 전제조건 : 무게를 기준으로 찾는 경우 무게로 오름차순 정렬이 되어 있고
		원소 중에 동일한 값를 가진 원소가 여러개 있는 경우 결과의 정확성을 보장할 수 없다.
		결과가 음수인 경우 해당하는 조건을 가진 원소가 존재하지 않음을 나타낸다.
		모든 상황에 이 서치법을 사용할 순 없다. 그래서 유일한 값을 만들어냄 (ex.학번)  a

Comparable로 나타내지 못하는 것이 있다.  Comparable은 compareTo문으로 쓸때 한가지 멤버변수밖에 정렬하지 못한다
만약 다른 사람이 해당 클래스를쓸때 compareTo문으로 정렬한 멤버변수가 아닌 다른 멤버변수를 정렬하고 싶다면???
Comparator 인터페이스를 쓰면 가능하다!(제 3자가 누가 크고 작은지 정해주는 느낌)
Comparator 인터페이스에서 compare() 추상메서드를 써서 비교함! compare(a, b)  앞 첫 파라미터를 기준으로 a>b , a<b a==b로 나뉨
Comparator도 유틸이라서 import 필수 
하고나서 sort(배열, 비교를 위해 만든 클래스 생성자)

배열의 단점 >> 길이가 고정이라 삭제 및  삽입을 하지 못한다.
복수데이터를 다룰때 1순위로 배열을 사용하는 것이 좋다.( 심플해서 성능이 좋다)
collections framework -> 기본적으로 가변길이이며 객체만 다룬다!(기본형은 다루지 않는다)
                               -> collection이라는 인터페이스와 map이라는 인터페이스로 나뉜다.
제네릭 >> 동일한 타입의 원소만 처리하겠다! (원소 타입에 제한을 두겠다!) (collections framework를 위해!!) 
ex. collection<String>  -> String타입 원소만 처리하겟다!(넣을때도 제한이 생겼지만 꺼낼때 형변환 할 필요가 없어짐) 
wrapper class >> 기본데이터형을 나타내는 클래스 (collections framework은 기본형을 다루지 않기 때문에 )
                   >> int, char 만 빼고  첫글자를 대문자로 바꿔준다!!  (int >> integer     char >> Character)
int n = 5             Integer i = new Integer(n);       >> int -> Integer 로 바꿈
int other = i.intValue();                                     >> Integer -> int 로 바꿈
auto boxing >> ex. Integer i2 = 3; >> String처럼 편하게 쓸 수 있슴 (JDK1.5이상부터)
auto unboxing >> ex. int m = i2;
**String을 int로    ex. Stiring str = "123";  >> int strNum = Integer.parseInt(str); (정수로 변경이 불가능한 문자를 변경시도하면 예외뜸)
  int를 String으로 ex. String result = String.valueOf(100);
collection >> set이랑 list로 나뉜다
              >> Vector, ArrayList라는 클래스가 많이 쓰임
              >> 객체.add() >> 원소를 추가 /     객체.size() >> 길이  /  객체.clear() >> 원소 전부 삭제   /  객체.comtains(a) >> 객체 안에 a라는 원소가 있습니까?
                   객체.remove(a)  >>  객체 안 a라는 원소를 삭제 ( ()안에 인덱스도가능 )
              >> 객체를 출력하면 자체적으로 Arrays.toString()쓴것 같은 효과가 나옴!
              >> collection을 배열로 바꾸기(길이가 정해지면 배열로 바꾸는 것이 좋다) -> String[] arr = some.toArray(new String[0]); (String 배열로 바꾸는 경우) 
                    some의 길이가 배열의 길이보다 짧을 경우 null값으로 채워짐   String[0]을 함으로써 some의 길이만큼 채워지게 됨!
                    배열로 바꿀때 원소 수가 크거나 같게 하면 그 주소를 유지하지만 원소 수가 작으면 원소 수가 같은 새로운 배열을 리턴한다
              >> 원소를뽑을 때 컬렉션 내에서 바로 뽑을 수 없기 때문에 뽑는 담당의 객체를 만들어줘야함(Iterator) (foreach문으로 원소 뽑아내는 것과 똑같다)
                    Iterator<타입> itr = 객체.iterator(); 이렇게 생성 /  while(itr.hasNext()) { String element = itr.next(); System.out.print(elememt)
                    hasnext() >> 꺼낼 것이 더 있습니까??    next() >> 꺼내라! 
                   collection은 순서가 없다 즉, index라는 개념이 없어서 원소들간의 순서가 없다!
                   foreach 문도 사용 가능 (JDK 1.5부터)                                            
              >> addAll() ()안에 있는 원소들을 다 추가해라
              >> containsAll() ()안에 객체의 원소가 비교하는 객체의 모든 원소에 포함이 되는가?
             >>  removeAll() 비교하는 객체의 원소중 ()안의 원소들과 겹치는 것들을 삭제   (차집합와 비슷)
              >> retainAll()  비교하는 객체의 원소중 ()안의 원소들과 겹치는 것은 남겨두고 나머지 삭제 (교집합와 비슷)
              >> list까지 오면 인덱스가 추가된다! (Vector / ArrayList) (이 두개는 거의 같다!) thread safe = Vector    / thread unsafe = ArrayList
                    즉, list는 순서가 있는 collection이다.
             >> Vector >> index가 존재하기 때문에 꺼널때 get(원소번호)를통해 꺼낼 수 있다! / remove도 인덱스로 지울 수 있다 (Vector는 원소 하나하나에 접근할 수 있다)
                                 add(index, 원소)  해당 인덱스자리에 원소를 삽입
                                 set(index, 원소)  해당 인덱스자리에 해당 원소로 변경
                                 for문과 remove를 통해 원소를 지운다면 앞에 것을 지우면 번호가 앞으로 당겨진다 극래서 모두 지우고 싶을땐 뒷번호부터 시작해서 지운다
                                 indexOf()  해당원소의 인덱스 번호를 구한다 (정렬이 먼저 필요!)(정렬없이 쓰면 성능이 안나온다)(중복되는 원소의 경우 제일 앞에 있는 원소의 인덱스를 불러옴)
                                 lastIndexOf() 해당원소의 인덱스 번호를 구하는데 중복되면 마지막 것을 고름
                                 indexOf(원소, 찾기 시작하는 인덱스번호) > 몇번부터 찾을 지 정할 수 있다!
                                 subList(처음인덱스,마지막인덱스) >> 부분적으로 원소들을 불러옴 / subList에 원소를 추가하면 원래 있던 객체에도 추가됨.
		     Collections.sort ()  >> 정렬
                                 Collections.max()  >> 가장 큰 인덱스 불러옴  / min() 가장 작은 인덱스 불러옴
                                 Collections.shuffle >> 섞어서 원소들을 불러옴
                                 Collections.reverse >> 반대로 원소들을 불러옴 (내림차순)
                                 Collections.binarySearch(객체, 찾고자하는 원소) >> 찾고자하는 원소의 인덱스값을 불러옴
                                 배열을 list로 바꾸기 >> List<타입> list = Arrays.asList(arr); 단, 길이가 고정된 리스트가 된다!                                  
 	                   가변길이로 하려면 새로 만들어서 새로만든 리스트 클래스는 생성자로 고정된 리스트를 받는다 
                                 객체.capacity >> 용량!!  (벡터는 처음에 10개의 원소를 담을 수 있는 용량을 준비했다가 10개의 원소가 다차면 용량을 두배로 늘린다!)
                                 객체.trimToSize() >> 남은 공간 낭비를 없애기 위해 해당 용량에 맞게 맞춰줌
                                 객체.ensureCapacity() >> 공간을 ()만큼 확보
                                 비교를할땐 equals는 필수!!  (객체끼리 비교할때 비교하기위한 장치가 필요!!)

Set >> 집합!!(중복을 허용하지 않는다)     Set을 구현하는  HashSet과 TreeSet이라는 클래스가 있다.
     >> 중복을 허용하지않기 때문에 중복된 원소는 취급하지 않는다 그래서 사이즈도 늘어나지 않음
     >> 유용하게 쓰이는 곳 : 중복되지 않는 값을 뽑을 때 
     >> TreeSet >> 자동적으로 정렬을 시켜준다
Map >> 지도를 볼때 지명을 보고 위치를 찾는다 그래서 key, value라는 정보를 가진다 
            value >> 찾는 값       key >> 식별자 (의미를 부여)(그래서 숫자가 아님)
           배열, 리스트는 인덱스라는 숫자를 통해 찾았기 때문에 의미를 담을 수 없다. 즉, 꺼내야지만 알 수 있다. ex 24가 무엇인가?
           한번에 볼 수 있는 방법이 뭐가 있을까 >> Map
           Map은 문자로 의미를 부여하기 때문에 저장용량도 많이 듬
           식별자는 중복될 수 없다! 한개의 식별자는 한개의 값을 가짐
           Hashtable , HashMap >> 이 두개가 Map에서 많이 쓰임 
           Hashtable<데이터타입, 데이터타입> map = new Hashtable<데이터타입, 데이터타입>(); > 이런식으로 만듬
                           (key)             (value)
           객체.put() >> 데이터 추가 (데이터가 중복되면 덮어쓰기가 되서 원래 데이터가 손상됨)
           객체.size() >> 데이터 길이 (데이터가 중복되면 원래 있던 데이터가 없어져서 데이터가 늘어나지 않는다)
           객체.get() >> 데이터불러옴 
           객체.containsKey(key) >> 해당 키가 있는지 확인하는 용도 있다면 true
           객체.comtainsValue(value) >> 해당 밸류가 있는지 확인 
           객체.remove(key) >> 데이터 삭제   
           map 반복문돌리기 >> Set<String> keys = map.keySet(); >> key만 다 들고옴! 
                                          Iterator<String> itr = keys.iterator();
                                          while(itr.hasNext()) {            
                                          String key = itr.next();
                                          String value = map.get(key);
          Collection<String> values = 객체.values() >> value만 다 들고옴
          내가 만든 객체로 key관리 >> 이퀄스를 해도 안됨 
                                                   해싱 >> 빨리 찾기 위한 방법중 하나  key와 해싱함수의 계산값을 이용해서 key비교
                                                               그 계산에서 나온 결과 값과 같은 결과 값이 나온 애들만 비교!(그렇게 하므로 비교횟수를 줄임)
                                                   해싱함수 >> Object클래스의 HashCode() : int   
                                                   해싱함수를 16진수로 바꿔줌!! (왜냐 ?? 주소값이 16진수임) 
                                                   그래서 비교하는 값들을 서로 같게 만들어줘여한다 (해쉬코드 오버라이드)
                                                   해쉬코드의 주의점 : a.equals(b)가 true일때 반드시 a.HashCode() == b.HashCode()가 성립해야함 (단, 역은 성립 x)
                                                   참조형을 구할땐 해쉬코드안에 해쉬코드를 넣어준다 (더 성능을 좋게하려면 '%4' 이런식으로 해서 구분을 더 시켜줌)
                                                   번외 :toString으로 오버라이드되어서 주소을 알 수 없을때 System.identityHashCode(객체)를 통해 16진수로 바꾸면 알 수 있다.
   
String >> String객체들은 상수 ->만들어지고 나서 변경이 불가능한 객체 /   
         >> 공유가능 >> String s1 = "abc"이 있다면 String pool이라는 곳에서 "abc"를 저장하고 만약 다른 String변수값이 abc라면 주소를 공유  
            String s1 = new String("abc"); >> 상수 !! (매번 생성함) >>Stringpool을 거치지 않는다.  >> 이 친구도 등록이 가능함!! (intern()을 통해서)
           ex. String s1 = new String("abc").intern();                                    
            String str = "abcde";  > ** str.charAt(2) , 결과: "c" >> 해당 문자열인덱스의 값을 들고옴   ** str.length() >> 글자길이
            str.trim() >> 앞, 뒤 공백을 제거( 바뀌는게 아니라 새로운 문자열을 생성)(원본 문자열은 바뀌지 않는다)
            str.codePointAt(문자) >> 문자열의 해당 문자를 아스킷코드값으로 보여줌
            str1.compareTo(str2)하면 서로 문자인덱스끼리 문자의 아스킷코드로 비교하고 길이가 다르면 -1을 반환
            정렬할때 compareTo말고 compareToIgnoreCase도 있다(대소문자 구분없이 크기 비교)
            equalsIgnoreCase도 있다 (대소문자 구분없이 내용비교)
            str1.toUpperCase() >> 대문자로 만듬    /       str1.toLowerCase() >> 소문자로 만듬
            str1.concat(str2) >> 문자열끼리 더해줌 /  str1.contains(문자) >> 문자가 포함되는가 str1.indexOf(문자) >> 해당 문자의 인덱스
            str1.lastIndextOf  /   str1.indexOf(문자, 시작할 인덱스)  
            str1.replace(문자1, 문자2) >> 문자 1을 2로 바꿔라 (새로운 객체가 만들어진것!)
            str1.substring(숫자) >>  해당 숫자인덱스부터 문자열을 불러옴  / str1.substring(숫자1, 숫자2) >> 해당 숫자1인덱스부터 숫자2인덱스까지 문자열을 불러옴
                   (indexOf랑 같이 많이 쓰이므로 기억해두자)
            str1.toCharArray() >> 스트링을 캐릭터배열로 바꿈 // 1. String.valueOf(캐릭터배열); 2. new String(캐릭터배열); 캐릭터 배열을 스트링으로 바꿈
=============================================================================            
            String file = "choonsik.jpg"   
            file.endsWith(".jpg") >> 끝이 이렇습니까?      file.startsWith("choonsik") >> 시작이 이렇습니까  (경로 찾을 때 좋다)
stringBuffer >> String과 비슷하지만 수정이 가능하다 .  mutable String 이다  (길이가 바뀔 수 있다.) 
                      StringBuffer buf = new StringBuffer();     
                      buf.append(문자)  >> 문자를 추가  
                      buf.insert(3, "x") >> 3번쨰 자리에 x를 삽입   // buf.delete(2, 5) >> 2번부터 4번까지 지움 
                      buf.reverse() >> 문자를 뒤집음
                      Stringbuffer는 왜 쓰이나?? String 보다 훨씬 빠르다!!! (toString 메서드에서 많은 양을 뽑을 때 사용)
                      StringBuffer buf = new StringBuffer(str); >> String -> StringBuffer
                      String result = buf.toString(); >>    StringBuffer => String      //  다루는 내용이 많으면 StringBuffer, 간단한건 String
                      String이 오래걸리는 이유는 String은 문자를 추가할 때마다 새로운 객체가 계속 생기기 때문!
System.currentTimeMillis() >> 1970년1월1일부터 지금까지 초로 나타냄
Date라는 클래스  Date d = new  Date(); >> 현재시간을 나타내는 클래스이다.
SimpleDateFormat >> text 패키지의 클래스 >> 날짜 설정은 내가 원하는 방식으로 표현가능
SimpleDateFormat s = new SimpleDateFormat("yyyy-MM-dd (a hh:mm)"); 2022-05-16 (PM 03:06)
String format = sdf.format(d); >> 문자로 나타냄
d.setTime(시간) 원하는 시간으로 세팅가능!
StringTokenizer st = new StringToKenizer(문자열 객체, 구분자들); >> 문자열안에서 구분자를 기준으로 문자열을 분할!! (구분자는 기본적으로 스페이스, 엔터)
String line =" 이 또한 흘러 가리라~";                                       >> 사용법은 이터레이터랑 비슷!!
while(st.hasMoreToken()) {        
      String token = st.nextToken();
}
                                                                                        >>st.countToken()>> 분할한 문자열의 갯수

배치 (Layer) >> 크기 + 위치 
컨테이너 >> 컴포넌트를 포함할 수 있는 컴포넌트!  (컴포넌트를 상속받음) (안에 뭔가를 담을 수 있음) 
LayoutManager >> 배치관리해주는 객체 (모든 컨테이너는 기본적으로 LayoutManager를 가지고 잇다) (컨테이너 안에 데이터들을 배치함)
기본적인 배치관리매니저
1. Border Layout >> 동서남북, 센터 이렇게 나누어서 배치하는 것 (종, 횡마다 사이즈의 영향을 받는 부분이 다르다) (하나의 영역에 하나만 포함가능!)
2. Flow Layout >> 중앙정렬이 기본 , 기본적으로 표시하는 내용에 따라 컨포넌트 크기가 바뀜 (선호크기)(임위적으로 바꿔줄 수 있다)
3. Grid Layout >> 줄, 칸으로 나누어서 배치하는 것, 이 레이아웃으로 배치된 컴포넌트들은 전부 크기가 똑같고 바뀌어도 같이 바뀜 , 줄칸에 따라 컴포넌트 크기가 바뀜 
                       합병이 불가능하며 순서를 띄울 수 없다 , 하나의 영역에 하나만 포함가능!
배치관리자는 자기가 가지고 있는 규칙으로 컴포넌트의 위치, 크기를 변경시킴 >> 규칙을 없애는 것도 가능  setLayout(null)로 바꿔줌 (쓰지마라)
JFrame의 기본 배치관리자는 Border이다!!
base-container >> gui를 만들때 반드시 있어야하는 컴포넌트 ex. JFrame
일반 comtainer >> 반드시 필요한 것은 아닌 컴포넌트 
컨포넌트들은 base-container에 부착이 되어야지만 가시성을 가짐 부착하는 메소드 : add();
JPanel >> 하나의 컨테이너로 레이아웃 속에 레이아웃을 넣을 수 있게 해주는 매개체 (패널안에 또 패널 넣고 가능)
레이블 >> 글자 그림 표현하는 것이 레이블이다.
원하느 색상 넣기 >> 색상표을 찾고 new Color(0xFFD8D8)를 넣어줌
로지컬폰트 : 가상머신에서 지원하는폰트    // 피지컬폰트 : 운영체제에서 파일로 지원하는 폰트
코드로 이미지의 크기를 조절하면 손상이 발생

이벤트 처리
이벤트 >> ui상에서 사용자가 하는 행동들
이벤트 소스 >> 이벤트를 발생시킨 컴포넌트 ex. JFrame , JButton 
이벤트 리스너 >> 이벤트가 발생 시 하는 일을 정의하는 객체 (인터페이스)
이름에 규칙이 있다. mouse event, mouse  listenner, action event , action listenner 
순서
1.ui구현 >> 처리할 이벤트를 결정했다는 뜻
2.이벤트 리스너 구현
3.이벤트 소스와 리스너 연결
Invoked가 쓰여있으면 우리가 그 메소드를 부르지 않는다!

equals >>> 중요!!!!!! (어떤 메서드를 통해 주소가 다른 객체로 어떤 값을 
                     찾을 때 또는 비교할 때 매우 요긴하게 쓰일 수 있음!!)

입출력 >> 읽기 쓰기   // 프로그램 성능과 관련이 깊다!! (패키지 : java.io)
중요한것!! >> 영속적인 저장소 ( 파일, 데이터베이스) 의 컨트롤  (일회성이 아니다!!)
입출력에선 파일을 컨트롤 하는것이 중요!!
읽고  쓸 대상 >> 파일!! 
파일 > 디렉토리(폴더) (경로) : 논리적 식별자  / 파일(a.txt)  
윈도우는 역슬래쉬라서 자바에선 역슬래쉬는 이스케이프 단어라서 두개씩  써줘야한다!

stream >> 입출력을 담당하는 객체들 
            특징 : 방향 (읽기와 쓰기를 동시에 하는 것은 없음)
                    순차적 ( 차례대로 도착)
stream은 byte단위로 읽기(InputStream) 쓰기(OutputStream)하고  캐릭터단위로 읽기(Reader) 쓰기(Writer)가 나뉜다!
원래는 바이트 연산만 존재햇지만 영어권이 아닌 다른 언어들도 사용하면서 캐릭터연산도 만들게 되었다
(바이트연산으로 다른언어를 하기엔 2바이트로 하거나 반으로 쪼개서 써도 글이 깨지기에 새로 만듬)
char >>(영어가 아닌) 글자로만 이루어진 경우  txt , java
byte >> jpg, avi, zip (안에 글만으로 이루어진 것이 아님) 
대부분 바이트 연산을 주로 쓴다!!
4개 다 추상클래스이다!!
파라미터 int라고 되어 있지만 이건 일일이 형변환을 해야하는 일을 간편하게 하기 위해 int라고 한것이고 자세히보면 byte char이다!

굳이 fileReader을 안쓰고 inputStreamReader 쓰는 이유 >> 강제적인것임!! 대부분 처음에는 바이트연산을 하기때문에 !! (ex. System.in)
                                                                                 그래서 원하는 형태로 바꿔쓸 수 있어야한다

네트워크 >> 디바이스와 디바이스가 통신이 가능하게 하는 통신망

ip >> 특정 디바이스를 표현하는 물리적 주소
port >> 특정 프로세스를 표현하는 논리적 식별자 (임의로 지정가능) 
도메인 >> ip를 나타내는 주소 (ip값이 바뀌어도 해당 도메인으로 들어갈 수 있다)
dns >> 도메인네임서버 
도메인을 쳣을때 dns에 가서 해당 도메인에 맞는 ip를 돌려받고 그 ip를 통해서 접속!

서버웹기술 서버에서 연산이 일어나느 기술
클라이언트 웹기술 클라이언트에서 연산이 일어나는 기술

html >> hyperText (비선형 문서 > 순서가 한 흐름으로 연결되어 잇는 것이 아닌 여러가지 짜잘하게 나누어서 연결됨)
       >> markup 랭귀쥐 > tag로 이루어져 있다 (tag는 복수개의 속성을 가짐)
      >> 확장자는 html, htm이 있다
       >> html문서는 텍스트 파일이다 (메모장에서도 볼 수 있다)
       >> 결과확인은 웹브라우저를통해 한다 (웹브라우저가 되는 조건은 html parsor, js parsor, css parsor) (해독할 수 있는 엔진)
<html> >> 여는 태그  
<head> 설정이며  눈에 보이지 않음
 </head>
<body> 사용자 화면에 보여질 내용들 (문서 구조) 
</body>
</html> 닫는 태그
태그가 열리면 나중에 태그가 닫혀야한다!!
속성 >> key(속성이름) = "value"(속성값) 속성이름, 태그, 속성 값 모두 소문자이며 속성값은 ""해줌
구조 <태그 이름 속성1 = "값1", 속성2 = "값2">
        </태그 이름> (닫음)
html의 공백은 엔터든 탭이든 스페이스든 한칸으로만 취급함
<br/> > 줄바꾸는 태그  html5에서는 <br>로 쓴다
<p> </p> > 문단 나눌때 쓰임
html은 문서를 어떻게 보여주는 것을 표현하는 것이 아니라 문서의 구조를 표현한느것이다
            (css)디자인부분은 css에게 맡김     
                              (html)
<h1~6> </h1~6> > 제목을 나타낼때 사용됨 (줄이 자동으로 바뀜)(검색도 도와줌)
<b>문자</b> > 굵은체 (css로 할 수 있다)
<Strong>문자</Strong> > b와 같이 굵은체지만 중요한 단어라는 의미가 들어가있다. 
<hr> 문서 내용 사이 수평선을 그어 구분할 떄 사용
<ul></ul> > 순서가 없는 목록을 표현할 때
<ol></ol> > 순서가 있는 목록을 표현할 때
<img src = "이미지주소" alt = "엑박뜰때"></img> > 이미지를 표현 (이미지를 가지고 있거나 인터넷상 이미지 주소를 들고올 수 있다)
(이미지 주소로 쓸경우 작성자가 이미지에 대해 주소를 바꾸거나 삭제할경우 따라서 같이 바뀜)
(alt는 이미지가 뜨지 않을때 해당 문자가 뜸 , border은 테두리 치는 것, hspace, vspace 사진의 횡,종 간격)
<a href = "연결페이지"></a> > 페이지를 연결해줌(중요)
(같은 .html파일을 연결해서 비선형문서로 만들수 있음 단, 파일이 서로 같은 위치에 있어야함)
(target > 새테이블로 열지 현재 페이지에서 연결할지 정함) 기본값은 "_self" , "_blank"(새창)
(id > 페이지 내 해당하는 이름위치로 이동) 
<a id = "아이디"> 링크를 눌럿을때 나올 값
<a id = "(해당사이트주소)#아이디"> 링크하기 누르기 위한 값(아이디 값은 유일해야함)
자주쓰는 특수문자
"<" -> &lt;
">" -> &gt;
"&" -> &amp;
" " " -> &quot;
공백 -> &nbsp;
<body link = "#ffffff" vlink = "#000000" alink = "#f12a2b"> -> 바디에 색을 넣을 수 잇음
          (평소링크색)   (이미 누른 링크색) (동작하고 잇는 링크색)
<table> ~ </table> 표의 시작과 끝을 정의
줄 나타내는 태그 tr  (행)
칸 나타내는 태그 td (열)
th는 열이 자동적을 정렬되고 굵은체가 됨 (제목에 대한 것을 쓸때 씀)
셀병합도 가능! - 가로로 병합 : <td colspan = "차지할 칸수"> 왼쪽 기준으로 칸을 차지
                     - 세로로 병합 : <td rowspan = "차지할 칸수"> 윗쪽 기준으로 칸을 차지 
<caption>표 이름</caption> -> 표이름을 설정
thead tfoot tbody를 나누는 것은 논리적인 그룹핑이다!
<style>에서 css로 표에 대한 레이아웃을 정해준다!!
css에서는 셀렉터가 들어감 (어떤 애한테 적용할지)

class를 통해 변경이 필요한 것들을 묶어서 사용가능(id는 하나만 가능)
클래스로 묶은것 중에서도 태그로 나누어 적용가능 ex p.javaP { } 
<form> ~ </form> -> 사용자의 선택, 입력을 전송할때 필요
method > get방식 또는 post방식으로 보냄
action > 전송시킬 곳
<form name = "전송단위구분" method = "방식" action = "전송시킬곳">
로그인 정보를 전송하기 위한 것하나 검색을 위해 값을 전송하는 것 하나 등 
전송하는 값이 다를 때 form을 나누어서 사용한다.
값결정의 주체가 사용자인데 hidden태그는 값결정을 임의로 우리가 정함
<meta> 태그 -> <head> 사이에 있어야함! (meta태그 다시 보기)
<!DOCTYPE> 이란??? 찾아보기

database >> 두개로나뉨 (DBMS(매니지먼트시스템), Database)
             >> Database에 실질적인 자료가 저장되어 있고 매니지먼트을 거쳐서 데이터를 접근함(게터세터느낌))
             >> query(질의) >> sql언어로 요청을 함!	(테이블을 어떻게 조작하는가가 중요)
             >> 데이터베이스는 복수개의 테이블로 구성되어 있다
             >> 릴레이션 -> 테이블 (행위 -> 메서드, 상태 -> 멤버변수 같은 느낌)
                   논리                                           물리
               릴레이션            >                        테이블
                속성                >                         필드
               tuple(고객하나 정보)  >                   레코드
             >> 복수 데이터를 만들때 항상 식별자(key)가 필요함!
                  후보키 : id , 주민번호 
                  주키(primary key): id (고유의 식별자) (변경 불가)
                  대체키 : 주민번호 (id대신 할 수 있는 식별자)
                  슈퍼키 : 식별 가능한 열의 집합 (유일성만 강조)
                  외래키(foregin key) : 다른 테이블의 정보를 참조하기 위해 사용된 열(key의 집합)
                                                단, 외래키는 주키여야함!
                  unique 속성 (키x): 중복이 불가능하지만 주키랑 다르게 null이 허용되며 변경이 가능하다 
             >> 무결성 : data를 만족하기 위해서는 3개의 무결성을 만족해야함
                   1. 개체 무결성 > 주키가 존재하고 있어야한다
                   2. 도메인 무결성 > 열의 제약조건에 만족하는 값이 와야함(ex.나이는 문자x 마이너스x 0이상을 지키는 값들만 올 수 있음) 
                   3. 참조 무결성 > f.k가 만족해야함    
             >> 정규화 : 6차정규화까지 존재 
                     1차 : 열은 원자적 값만 포함, 같은 데이터가 여러열에 반복되면 안됨(동아리에 대한것이라면 동아리1,동아리2 이렇게 x)(잘라서 사용)
                             원자적인 값은 상대적임 (다시듣기)
                     2차 : 완전 함수 종속 구현 >> p.k가 복합키(두개이상의 열의 합쳐 키를 형성)일때 발생
                                                              (하나의 속성으로 p.k가 구성된 경우 이미 만족함)
                             p.k에 따라서 해당 열의 값이 정해짐 .>> 함수 종속
                             여러 p.k가 관련되어 열의 값이 정해짐 >> 완전함수종속
                             하나의 p.k가 관련되어 열의 값이 정해짐 >> 부분함수종속
                     3차 : 이행적 함수 종속 제거 >> key가 아닌 열에 종속되는 현상 (key로 만들어서 떼어내면 해결)

jsp 기본 객체

기본객체 : request, response pageContext, session, application 등이 있다 ( 다중요)
사진1 참조 ( 타입도 중요))
out 기본객체 : jsp페이지가 생성하는 모든 내용은 out 기본객체에서 출력됨(브라우저에 뿌려주는 객체)
사진2참조 (이런 경우에 out객체가 쓰임!! 그 외에는 잘 쓰일 일이 없다)

pageContext > 1. 기본객체 구하기 (jsp에서는 기본객체이 이미 존재해서 필요없지만 서블릿에서는 기본객체를 만들때 필요)
                     2. 속성 처리하기
                     3. 페이지흐름 제어
                     4. 에러 데이터 구하기
                  > 사용은 드물다
application 객체
사진참조3 (기본 객체 구하는 메서드들이다 대충 기억만)(불러오는 요청,응답의 클래스가 상위클래스라 형변환이 필수) 
사진참조4 (프로그램 전체에서 사용될 값의 경우 web.xml에 이런식으로 넣어서 사용) 

로그라는 메서드도 지원 (한번더 보기))                >>
jsp자체에서도 제공하는 로그도 있다( log();)) w     >> was마다 다르게 적용됨

자원 구하기(readFileDirectly.jsp을 참조) >> 이게 어디서 쓰이나?? >> 사용자가 편하게 내용만 넣어서 올릴 수 잇음(?? 이것도 다시 확인)
보통은 웹어플리케이션 내부경로를 쓴다 (readFileDirectly.jsp처럼 간단하게쓰지 않음)
사진5참조 (중요한 메서드(내부경로지정)!!!기억할것!!))
개발하는 컴퓨터경로와 운영할때 컴퓨터의 경로가 절대 동일하지 않기 때문에 !! 내부경로를 따로 써야함!
(같게하려면 운영, 개발 경로를 전부 똑같이해야하는데 개발할때 Stream클래스에서 정한 주소로 인해 문제가 발생해서 같을 수 없음
그래서 "/" 절대경로(어플리케이션 내부 경로)로 사용한다(루트는 프로젝트파일이다)
어플리케이션 내부 경로로 어플리케이션 메서드를 사용해서 코드의 변경없이 해당파일이 어디에 있든 불러오는것이 가능 

-추가사항-
get은 그냥 읽을 때 post는 값이 바뀔때 (추가, 업데이트, 삭제등)

사진참조1(미친듯이 중요)
사진참조2(미친듯이 중요)
jsp페이지마다 pagecontext가 있으며 Jsp가 바뀔때마다 pagecontext도 바뀜
request는 응답이 갈때까지 유지 (즉, jsp파일을 여러개 걸칠경우 다 같은 request이다)(request를 공유)
session는 클라이언트(브라우저)별로 하나씩 있다(브라우저 종료, time out, 의도적인 종료에 해당하면 없어짐)
application 웹 어플리케이션 당 하나(모든 클라이언트가 공유, 모든 JSp가 공유)(was가 시작되면 생기고 종료되면 없어짐)\
웹 어플리케이션 == 프로젝트파일 

속성은 속성이름, 값의 형태를 가짐(map)
기본객체의 속성 사용하기 > 
사진참조3(완전 중요 메서드) 
setAttribute(값을 설정)
getAttribute(값을 불러옴)
removeAttribute(속성을 삭제)
키는 스트링이지만 값은 오브젝트형이라 형변환을 해줘야함!!
사진4,5참조(쓸때 형변환해줘야함)
동영상 다시 보기 (유지되는 부분 jsp파일)
사진6(속성쓰임새)

parameter <-----------> attribute 
(사용자가 정함)         (코드 상에서 정함 개발자가 사용)
(이걸 부르는 것말고   (바꾸는 거 가능)
할 수없다)(훼손불가)

jsp에서는 예외가 일어나지 않음 (try안써도 적용이됨)
서블릿으로 바뀔때 throws로 던져주기 때문!
서블릿 메서드????(다시보기)
init > 시작할 때 1번
service > jsp의 스크립트릿, 표현식들은 모두 service메서드로 들어감 그리고 서비스 메소드가 실행될 때
             기본객체들을 먼저 정의하고 나서 jsp값들을 실행한다. 그래서 기본객체는 선언 안해도 쓸 수 있느 것처럼 보인다.
             (선언부는 service메서드에 안들어간다 그래서 선언부에는 기본객체를 쓸 수가 없다)
destroy > 삭제될때 1번
1. 사진참조 1(에러)
좀더 우아한 문제 발생에 대한 처리를 위해 에러페이지를 따로 만들어줌
errorPage >> 에러뜰 시 이 페이지를 보여줘라라는 뜻
isErrorPage = true >> 에러뜰 때 발생했을때 오는 페이지라는 뜻(여기서는 true라면 기본객체 exception을 쓸 수 있다)
그리고 에러떠서 페이지가 넘어가도 주소값이 바뀌지 않는다!! 
(익스플로러는 해당 에러페이지가 512kb를 넘어야 하기때문에 for문 같은 걸로 용량을 채워줘야함

버퍼와 에러페이지의 관계
사진2참조
첫번째 버퍼가 플러쉬되면 응답코드가 확정이난다 그리고 플러쉬되어서 변경이 불가능!!
만약 첫번째 버퍼 이후에 예외가 발생한다면 버퍼의 크기를 키워야한다( 예외가 발생하는 부분까지 첫번째 버퍼가 담도록 보장해주어야한다)
                                                            아니면 해당 예외부분을 위로 올린다(하지만 다른 값들과 연관이 많을 경우 불가능)
2. 응답메세지마다 에러페이지 지정하기
사진3 참조 (web.xml에서 <error-page> 태그를 사용!) (import에 errorPage와 isError페이지를 해줄 필요가 없어짐)
3. 익셉션타입마다 에러페이지 지정하기
사진4 참조
에러페이지 우선순위와 지정형태 
1순위 page디렉티브의 여부  2순위 타입별로 설정 3순위 에러코들로 설정 순위가 높을 수록 우선되어 브라우저에 나옴

web.xml에서 code별로 에러페이지 설정 > 404, 500
따로 처리할 필요가 있다면 타입별로 에러페이지 설정 > 여러 타입
디렉티브 

반대순서로 에러페이지를 설정함 (대중적인 에러코드는 코드별로 설정해주고 특정한 익셉션의 경우 따로 설정
                                              그리고 또 그안에 개개별로 에러메세지가 떠야한다면 디렉티브로 설정해준다.
<jsp: include page= "해당파일"/>    -> 액션 태그 (해당 파일의 버퍼를 공유함!!) (즉, 해당파일의 내용을 본 파일에 들고옴)
              출력버퍼를 이용해서 물리적으로 분리되어있는 파일을 논리적으로 결합시킴
              flush가 트루라면 액션태그가 발동하기 전에 버퍼를 flush함!!
              쓰는 용도 : 해당 파일을 여러 곳에서 쓸때(재활용) 사용됨!(메서드를 쓰는 것과 비슷함)
              request객체의 범위를 생각하면 본파일과 해당파일이 공유됨
              include되는 파일은 html순서를 넣으면 안됨 (이미 결합되는 파일에서 html이 있기때문)
<jsp:param   -> include로 버퍼를 공유할때 다른 파라미터를 해당 파일에 던질 수 있다
                    사진5 참조 (추가한 파라미터의 가용범위는 버퍼가 공유되는 파일부터 가능)
                    파라미터 밸류값이 한글일 경우 본 파일에서 request.setChar을 해줘야 안깨짐!
               

해당파일에서 본파일로 파라미터를 던지는 방법
attribute를 사용!! (request객체를 이용) 
include 디렉티브를 이용한 중복코드 삽입
사진1참조 (액션 include vs include 디렉티브)
내용을 현재위치에 삽입후에 자바파일로 변환하고 컴파일함
(어떤 값을 가져올 때 많이 씀)
<jsp:include> Ui구성요소 중복
<%@ include> 어떤 값 , 연산 중복
jspf값을 변경했을 때 jsp에 적용된 값이 바뀌는 보장이 없음 (적용이 안될 때있는데 지우면됨)
해당 jspf파일을 인크루드하는 파일이 많다면 web.xml에 등록해서 <%@ include>안써도 자동으로 적용되게 가능하다
사진2 참조 <url-pattern>/view/* >>view밑에서 부터 적용
prelude : 적용하고나서 상단  coda: 적용하고나서 하단
그리고 태그는 넣으면 안됨!
사진3 참조 (중첩해서 사용 가능!) (단, 중첩이 많을 경우 해당 변수가 어디서 왔는지 알아보기 힘듬)
사진4 참조 (서로 비교)

<jsp:forward>액션태그 >> 리다이렉트와 하는 역할은 비슷하지만 다른 점이 있다.
                         1. 주소 : 이동시킨 곳의 주소를 알 수 없다 (요청한 페이지의 주소만 알려줌)(사용자가 의도하지 않은 곳으로 못가게막음)
                         2. 구조 : 사진1참조 (~할때 포워드를 씀) (다시보기) 5분~
                         3. 연결 : 포워드는 서로 리퀘스트 객체를 공유함
                         ** 에러페이지를 설정할때랑 구조가 완전히 비슷
                         4. 실행 :  포워드는 포워드문을 만나면 바로 이동해서 밑의 코드를 읽지 않는다.
                                      포워드문은 쌓여있던 출력버퍼들을 버리고 해당 파일로 이동(그래서 해당 포워드문이 실행되기 전에 flush되면 안됨)
                                     (리다이렉트는 읽음)
                         ** a, b, c를 기능을해야하는 페이지가 있다면 하나씩 기능을 나눠서 유도리있게 왓다갓다 가능(기능별로 모듈화)
사진참조2 (리다이렉트,<form>, <a>랑 포워드는 루트의 정의가 다르다) (+ html도 루트는 /이다) 
               (즉 내부만이 아니라 외부로도 보낼 수 있으면 루트는 로컬호스트 8080/ 이다!!)
               (포워드는 내부에서만 가능해서 루트는 로컬호스트 8080/07_22 이다.)
request.getContextPath() >> 프로젝트 주소까지 를 보여줌 (ex. 로컬호스트 8080/07_22)
<param> 쓰는것보다 attribute쓰는 것이 더 좋다
임의로 접근 못하게 하려고 WEB-INF안에 파일을 넣어서 접근할 수 있는데 
그때 접근할 수 있는 방법이 forward이다!

자바빈(단순히 값을 나타내기 위한 객체)
멤버변수가 프라이빗 파라미터에 아무것도 없는 기본 생성자가 있고 게터세터있으면 자바빈 이라고 한다
<jsp:useBean 아이디 , 범위(속성), 해당클래스 /> 
사진참조1 (둘이 방식이 같다)(즉, 저런 긴 줄을 한줄로표현가능)(class대신 type을 쓸 수 있음)(다시보기1시간0분)
사진참조2( == member.setName())
사진참조3(편하게 한줄로  쓸 수 있음)(세터값을 넣어줄 수 있음)
<jsp:setProperty name= "dd" property = '*'/> : 파라미터로 받은 이름이 멤버변수이름이랑 같은 멤버변수에 모두 파라미터 값을 대입!! 
참고로 형변환까지 알아서 해줌!! 파라미터가 int면 value값도 int
<jsp:getProperty> : 게터 (단순히 html로 보여주는 것)
(사용빈도가 낮아진 이유 : 눈에 보여지지만 우리는 눈에 보여질 페이지를 만들지 않기 때문(결국 나중에 클래스로 만들거임!)
EL(expression Language) 보통 useBean 보다는 보여줄 페이지의 경우??? 이것을 씀!! (2시간 8분)
쿠키 >> 클라이언트의 상태를 저장 (클라이언트측에 저장, 서버측에 저장)
사진참조4(쿠키의 움직임)        
            쿠키는 클라이언트에 저장하는 데이터이다 (브라우저)
            쿠키는 응답헤더에 저장이됨 쿠키를 다시 서버에 전송할 때도 요청헤더에 들어감
사진참조5(쿠키의 구성  이름하고 값이 제일 중요)(그리고 복수데이터가 아니라서 1대1매칭이됨)(이름하나 값 하나)
              (쿠키는 유효시간을 정해주지 않으면 브라우저가 종료될때 사라짐)
사진참조6(쿠키 생성하기)(헤더에 담겨가기 때문에 flush되면 변경이 불가능하다 즉, 그전에 심어줘야함)
사진참조7(키의 메서드)
사진참조8(쿠키 값 읽어오기)
쿠키사용 이유 : 쿠키의 여부에 따라 페이지 상태를 보여줄 수 잇음
쿠키라는 기술은 사용자가 쿠키를 허용할때만 받을 수 있는 것이기에 보조수단 같은 것이다
쿠키는 이미 있는 키를 새로운 값을 주면 기존에 존재하는 키는 덮어씌워짐
쿠키는 그 쿠키를 만든 사이트에만 전송을 할 수 있게되어 있음
여러사이트에 쿠키를 보내고 싶다면 setDomain()을 통해 도메인을 지정해준다.
기존값으로 만든 사이트
.somehost.com >> 점으로 시작하는 관련 도멘인에 모두 쿠키를 보냄
www.somehost.com>> 점으로 시작하지 않는다면 특정 도메인에만 쿠키를 보냄
사진참조9 (setDomain, setPath)
유효시간 메서드에 -를 주면 브라우저를 종료했을 때 쿠키종료

세션 (브라우저를 끄지않는 이상 유지됨)
쿠키랑 차이점은 세션은 서버에 값을 저장함 (쿠키는 브라우저)
세션은 공유되지않고 각 브라우저마다 할당되기에 브라우저의 값들을 넣기 좋다
사진참조1(jsp파일로 요청한다는 것은 우리가 임의적으로 안써도 세션객체를 쓴다는 것!!
              그래서 최초요청시간, 마지망 요청시간으로도 볼 수 있다)
getId는 서버에 여러 사용자가 들어오면 여러 세션이 생성이 되는데 구분하기 위해!!
JSESSIONCOOKIE >> 고유 id를 들고있는 쿠키
쿠키 대신 세션을 사용하여 값을 저장해서 사용할 수 있다.
세션이 쿠키보다 더 사용되는 이유는 1. 세션이 보안에서 앞선다
                                                  2. 세션의 경우 쿠키설정여부와 관계없이 사용할 수 있음 
                                                  3. 세션은 여러서버에서 공유가 불가능 (ex. www.daum.net세션과 mail.daum.net세션은 서로 다름)
                                                     (반면 쿠키는 여러 도메인 주소에 공유가능함)
세션종료 
1. 브라우저 종료
2. session.invalidate()메서드로 종료(중요)(정확히는 기존 세션객체가 다른 새로운 세션객체로 바뀜
                                                 그러면서 기존 세션객체의 값을 다 삭제함)
   클라이언트 상태를 초기화할 때 / 로그아웃할 때 유용 (속성을 통채로 없애버림)
세션유효시간 
네이버에서 유튜브로 사용자가 옮겼을 때 서버는 해당 세션 객체를 들고 있을 이유가 없다
(그 사용자가 다시 온다는 보장도 없으며 많은 세션들이 메모리에 올라오는데 공간을 절약해야하기 때문)
그래서 마지막요청시간을 기준으로 일정시간까지 아무런 요청이 없을 경우 세션을 삭제!
(이게 반드시 필요!! 아니면 서버는 죽게됨(메모리 오버 플로우))
세션유효시간은 두가지 방법으로 설정 
1. web.xml을 이용해서 <session-config> <session-timeout>시간(분) 을 써서 지정가능 ->대부분 이 방법 사용
2. 파일에서 세션객체.setMaxInactiveInterval(시간(초))를 이용!
request.getSession() >> 요청객체로부터 세션을 구하는 메서드
invalidate가 되지 않은 세션이라면 그것을 리턴하지만 invalidate가 된 세션이라면 다음 할당될 세션객체를 미리 할당가능
(이 메서드를 안쓰면 다음 요청에서 얻을 수 있지만 이 메서드를 씀으로 미리 할당받음)
getSession() == getSession(true) 
사진참조2
getSession(false) >> invalidate가 되지 않은 세션이라면 그것을 리턴하고 invalidate가 된 세션이라면 null을 리턴
invalidate하면 세션객체가 사라지는 것이 아니라 더이상 그 세션의 속성에 접근할 수가 없어짐
그리고 새로운 세션객체는 다음 요청에서 바뀌게 됨!(즉, 다음 요청전까지는 세션객체는 그대로 유지됨 단, 속성접근은 불가능)
나중에 getSession()을 통해 세션을 구하고 getSevletContext()를 통해 어플리케이션 객체를 구함
사진참조 3 (세션은 프로그램단위로 할당되기때문에 /ch10 와 /ch10_2 는 다른 세션을 가진다)

css는 따로 파일을 만들어서 쓰는 것이 좋고 세세한 부분은 페이지안에서 해줌
js에서 <form>을 들고오면 배열처럼쓸 수 있으며 원소는 <input>들이다
js에서는 문자열은 equals쓰지않고 == !=를 쓴다.
getElementById("")  >> 15분 다시보기
js는 false로 판정되는 값이 존재한다 (null, undefined, +0,-0, NaN, false)
js에서는 변수가 값을 가지지 않은 상태가 존재할 수 있는데 그것을 undefined라고함
NaN(Not a Number)
isnan >> 숫자인지 아닌지 판단 (숫자가 아니면 true)
js는 비교할때 타입상관없이 비교한다(자동으로 형변환을 함) '==='을 해야 자바와 비슷한 ==의 역할을한다
삭제한다고 값이 삭제되는 것이 아니라 접근을 불가능하게만 함

<script>는 바디 안 맨끝에 쓰는게 좋다
<script>문이 바디보다 앞에 있을 경우 body안의 html의 태그의 원소를 들고올 때 차례대로 읽기 때문에
script부터 읽으면 원소를 인식을 하지 못한다  (마짐막태그라서 프로그램이 문서구조를 다 읽었기때문에 태그 원소를 들고오는 것이 보장이됨)  2시간 23분
자바스크립트 에러 찾기 >> F12를 누르면 개발자모드로 보이는데 거기서 에러뜬 부분이 보임
자바스크립트 디버그 >> console.log(자바의 System.out.println) 해서 F12에서 'console'에서 확인가능

이제 모든 요청을 받는 jsp가 필요 즉, 모든 jsp들이 이동할때 저 요청파일을 지나감 >> 이게 무슨방식??

자바스크립트에서 함수안에 파라미터를 받아오기 >> arguments[]
arguments[0]>> 첫번째 파라미터 arguments[1] >> 두번째 파라미터 
사진참조 2 (무조건 저렇게써야 적ㅇ요됨)(js파일에 있는 함수를 호출하는 방법)
js로 파일을 따로 뺏으면 가끔씩 적용이 안될때가 있는데 그때 캐시를 삭제하면 됨
pointCheck[1].selected = true; 하면 시작할때 셀렉태그의 인덱스1의 옵션이 적용되어있음

자바스크립트의 배열은 대괄호로 표시함 var pass = []; >> 배열 선언
var pass =["a","b","c"] 선언과 정의
자바스크립트의 배열은 길이가 가변적임(타입이 다른것도 다들어감)

사진참조1

sql 환경잡기 >> netstat -ano라고 하면 포트번호를 보여주는데 spl은 기본 주소가 3306이기에 
                       거기에 어떤 것이 쓰고 있다면 pid값을 보고 작업관리자에서 해당 pid번호를 찾아서 
                       지워야함 (이미 주소가 할당되어 있어서 다운이 안될 경우)
사진참고1 (이건 건들면 안됨 (실행에 필요한 db이다))
쿼리를 눌러서 실행문을 넣으면 됨 실행은 'F9'
실행할때 드래그해서 실행(원하는 곳만 가능)
sql문은 키워드는 대문자  이름, 값은 소문자 
글자는 char, varchar로 표현
char(바이트 수) >> 바이트 수는 크기를 뜻함(한글자가 몇바이트를 잡아먹느냐에 따라 지정하는것이 달라야함)
char, varchar의 차이점 >> 가변길이의 차이
char은 바이트 수만큼 칸을 만들고 거기에 값을 넣음 
varchar은 바이트 수만큼 칸을 만들고 거기에 값을 넣지만 빈칸은 지워버림
그러면 varchar이 좋은거 아닌가?? 
수정이 일어날때 char의 경우는 한칸비었으니 거기에 채우면되지만
varchar의 경우는 공간을 절약해서 빈칸을 지워버렷기 때문에 수정할때 칸을 모두 땡겨야하기 때문에 부하가 일어남
사진참조2
그래서 varchar은 수정이 되지 않는 키에 종종 사용됨
변경이 자주되는 키는 char로 해주는 것이 좋다 
 
int(숫자) >>(숫자)는 절대 범위가 아님
NOT NULL; >> 필수로 기입해야한다는 뜻
PRIMARY KEY; >> 프라이머리키로 지정

2시간 13분 원리 다시보기
2시간 반 연결 원리 다시보기
3시간 3분 url에 대한거 다시보기
1시간 10분 rs.next에 대해서 다시보기


1시간 35분 다시보기 pstmt
JUnit 테스트를 위한 프레임웤 
기능하나 만들고 테스트 하는 것을 단위테스트라고 함 그걸 지원하는 것이 JUnit 
TDD

사진참조 1 (쿼리문 안에 쿼리문이 가능)
연산의 결과가 한줄일 때만 가능(스칼라일때만 가능)
AUTO_INCREMENT >> 1씩 증가함 (단, 테이블당 한개만 가능하고 주키만 가능!! mysql만있음! (같은 기능은 모든 DB에 있음))
null값을 select할땐 IS NULL해야한다!
보통 NOT은 WHERE 바로 뒤에 온다
COUNT(열) SUM AVG MAX MIN 등등으로 계산 가능
rs.getInt(숫자) 숫자는 불러온 값들의 열 인덱스를 뜻한다 
집계함수는 값을 합쳐 한개로 만든 값을 말함 (스칼라 값)
서브쿼리 >> 주의점 : where뒤에 열항목 수랑 서브쿼리문의 열 항목수는 같아야함 

Spring.io
Spring tool suite : 스프링이 아님 ! (스프링을 개발하ㅣ 위한 툴)

j쿼리
다운 받아서 쓰던지(라이브러리파일을 직접 들고있는것) , 아니면 외부에서 들고와서 쓰는 방식이 있다(브라우저가 읽을때 외부에서 들고오는 방식)
인터넷이 안되면 후자방식은 불가능함
셀렉터 >> $("셀렉터").action
p는 모든 태그요소 
#은 id
.abc는 클래스
p a  -> 자기 밑에 있는 모든 자식들
p>a -> 자식(바로 밑에 있는 자식)

$(document).ready(function() {       16분다시보기
해당 다큐먼트가 준비가 되면(브라우저가 DOM트리를 완성시키면(즉, 문서구조를 다 읽으면)) 
function()을 실행함!
});
자바스크립트는 변수에 function(함수)을 할당할 수 있음
그래서 어떤함수에 함수를 할당한 변수를 파라미터로 받을 수 있다!
사진 1 사진2 
$(this) >>자기자신
.hide() >> setVisible(false)랑 같다
.hover() >> mouseEnter + mouseLeave >> 그래서 두가지 함수가 들어감! (사진3)
.hover(들어왓을때 할일, 나갈때 할일) >> 두가지 파라미터가 들어올 수 잇음
.focus >> 해당 구문을 클릭했을 때 
.blur >> focus를 얻은 상태에서 잃은 상태일때 (다른 포커스로 이동했을대)
.on >>  함수를 객체로 정의 가능하다! 해당하는 Event구문을 사용!! (사진4) 1시간 부터 다시보기
 (사진5)
.each >> 앞의 대상들에게 해당 일을 시킴!!
a.val() >> a의value를 가지고와라
a.val("abc") >> a의 value를 "abc"로  설정하라
(사진6) (검사기)
.attr("속성") >> 해당 속성에 맞는 값을 들고옴 
(사진7)
.prop("속성", false) >> 해당 속성 값을 false로 바꿔라!
.length >> 해당 갯수 
.is("조건") >> 조건이 트루입니까??
.parent() >> 부모를 불러옴
.children("조건") > 조건에 해당하는 자식을 불러옴
.html() >> 해당 태그의 안 내용을 들고옴
.html("") >> 해당 태그 안 내용으로 바귐
AJAX > 비동기를 구현하는 자바스크립트와 xml이라는 뜻
비동기 >> 사용자가 인지하지 못한 상태에서 request가 날아가는 방식
.change(함수) >>  내용이 바뀌면 함수를 실행
json > 자바스크립트로 객체를 표현하는 형식, 방법
json은 언어에 제한되지 않음
json으로 바꾸는 이유 >> 값을 브라우저에서 바꾸기때문에 자바객체에서 json으로 바꿨다가 자바스크립트 객체로 바꿈
자바를 json으로 바꾸는 라이브러리가 jackson (근데 바꿀 수 있는 라이브러리는 엄청 다양함) 
@Responsebody >> return값이 뷰이름이 아닌 바로 브라우저에 전송
(3시간 3분부터 다시보기)

JSON.stringify(자바스크립트 객체) >> 자바스크립트 객체에서 json객체로 바꾸는 방법
person.name == person["name"] >> 이렇게 해당하는 객체의 멤버변수를 불러올 수 잇음
json은 자바스크립트와 자바를 이어주는 매개체 역할이다. 
왜 xml을 안쓰고 json을 쓰는가? 
자바 배열: [배열내용]
json배열 : '[배열내용]' (문자열형태)

@Configuration이 붙은 클래스 >> 자바코드로 bean을 등록 가능하다 (@bean이 붙은 메서드로 등록)