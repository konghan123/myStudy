1. 성능 이슈 SQL 패턴
- 비표준 구문 사용(JOIN)
- Search Argument 위반
- 불필요한 I/O 유발 (같은 테이블 조인)
- 불필요한 임시테이블, 변수
- 불필요한 Cursor/Loop 사용
- 부적절한 함수/뷰 사용
- 부적합한 프로시저 내부 코드 구성
- 부적절한 만능 조회

2. 인덱스 사용 여부 판단
- SSMS
-- 실행계획에서 인덱스 검색, index seek 라는 값을 통해 
  인덱스를 사용중 인것을 알 수 있음
-- 실행계획에서 인덱스 스캔, index Scan, 테이블 스캔 이라는 값을 통해 
  인덱스를 정상적으로 사용 불가능한 것을 확인 할 수있음

- mySql, MariaDb
-- 실행계획의 type이 const(single row), range(index range scan), ref(Non-Unique.....) 이면 인덱스가 사용되고 있는 것을 확인 가능
-- 실행계획의 type이 ALL이면 인덱스를 정상적으로 사용 불가능한 것을 확인 가능

3. ANSI ISO 표준 사용하기
- ANSI ISO 표준은 성능과 유지관리에 영향을 미침
- ISO 표준이 아닌 예시
-- JOIN을 사용하지 않고 FROM에 테이블 두개를 쓰는 경우
-- WITH ROLLUP을 쓰는 경우

4. WHERE, JOIN 절 작성 순서
- WHERE, JOIN 절 조건의 순서는 쿼리 성능과 별로 연관이 없다.
  왜?? Query Optimizer가 교환법칙, 결합법칙에 근거하여
  쿼리 실행 시 자동으로 WHERE, JOIN 절 조건 순서를 지정해줌.
  따라서 개발자는 유지관리 측면에서 WHERE, JOIN절 순서를
  생각해볼 필요가 있음
  ex.
  (10/ a > 0) AND (a <> 0)
  (a <> 0) AND (10/ a > 0) 
  첫번째조건에서는 실행 시 0나누기 오류가 떠야하지만
  Query Optimizer가 자동으로 조건 순서를 맞추어 오류가 뜨지 않음

- 주의 사항 
-- 교환법칙, 결합법칙의 대전제는 순서를 바꿔도 결과 값이 동일하다는 점이다.
   즉, JOIN의 경우 LEFT JOIN, OUTER JOIN은 순서에 영향을 받기에
   Optimizer의 교환법칙, 결합법칙이 성립되지 않음
   (INNER JOIN만 가능)

5. 스키마 이름 지정
- 쿼리에서 테이블을 쓸때 스키마 이름을 지정하면
  성능을 올릴 수 있다.
- 테이블 이름을 해석할 때 스키마에서의 객체를 확인하여 해석하는데
  스키마 생략 시 해당 테이블의 ID를 사용하여 해석하게 되면서
  불필요한 코드를 사용하게 됨. (작은 부하를 일으킴)
- 테이블 앞에 스키마를 붙이는게 성능, 유지관리, 보안 측면에서 좋음

6. 날짜시간 상수 값 
- DATE타입을 사용할 경우 ms까지 표현할때
  소수점 3자리까지 표현이 되며 .999가 되면 1로 넘어감
  BETWEEN을 사용할 경우 ms .997까지 로 표현하는 것이 좋다.
  
- 검색 시 후행 공백을 제거하기 위해 RTRIM을 사용하는데
  후행공백이 있든 없든 비교연산을 할 때는 RTRIM을 쓸 필요가 없이
  그냥 써도 검색이 가능하다. (불필요하게 RTRIM을 쓸필요가 없다)

7. 조인 조건, 검색조건 구분 (조건을 어떻게 구분해서 쓰는게 좋은지에 대해)
- 결과적으로 의미에 맞게 조건을 넣는 것이 좋다.
   (Query Optimizer가 쿼리를 재조정 해주기 때문)

- OUTER JOIN의 경우 해당 조건을 조인조건에 넣냐, 검색조건에 넣냐에 따라
  의미가 달라져버리기 때문에 의미를 잘 파악해야함

8. 의미 오류
- 프라이머리 키에 IS NULL을 쓰는 경우 불필요한 조건이다

- 수량이 0보다 크다는 제약조건이 걸려있지만 검색조건에 0보다 작게 설정하는 경우 불필요한 조건이다 

- a > 4 or a > 2 이러한 조건의 경우  불필요한 조건을 사용중이다

- DISTINCT를 사용할 때 프라이머리키가 있거나 중복될 수 없는 값을 조회하는 경우 구문이 불필요하다

- LIKE에 %가 없는 경우 불필요한 조건임

- EXISTS SELECT절을 사용하는 경우 DISTINCT는 불필요한 조건임
  (EXISTS에 대한 공부 필요)

- ORDER BY 에 불필요한 컬럼은 빼는 것이 좋다.

- HAVING을 사용할 경우 GROUP BY한 결과에 대한 조건을 거는 것이기 떄문에
  해당 조건이 WHERE절에 들어가야할 지 HAVING에 들어가야할 지 생각해 볼 필요가 있다.
   
- UNION은 중복원소를 제거하는 집합 연산에 해당하는데 중복된 데이터가 없는 경우 쓸필요가 없다.
  ex. SELECT ..... WHERE ORDER_ID < 1025
      UNION 
      SELECT ..... WHERE ORDER_ID > 1107

- INNER 조인으로 쓸 수 있는 OUTER 조인들은 INNER JOIN을 해줘야함

9. Search Argument (SARG)
- 정의  
-- true, false, unknown의 값을 리턴하는 조건식(WHERE절, JOIN절, HAVING절)
   에서 검색 대상 및 범위를 제한할 수 있는 식을 의미함.
-- 해당 열에 인덱스 사용 및 쿼리 최적화를 위한 필요 조건

- NON- SARG
-- 검색을 제한하지 않는 식이며 인덱스 사용이나 쿼리 최적화를 방해하는 요소    
-- 인덱스를 사용할 수 없는 조건을 이렇게 부름

- SQL 쿼리 작성 시 필수로 준수해야하는 조건(INDEX를 사용하기 위해)
-- 불필요한 열 참조 
--- SELECT절에 *을 불필요하게 사용하는 경우

-- 불필요한 행 검색 
--- 50만건 이상의 데이터를 호출하는 경우 Client측에서 전부 소비하지 못하는 데이터일 수 있다.
     그 경우 심한 부하가 일어날 수 있기에 추가 검색 조건이나 적절한 TOP또는 페이징 처리가 필요

-- "INDEX열"에 부정형 사용 주의
--- 조건절은 ' = '이 가장 빠르고 효율적이다! (중요)
     ('='을 제외한 다른 부호들(<, >, <>, IN)은 인덱스 효율을 떨어뜨림)
    
--- 부정형을 쓴경우 Query Optimizer가 긍정형으로 자동으로 변환하는데
     변환할 때 부정형 결과는 항상 범위 검색으로 변환하기 때문에 
     성능이 떨어질 수 있다.  
     (특히 부정형 중에서도 NOT IN은 부하가 큼 정말 필요할 때만 사용)

--- 여러 인덱스가 존재할 때 첫번째 지정한 인덱스에서 정상적으로 사용하지 못하면
     이후 인덱스들도 정상적으로 사용할 수없다

-- 인덱스열에 (사칙)연산, 함수(SUBSTR함수 등등) 적용 주의
--- 인덱스에 연산, 함수를 적용하면 인덱스를 사용할 수 없다.

-- 인덱스열의 데이터형 변환 주의
--- 조건절에 인덱스열과 다른 데이터형이 오는 경우 인덱스를 사용할 수 없다.

-- 인덱스열에 LIKE 사용 주의
--- 인덱스열에 LIKE을 사용하면 인덱스 효율이 떨어짐
     (LIKE는 범위검색이기에 사용에 주의가 필요)

--- 인덱스열에 LIKE를 사용할 때 첫문자에 %, _ 가 들어갈 경우
     인덱스를 사용할 수 없다.

--- LIKE는 '%'를 통해 문자열로 검색하기 때문에 인덱스가 숫자형이라면
     인덱스를 사용할 수 없다.

- 조건절 상수화 이슈
-- 로컬변수, 사용자 정의 함수에 의해 인덱스를 못사용하는 경우가 생김

-- 로컬변수
--- 로컬변수의 경우 인덱스 사용 불가능하다.
--- 단, 해당열이 PK이면서 '='조건이 붙으면 한번만 검색하기 때문에
    인덱스를 사용할 수 있다.

-- 사용자 정의 함수
--- 사용자 정의 함수의 경우 인덱스 사용 불가능하다.
--- 상수나 해당 식을 직접 사용해야 함


11. 기본 SQL 권장 사항
- IN vs BETWEEN
-- IN 
--- '=' 조건과 OR연산의 결합
--- IN 조건의 검색 대상이 많을 수록 인덱스 사용기회가 감소
--- 합집합 연산이기에 불필요하게 DISTINCT, GROUP BY는 불필요
--- 비연속 값을 검색 및 검색 대상이 적은 경우 적합

-- BETWEEN
--- '<=, >=' 조건과 AND연산 결합
--- 연속 값 검색 시 적합

- TOP
-- 쿼리 최적화에 도움됨 (결과 집합 제한에 활용)

-- TOP(1)
--- MIN/MAX vs TOP(1) - NULL처리에 따라 결과가 달라짐

-- TOP(n)
--- 페이징 쿼리
--- 전체결과집합 제한하는 용도

-- TOP + ORDER BY 절 주의사항
--- TOP을 사용할 경우 ORDER BY절을 쓰는 것이 좋다.
     (ORDER BY 에서 정렬을 하지 않아도 되는 적절한 인덱스가 없거나
      인덱스를 쓰지 못하는 경우 느려짐이 발생하는 것임)
      (TOP을 쓸 때 ORDER BY절은 생략하지 않는 것이 좋다)

--- ORDER BY절의 경우 정렬 시 중복 값이 존재할 때 
     각 행을 유일하게 구별할 수 있는 식까지 지정해주어야 일관성 오류가 없음
      (PK등 추가 컬럼이 필요할 수 있다)

- 집계함수
-- COUNT(*) vs COUNT(컬럼)
--- COUNT(컬럼) : NULL이 허용된 열이면서 해당 열이 NULL값인 것을 제외한 값들의 
     행의 수를 셀 필요가 있을 때 사용

-- COUNT(*) vs EXISTS
--- 용도에 맞게 사용해야함

--- COUNT(*) : 조건에 맞는 값이 존재하는 행의 수 (전체검색)

--- EXISTS : 조건에 맞는 값이 존재하는 경우 TRUE (부분검색)
    (조건에 맞는 값이 발견되는 순간 검색을 멈춤)
  
-- NULL을 고려한 집계 연산
--- NULL이 아닌 값의 집계연산을 한다면 집계연산만으로도 NULL을 거르지만
    조건에서 IS NOT NULL을 추가하여 인덱스를 사용하여 성능을 올릴 수 있다.
   
-- 불필요한 GROUP BY 열 제거
--- 중복되지 않는 값을 두개 이상 GROUP BY 할 경우
    첫 중복되지 않는 값만 GROUP BY에 지정하고 나머지 값들은
    MAX, MIN으로 지정하면 성능이 더 좋아짐
    (중복되지 않는 값들은 어짜피 중복이 안되기 때문)
    (이 부분도 Query Optimizer가 자동으로 맞추지만 쿼리 작성 단에서 미리 지정해주는게 좋다)

-- UNION vs UNION ALL 차이 이해
--- UNION은 기본적으로 DISTINT 연산이 있어 중복을 제거하여 부하를 발생할 수 있다.
--- 행 유일성이 명확하여 중복이 없는 경우 ALL로 지정하는 것이 좋다.
     
- UPDATE 결과 열 값 반환
-- UPDATE 테이블 SET @일련번호 = 일련번호 = 일련번호 + 1 WHERE...
   (이경우 업데이트한 값을 리턴하여 SELECT를 할 필요가 없음)

  ex. DECLARE @OrderDate DATETIME;
          
          UPDATE Orders
               SET  @OrderDate = OrderDate = @OrderDate + 365
               WHERE ....
          SELECT @OrderDate

- INSERT/UPDATE/DELETE/MERGE 결과 행 반환
-- OUTPUT절을 통해 결과 행 반환 가능
 ex. UPDATE ... SET... OUTPUT 'inserted', inserted.*, 'deleted', deleted.*
    (수정되고 난 뒤 결과 inserted , 수정되기 전 결과 deleted )

- JOIN 작성 시 고려해야할 사항
-- Nested Loops(중첩 루프) JOIN 성능 이해
--- WHERE 절의 검색 조건을 확인하여 검색하는 컬럼의 테이블을
     참조한다. 그 후 그 참조된 테이블(외부입력)을 먼저 조건에 맞게 검색하여, 나온 행에서
     조인 조건에 맞는 컬럼의 값을 조인테이블(내부입력)에서 검색하여 조인 테이블의
     행을 들고온 다음 리턴하는 방식
     (만약 두 테이블 모두 같은 열을 가지고 있는 경우 검색행 수가 더 적은 쪽이 외부입력 테이블이 된다)
    
--- 중첩 루프가 좋은성능을 가지기 위해선 내부 입력 테이블에 반드시 인덱스가 사용되어야 하며
     SARG 반드시 준수해야함      

--- 쿼리에서 만약 조인 시 조인 조건에서 열 데이터형의 변형이 필요하다면
     내부 입력 테이블의 컬럼보다는 외부입력 테이블의 컬럼의 데이터형을 변환하는게
     더 나은 성능을 보여줄 수 있음
 
- 서브쿼리 이해
-- 서브쿼리는 결국은 조인이며 조인에 대한 또 다른 특별한 표현식이다.
    (조인순서, 연산방법등 차이가 있음)

-- 언제 서브쿼리를 사용할 것인가?
--- 한쪽 테이블 만 결과 집합으로 요구하며
     JOIN하는 테이블은 데이터를 체크하는 연산만 수행 하는 경우
     (SEMI JOIN)

--- 데이터 가공 후 JOIN이나 기타 연산 수행 시

-- 서브쿼리 중복 I/O 제거
--- 컬럼마다 서브쿼리가 들어가는 경우가 있는데
     같은 테이블, 같은 조건을 쓰는 경우가 있다
     그런 경우 WITH로 테이블을 빼는 방식(CTE)을 사용하거나
     서브쿼리로 파생테이블처럼 이용하여 JOIN을 하는 방식으로 사용 

-- 서브 쿼리 유의 사항
--- CASE안에 서브쿼리를 쓰는 경우 WHEN갯수만큼 테이블을 읽기 때문에
    반대로 SELECT 안에 CASE를 써주는 것이 좋다.

- NOT IN 주의 사항
-- NOT IN을 사용하고 검색조건으로 서브쿼리를 사용할 경우
   NOT NULL 처리 반드시 필수!

- SELECT 쿼리 락 대기,차단 회피
-- SELECT 시 불필요한 락 대기/차단으로 인한 성능 이슈가 발생하는 경우
-- 방법 
--- DB옵션에서 Read Committed Snapshot을 사용 (기본이자 정석)

--- 쿼리 단에서 NOLOCK 처리 (단, 주의가 필요함)
---- 세션단위 격리수준 조정 : SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED 구문

---- 테이블 락 힌트: SELECT * FROM table WITH(NOLOCK)  또는 READUNCOMMITTED
 
12. 커서 뷰 사용자 정의 함수
- 커서
-- 커서 사용 권장 사항
--- 서비스용 쿼리에서는 최대한 금지!!
     (PIVOT로 만드는 경우 GROUP BY + CASE 등을 사용)
     (행을 열로 만드는 경우 STRING_AGG() 사용)

--- 커서 사용 시 LOCAL 옵션 + FASE_FORWARD옵션을 권장

- 뷰
-- 만능 뷰는 위험
--- 대량 Table을 JOIN한 뷰, 많은 원격 테이블을 UNION한 뷰
--- 불필요한 IO 유발
--- 실행 계획 최적화 방해

-- 과다 중첩 뷰
--- 뷰안에 뷰안에 뷰안에 뷰안에 테이블
--- 중첩수준은 1단계만 권장

-- 뷰 내에서 인덱스 열 변형 주의
--- SARG위반으로 인덱스가 사용 불가능해짐

- 사용자 정의 함수
-- 성능이슈
--- Scarlar Function (행단위 반복 호출)
---- 행단위 반복 호출 자체가 대량의 결과 집합에서 호출 시 큰 부하가 발생

---- 함수 내부에서 SELECT 쿼리 포함 시 검색 행 수 비례하는 IO유발

---- 단순 연산 함수의 경우 CPU 부하 발생

---- 튜닝시 해당 함수 동작에 대한 쿼리의 실행계획 및 IO가 표기되지 않아
      마치 성능이 좋은 것 처럼 보일 수 있음

---- 해결방법
----- SELECT 쿼리의 경우 함수를 제거하고 쿼리 자체에서 병합
----- 꼭 써야한다면 함수 내부로직과 연산을 최대한 단순하게 함

--- Table-Valued Function
---- inIine Table-Valued Function 
-----매개변수를 가진 뷰 
-----뷰 대체용으로 활용 권장

---- Multi-statement Table-Valued Function
----- 가장 부하가 큼 ex. Split()
----- 대량 동시 호출 환경에서 비권장 

- FORMAT() 성능
-- 대량 SELECT 에서는 부하가 큼
-- 다른 함수나 방식으로 구현


 