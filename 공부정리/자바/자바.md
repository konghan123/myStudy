- ==대 원 칙 : 자바에서 대입은 항상 변수에 들어 있는 값을 복사한다.(참조값만 복사)==![[Pasted image 20240517171436.png]]
- 배열
	- 변수의 참조값을 보관함
	- ![[Pasted image 20240517171351.png]]
	- ![[Pasted image 20240517172328.png]]
- 기본형 vs 참조형
	- 개발자는 기본형을 정의할 수없으며 참조형만 정의 가능
	- 기본형
		- 실제 사용하는 값을 변수에 담음
	- 참조형
		- 실제 사용하는 값을 변수에 담는것이 아닌 실제 객체의 위치값을 저장
		- String은 클래스이기에 참조형이다. 문자열은 매우 자주 다루기에 자바에서 특별하게 편의 기능을 제공함
		- 위치값이 같은 이상 해당 위치의 데이터가 변경되면 불러올 때 어느 참조값이든 값은 같다.
		- 메서드를 통해 매개변수를 넘겨서 해당 참조변수의 값을 변경하면 해당 참조값은 변경된 값이 적용
- 자바 메모리 구조
	- ![[Pasted image 20240518132136.png]]![[Pasted image 20240518132454.png]]
		- 메서드 영역
			- 프로그램을 실행하는데 필요한 공통 데이터를 관리
			- 클래스정보
				- 클래스의 실행코드(바이트 코드), 필드, 메서드와 생성자 코드등 모든 실행코드가 존재
				- 
			- static 영역
				- static 변수를 보관
			- 런타임 상수 풀
		- 스택영역
			- 자바 실행 시 하나의 실행스택이 생성됨
			- 실제 프로그램이 실행되는 영역 
			- 각 쓰레드별로 스택영역이 생성됨 
			- 스택프레임
				- 메서드를 호출할 때마다 쌓임
				- 메서드가 종료되면 스택 프레임 제거됨
				- 지역변수, 중간 연산결과, 메서드 호출 정보가 포함되어 있음 
		- 힙영역
			- 객체(인스턴스)가 생성되는 영역
			- new 명령어를 사용하면 이 영역을 사용함
			- 가비지 컬렉션이 이루어지는 영역 (더이상 참조되지 않는 객체는 제거됨)
			- 각각의 A 인스턴스들은 힙영역에 존재하지만 A 인스턴스를 생성할 수 있는  A 클래스는 하나이다.즉, 변수는 인스턴스마다 값을 가지고 있어 힙영역에서 쓰이지만 메서드의 경우 공통적으로 쓰이게 됨. 그러므로 메서드 호출은 메서드 영역의 코드를 불러서 수행함. 
			  그래서 객체가 생성될 때, 메서드는 새로운 메모리 할당이 없음
			- 스택영역에서 메서드 실행 중 new 명령어를 통해 객체가 생성되면 힙영역에 해당 인스턴스가 생성되고 참조값이 생성됨. 그 참조값을 스택영역의 변수가 보관![[Pasted image 20240518135749.png]]
- static
	- static 메서드는 인스턴스 메서드, 인스턴스 변수에 접근할 수 없다.
- final
	- 기본형 변수
		- 값을 변경못함
	- 참조형 변수
		- 참조값을 변경못함
		- 하지만 참조대상의 객체 값은 변경 가능하다
		  (예시의 data는 final임)![[Pasted image 20240518150538.png]]
- 상속
	- 상속된 객체를 생성하면 부모 객체, 상속된 객체를 같이 생성시킴(참조값하나에 두개의 객체가 묶임)![[Pasted image 20240518151350.png]]
	- 만약 메서드를 호출한다면 해당 참조값을 찾아 메서드를 호출할 것이다. 하지만 해당 참조값엔 부모, 자식 객체가 존재하기에 어느 객체에서 메서드를 찾을지 선택해야함
	  선택의 기준은 호출하는 변수 타입을 기준으로 잡음
	  만약 호출하는 변수 타입이 자식 타입이고 자식 객체에 해당 메서드가 없을 경우 부모 객체로 올라가서 해당 메서드를 찾음
	  ex. ElectricCar obj 라면 obj.메서드()는 ElectricCar 객체의 메서드부터 찾고 없으면 Car객체에서 메서드를 찾음
	- super
		- 부모클래스를 참조할 수 있는 문법![[Pasted image 20240518153522.png]]
	- 상속관계는 결국 자식과 부모 객체를 둘다 만드는 것이기 때문에 각각의 생성자가 호출되어야함
	  그래서 상속관계에서 자식 클래스의 생성자에 부모 클래스 생성자가 반드시 호출되어야함
	  이때 쓰이는 구문이 super(...)
	  (단, 기본생성자(매개변수가 없는경우)는 생략가능)
	- 메서드 오버라이딩
		- 자식타입으로 생성한 인스턴스를 부모타입 변수에 담더라도 메서드 호출 시 자식 클래스에 오버라이딩이 선언된 메서드가 있다면 자식 메서드를 불러오게됨 
		  즉, 오버라이딩이 된 메서드는 항상 우선권을 가짐 (필드 값은 그렇지 않음) 
- 접근 제어자
	- private : 외부 호출 막음
	- default : 같은 패키지안에서 호출 가능
	- protected : 같은 패키지안에서 호출 가능하지만 상속관계라면 호출 허용
	- public : 모든 외부 호출 허용
- 캐스팅
	- 다운캐스팅
		- 부모타입 -> 자식 타입으로 타입변환
		  (단, 생성할때부터 자식타입으로 생성되어야함)![[Pasted image 20240518155550.png]]
- 추상 클래스
	- 상속을 목적으로 사용되고 부모클래스가 되는 것이 목적
	- 부모클래스가 생성되면 안될 때 추상 클래스를 사용
	- 추상 메서드가 하나라도 있다면 추상 클래스로 구현해야함
	- 추상 메서드
		- 상속받는 사직 클래스가 반드시 오버라이딩 해야하는 메서드
	- 순수 추상 클래스
		- 모든 메서드가 추상 메서드인 클래스
- 인터페이스
	- 순수 추상 클래스 + 편의기능 추가
	- 인터페이스의 모든 메서드는 public, abstract임
	- 그래서  public, abstract 생략 가능 (권장)
	- ==다중 구현을 지원==
	- 인터페이스의 멤버 변수는 public, static, final이 모두 포함되어 있다. (해당 키워드도 생략 가능)
- java.lang 패키지
	- 해당 클래스들이 존재![[Pasted image 20240519115930.png]]
	- 모든 자바 애플리케이션이 자동으로 import하기에 해당 패키지는 import를 생략 가능
- 동일성과 동등성
	- 동일성 : 물리적으로 같은 참조값인지 확인
	- 동등성 : 논리적으로 같은 기준인지 확인
- 불변객체
	- 객체의 상태(내부값)이 변하지 않는 객체
	- 공유 참조 이후 해당 참조값의 상태가 변경되었을 때 공유된 다른 변수들도 영향을 미치는 것을 방지
	-  객체가 생성 이후 필드값을 변경 못하게 막으면 그것이 불변객체 (단순히 제약을 거는 것)
	- 개발자가 해당 객체를 사용할 때 사이드 이펙트를 방지
- String
	- 문자열 풀
		- String str = "hello" 처럼 문자열 리터럴을 사용할때 자바는 메모리 효율성을 최적화 하기 위해 문자열 풀을 사용![[Pasted image 20240520201023.png]]
		- 자바가 실행되는 시점에서 문자열 리터럴이 있으면 문자열 풀에 String 인스턴스를 미리 만들어두고 같은 문자열이 있다면 만들지 않음 그리해당 문자열을 가진 인스턴스의 참조값을 반환String str3 = "hello" 
		  String str4 = "hello"
		  str3 == str4 가 true인 이유
		- 메서드에서 String으로 넘기는 값이 문자열 리터럴인지 String인스턴스인지 알 수 없기에 항상 equals()로 사용해서 비교해야함
	- 불변객체
		- String객체는 불변객체이다. 즉, 내부값 변경이 필요한 경우 새로운 인스턴스를 생성하여 내부값을 넣고 그 참조값을 리턴함
	- StringBuilder
		- 문자열 가변객체
		- 문자열을 자주 변경하면 그만큼 객체를 생성하기 때문에 자원을 소모하고 느려짐 
		- 문자열을 변경하는 동안만 StringBuilder를쓰고 문자열 변경이 끝나면 String 변환하는 것이 좋다.
		- 사용하기 좋은 상황
			- 반복문에서 반복하여 문자연결
			- 조건문을 통해 동적으로 문자열 조합
			- 복잡한 문자열의 특정부분을 변경
			- 매우 긴 대용량 문자열을 다룰때
		- StringBuilder vs StringBuffer
			- StringBuffer의 경우 동기화가 되어 있어 멀티 스레드에 안전하지만 그만큼 동기화 오버헤드가 존재
	- String 최적화
		- 문자열을 합칠 경우 
		  str1 + str2
		  new StringBuilder().append(str1).append(str2).toString()이런식으로 최적화함
		- 일반적인 상황에서는 + 로 문자열을 합치는게 더 좋음 (자바에서 String 합을 최적화해놓음)
		- 반복문을 통해 문자열을 합칠 경우 최적화가 불가능하기에 직접 StringBuilder을 씀!![[Pasted image 20240520203323.png]]
- 래퍼클래스
	- 기본형의 한계
		- 기본형은 객체가 아니기때문에 메서드를 제공할 수 없음 (비교 메서드 등)
		- null값을 가질 수 없음
	- 자바가 지원하는 래퍼 클래스
		- valueOf(값)를 사용하여 래퍼 객체 생성
		- 오토박싱
			- 개발하면서 박싱/언박싱하는 경우가 많아 자바에서 자동으로 해줌![[Pasted image 20240521215030.png]]
		- 기본형 vs 래퍼형
			- 기본형이 연산은 더 빠르지만 특수한 케이스(수만~수십만 연속연산)가 아니라면 상관없다. 유지보수측면에서 좋은 것을 선택
- Class 클래스
	- 타입 정보 얻기 : 클래스이름, 부모클래스 ,인터페이스, 접근 제한자
	- 리플렉션 : 클래스에 정의된 메서도, 필드, 생성자 (메서드 호출, 인스턴스 생성도 가능)
	- 동적 로딩과 생성 : Class.forName() 메서드를 사용하여 클래스를 동적으로 로드하고 newInstance()메서드를 사용하여 새로운 인스턴스 생성함
	- 애노테이션 처리
		- 클래스에 적용된 애노테이션을 조회, 처리 가능
	- 주요기능![[Pasted image 20240521220343.png]]
- ENUM(열거형)
	- 열거형이 필요한 이유(문자형의 문제점)
		- 로직을 만들면서 문자형은 오타가 발생할 수 있고 유효하지 않는 값이 입력될 수 있음
		- 다양한 형식으로 문자열을 입력해서 일관성이 떨어짐 (대소문자)
		- 컴파일 시점에서 오류감지가 불가능함
	- 열거형 패턴
		- 해당 패턴을 사용하면 나열한 항목만 사용할 수 있음!
		- 패턴예시
			- ![[Pasted image 20240522205745.png]]
		-  전후비교
			- 전![[Pasted image 20240522204637.png]]
				- String으로 매개변수를 받기 때문에 내가 아무리 static final로 상수값을 박아 넣어도 다른 개발자가 String변수로 넣어 로직 안정성이 떨어질 수 있음
			- 후![[Pasted image 20240522204541.png]]
				- 매개변수로 특정 객체를 받기 때문에 해당 객체의 사용이 강제되며 다른 개발자가 해당 메서드를 쓸때 해당 객체의 상수값을 추가하거나 상수값을 이용하여 로직 안정성이 올라감(대신 객체 생성을 막아야함)
	- Enum
		- Enum타입으로 생성![[Pasted image 20240522210111.png]]
		- 위 열거형 패턴을 줄여 자바에서 지원
		- Enum도 클래스!
		- 자동으로 Enum을 상속받음
		- 인터페이스를 구현 가능
		- 추상메서드를 선언하고 구현가능
		- Enum은 toString을 자동으로 오버라이딩해놓음
	- 주요 메서드
		- ![[Pasted image 20240522211521.png]]
		- 단, ordinal()은 사용하지 않는 것이 좋다. 
		  (상수선언하는 위치가 변경되면 전체 상수 위치가 변경되기 때문에)
	- 활용
		- 불변 객체에 생성할때 값을 넣어주고 그 값을 꺼낼 수 있는 public 메서드를 만듬(생성자가 private이라 클래스내에서 생성 가능!)![[Pasted image 20240523205310.png]]
		  Enum에서 그 할인율을 관리하기 때문에 if문으로 분기칠 필요가 없어짐!!![[Pasted image 20240523205413.png]]
- 날짜
	- 주로 LocalDateTime을 씀
	- 가져올땐 get(), 더하거나 뺄땐 plus(), minus()
	- 차이를 구할땐 between()
	- 날짜 값을 변경할땐 with()
		- with(TemporalAdjusters.메서드)를 활용하여 해당 날짜의 달 마지막 일요일, 다음주 금요일 같은 복잡한 값을 구할 수 있음
- 중첩 클래스
	- 사용하는 이유
		- 두 클래스가 긴밀하게 연결될 경우 사용됨
		- 논리적 그룹화
		- 캡슐화
	- 중첩클래스는 그 용도가 자신이 소속된 품는 클래스 안에서 사용되는 것이다. 즉, 외부에서 중첩클래스를 생성하고 있다면 그것은 중첩 클래스의 용도에 맞지 않다.
	- 클래스 종류
		- 정적 중첩 클래스
			- static이 붙는다
			- 위치만 안에 있고 품는 클래스와 전혀 다른 클래스
			- 품는 클래스의 static멤버는 접근가능(private 접근자도 가능)
				- 메서드영역의 static멤버에만 접근하는 것!
			- 인스턴스 멤버는 접근 불가능
		- 내부클래스
			- 위치도 안에 있으며 품은 클래스를 구성하는 하나의 요소
			- 품는 클래스의 인스턴스 멤버 소속이 됨
			- 
			- 내부클래스종류
				- 내부클래스
					- 필드에 정의하는 클래스
					- **품는 클래스의 인스턴스 멤버에 접근 가능(중요)**
					- 품는 클래스의 인스턴스를 참조하여 내부클래스의 인스턴스가 생성됨![[Pasted image 20240526132147.png]]
					- ![[Pasted image 20240526132043.png]]
				- 지역클래스
					- 지역변수와 같이 코드블럭 안에서 클래스 정의
					- 내부 클래스의 특징 + 지역변수에 접근 가능
					- 지역클래스의 지역변수 캡쳐
						- 지역 클래스의 인스턴스 생성 시점에 접근이 필요한 지역 변수를 복사해서 생성된 인스턴스와 함께 넣어두는 것
						- 지역 인스턴스를 반환할때 지역 변수의 특성으로 스택영역에서 사라져 값을 호출 할 술 없는 부분을 막기위해 등장
						- ![[Pasted image 20240526135847.png]]
						-  그래서 캡쳐한 변수들은 인스턴스에서 접근가능하기에 인스턴스 생명주기와 같다.
						- 지역 클래스가 접근하는 지역 변수는 사실상 final이다.
						  왜??
						  지역 인스턴스 생성 시점에 지역변수 값을 캡쳐하므로 이후 변경된 값에 대해서 동기화를 시켜주어야하는 문제점이 발생되며 예상치 못하는 곳에서 값이 변경될 수 있어 디버깅을 어렵게하고 멀티쓰레드 상황에선 동기화가 성능에 영향을 미침.
				- 익명클래스
					- 이름이 없는 지역클래스의 특별한 버전
					- 지역클래스 + 클래스이름이 없음
					- 지역클래스를 선언과 생성을 한번에 함
					- 익명클래스 선언 및 생성![[Pasted image 20240526141720.png]]인터페이스 Printer를 생성한것이 아니라 인터페이스를 구현한 익명의 클래스를 생성한것!즉, 상속(구현)하면서 바로 클래스생성!
					- 특징
						- 사용시 부모클래스를 상속, 인터페이스를 구현해야함
						- 이름을 가지지 않으므로 생성자가 없음(기본 생성자만 사용됨)
						- 일회성으로 사용되기에 단한번만 인스턴스가 생성됨
					- 활용
						- 코드조각 넘기기
							- 구현한 인스턴스를 전달하여 그 메서드를 호출하는 방식
					- 
- 변수 생명 주기
	- 클래스 변수 : 프로그램 종료시
	- 인스턴스 변수 : CG가 될 시
	- 지역변수 : 스택영역에서 메서드 호출이 끝날 시
- 람다
	- 자바 8 이전에는 메서드 인수로 넘길 수 있는 것은 기본형 타입, 인스턴스참조였다. 코드조각을 넘기기 위해선 인스턴스를 생성하고 그 메서드를 넘겨서 전달해야하였다.
	- 람다를 통해 메서드를 인수로 전달할 수 있게 됨.
	  즉, 코드조각으로 넘길 수 있음
	- 람다 이전![[Pasted image 20240526144516.png]]
	- 람다 이후![[Pasted image 20240526144954.png]]
- 예외
	- 계층![[Pasted image 20240526145820.png]]
		- Exception 
			- 체크 예외
			- 컴파일러가 체크하는 예외 (RuntimeException을 제외)
		- RuntimeException 
			- 컴파일러가 체크하지 않는 예외(언체크 예외)
	- throw, throws
		- throw : 예외를 발생시킬때 쓰는 문법
			- throw new myException()
		- throws : 예외를 던질때 쓰는 문법
			- public void method throws myException {}
	- 체크 예외
		- 컴파일러가 체크하는 예외
		- 체크예외는 **반드시** 밖으로 던지거나 잡아서 처리하여야함 (명시적으로 처리해야함)
		  즉, try-catch로 잡거나 throws로 넘겨야함
	- 언체크 예외
		- 컴파일러가 체크하지 않는 예외
		- throws를 생략할 수 있음
	- 차이점
		- throws를 필수로 선언해야하는가의 차이
	- 예외처리
		- try-catch-finally 문법으로 처리
		- catch문은 여러개  나열 가능하며 우선순위는 순서대로 체크함 (즉, 맨밑에 부모 익셉션 객체를 두어 알수 없는 예외는 해당 부모 익셉션으로 잡는다 (ex. Exception e))
		- | 를 통해 여러개의 예외를 한번에 잡을 수 있다.![[Pasted image 20240527205658.png]]
	- 예외처리 실무
		- 체크예외는 부담이 됨
			- 여러 라이브러리를 적용하여 프로젝트를 만들기 때문에 라이브러리마다 체크예외로 처리한다면 체크예외지옥에 빠지게됨![[Pasted image 20240527205859.png]]
			-  throws Exception으로 던지는 것은 최악의 수이다.
				-  모든 예외의 부모객체이기 때문에 중요하게 체크가 필요한 예외가 있을 경우 그 예외는 무효화됨 (Exception으로 잡아 정상이라고 판단)
			- 예외처리하여 복구 가능한 예외가 적다. 그래서 밖으로 던져 사용자에게 에러메세지를 보여주는 것이 합리적
			- 언체크 예외를 사용하여 throws를 줄이고 잡을 수 있는 언체크 예외는 공통 예외 잡는 로직을 만들어 거기서 예외처리함![[Pasted image 20240527210902.png]]
	- try with resources
		- 자바 7부터 생긴 문법으로 외부자원을 반납하다는 패턴이 반복되면서 등장한 문법
		- 장점
			- 리소스 누수 방지
			- 코드 간결
			- 리소스가 try안으로 한정되기에 스코프 범위를 줄여 유지보수성 증가
			- try구문에서 끝나면 바로 반납하기에 기존보다 조금 더 빠름 (원래는 catch이후에 반납)
		- 사용을 위해 자원에 아래 인터페이스를 구현해야함![[Pasted image 20240527211410.png]]
		- 구문 사용법![[Pasted image 20240527211421.png]]
		- 예시
			- 인터페이스 구현![[Pasted image 20240527211458.png]]
			- 사용![[Pasted image 20240527211453.png]]
- 제네릭
	- 클래스 내부 타입을 클래스를 정의하는 시점이 아닌 생성하는 시점에 결정하는 문법
	- 필요한 이유
		- 여러타입이 들어올 수 있어야 할 때 타입안전성을 위해 사용 (코드 재사용성 및 타입 결정을 생성 시점에 진행)
			- 타입 안전성 : 어떠한 타입이 들어왔을 때 보장이 됨
		- 모든 부모타입 Object를 사용한다면 코드상으로 어떠한 값에 대해 다운 캐스팅을 진행해주어야한다. 하지만 Integer타입으로 캐스팅이 되어야할 값이 문자열이 들어온다면 타입이 맞지 않아 예외가 발생하여 타입 안전성이 없음 (==Object 타입은 컴파일 오류가 생기지 않아 런타임에 오류에 대해 알 수 있음 ==)
	- 제네릭 적용![[Pasted image 20240908125457.png]]
		- T를 타입 매개변수
	- 제네릭 타입 객체 정의![[Pasted image 20240908125615.png]]
		- 생성 시점에 타입이 결정됨
		- 타입 추론으로 new 객체<'타입'> 에서 타입을 생략할 수 있음 (선언한 타입으로 추론함)
	- 원리
		- 메서드의 매개변수와 원리가 비슷함
		- 단지, 클래스에서 타입 매개변수를 넘길 뿐
	- 제네릭 타입 제한
		- < T extents 제한시킬 타입>
		- 어떠한 클래스의 메서드, 필드를 사용하기 위해 해당 타입의 객체만 받기를 원할 때 사용됨
		- 타입을 제한하지 않는다면 디폴트 값은 Object타입이다.  (즉, 원하는 타입의 메서드를 사용할 수 없음)
		- 예시![[Pasted image 20240908135839.png]]
	-  제네릭 메서드
		- 메서드를 호출하는 시점에 타입을 결정함
		- 제네릭 타입은 static 메서드에 타입 매개변수로 사용할 수가 없다.
			-  static 메서드는 인스턴스단위가 아닌 클래스 단위이기에 제네릭 적용과 무관해져서 적용할수 없다.
			- 그래서 제네릭 메서드를 사용하여 static 메서드에 타입 매개변수를 지정할 수 있음
		- 선언![[Pasted image 20240908142235.png]]
		- 정의![[Pasted image 20240908142614.png]]
			- 메서드 앞에 <타입>을 넣어줌
			- 타입 추론을 통해 반환타입이 존재한다면 메서드 앞에 <타입>을 생략해도 됨
	- 제네릭 타입과 제네릭 메서드 우선순위
		- 제네릭 메서드가 우선순위를 가짐
	- 와일드 카드
		- 이미 만들어진 제네릭 타입을 활용할 때 쓰임
		- 와일드카드는 제네릭 타입이나 제네릭 메서드를 정의할 때 사용하는 것이 아님
		- 제네릭 메서드와 차이점
			- 제네릭 타입이나 제네릭 메서드를 정의하는 게 필요한 상황이 아니라면 단순하게 와일드 카드를 이용하여 타입들을 제네릭하게 사용함![[Pasted image 20240909211239.png]]
			- 유동적으로 적절한 타입의 리턴값을 반환받고 싶은 경우 제네릭 타입, 메서드를 정의하여 사용해야한다![[Pasted image 20240909211813.png]]
		- 종류
			- 비제한 와일드 카드
				- ?
				- 모든 타입을 다 받을 수 있음
				- ? == \<? extents Object>  와 같다
				- 쓸 수 있는 메서드가 Object 메서드임
			- 상한 와일드 카드
				- \\\<? extents 클래스>
				- 해당 클래스 포함 하위 타입 전달 가능
			- 하한 와일드 카드
				- \\\<? super 클래스>
				- 해당 클래스 포함 상위 타입 전달 가능
	- 타입 이레이저
		- 제네릭은 자바 컴파일 단계에서만 사용되고 이후 제네릭 정보가 삭제된다.
		- 즉, 제네릭에 사용한 모든 타입 매개변수가 사라짐
		- 그래서 .java파일에는 타입 매개변수가 존재하지만 컴파일 이후인 바이트 코드의 .class 파일에는 타입 매개변수가 존재하지 않음
			- 런타임에 모두 Object형이 되기때문에 instanceof메서드는 항상 Object형과 비교하게 되고 무조건 참이 되기 때문에 타입 매개변수에 instanceof를 허용하지 않으며 new도 무조건 new Object가 되어버리기 때문에 타입 매개변수에 허용하지 않음
			- 컴파일 시점 코드![[Pasted image 20240909213950.png]]
			- 런타임 시점 코드![[Pasted image 20240909214013.png]]
		- 상한 제한없이 선언한 타입 매개변수는 모두 Object형으로 변경됨
		- 컴파일러가 직접 캐스팅을 추가함
- 배열
	- 특징
		- 인덱스로 데이터를 찾는 속도는 빠르다 O(1)
			- 인덱스를 통해 배열의 기존 주소값 + 인덱스 수 만큼 더하여 한번에 찾아냄
		- 값으로 데이터를 찾는 속도는 느림 O(n)
- 빅오 표기법
	- 알고리즘 성능을 분석할 때 사용하는 수학적 표현 방식![[Pasted image 20240910204836.png]]
	- O(1)
		- 상수시간
		- 데이터의 크기에 관계없이 알고리즘의 실행 시간이 일정
		- ex. 배열에서 인덱스를 사용한 경우
	- O(n)
		- 선형시간
		- 알고리즘 실행 시간이 데이터의 크기에 비례하여 증가
		- ex. 배열의 검색 (배열의 모든 요소를 순회)
	- O(n^2)
		- 제곱시간
		- 알고리즘 실행 시간이 데이터의 크기의 제곱에 비례하여 증가
		- ex. 이중 루프를 사용하는 알고리즘
	- O(log n)
		- 로그시간
		- 알고리즘 실행 시간이 데이터의 크기의 로그에 비례하여 증가
		- 이진 탐색 (트리구조)
	- O(n log n)
		- 선형 로그 시간
		- ex. 효율적인 정렬 알고리즘
	- 
- 링크드리스트
	- 기존 배열리스트의 단점
		- 배열 리스트의 경우 크기를 미리 확보해야하기 때문에 낭비가 됨.
		- 중간에 데이터가 추가되는 경우 성능이 좋지 않음
- 자바 리스트
	- 자바의 ArrayList의 경우 중간에 값을 추가할 시 메모리 고속 복사 연산을 사용하여 성능이 매우 빠름(System.arraycopy()를 사용함)![[Pasted image 20240920180253.png]]
	- 자바가 지원하는 LinkedList는 이중연결리스트이다.
	- 데이터를 앞쪽에서 자주 추가 삭제할 일이 있다면 연결리스트를 고려하고 나머지는 배열리스트를 고려하는 것이 좋다.
- Set
	- 특징
		- 유일성
			- 중복된 요소가 존재하지 않음
		- 빠른검색
			- 요소 유무를 빠르게 확인할 수 있음
		- 순서 미보장
			- 인덱스가 없음
- 해시 알고리즘
	- 해시 알고리즘을 사용하면 검색 성능을 평균 O(1)로 비약적으로 성능을 올릴 수 있다.
	- 데이터에 해시 알고리즘을 적용하여 해시 인덱스를 만들어 사용하여 O(1)의 성능 
		- 해시 인덱스 : 배열의 인덱스로 사용하기 위해 원래 값을 계산한 인덱스
	- 해시 함수
		- 임의의 길이의 데이터를 입력받아 고정된 길이(타입)의 해시값(해시코드)를 반환하는 함수
		- 어떠한 데이터는 해당 함수를 통해 해시코드가 만들어지고 그 코드로 해시 인덱스를 만듬
	- 해시충돌
		- 해시 알고리즘을 적용하면 다른 값이라도 겹치는 경우가 발생 이때 충돌이 발생한다.
		- 각 인덱스마다 배열을 두어 해시값으로 들어오는 경우를 모두 담음 (단, 이때 들어오는 값에 대해 일일이 비교해야하므로 O(n)이 됨) ![[Pasted image 20240921121957.png]]
- 자바의 해시코드
	- Object.hashCode()
		- 원시타입뿐만이 아니라 사용자 정의 타입까지 해시코드로 표현할 수 있다.
	- 보통 오버라이딩하여 사용
	- ==해시 자료구조를 사용할 땐 반드시 equals(), hashCode()를 재정의해야한다==
		- 어떠한 데이터를 꺼내고 싶을 때 해시 인덱스를 통해 접근했지만 해당 인덱스에 존재하는 값이 여러개일 수 있기에 정확히 어떤 값을 꺼내야할 지 알 수 없음. 그래서 equals로 비교가 필요
		- 만약 해당 인덱스에 1개 데이터만 존재하더라도 그 값과 꺼내고 싶은 값이 같은 것인지 확정지을 수 없기 때문에 equals로 비교할 필요가 있다.
		- hashcode()를 구현하지 않은 경우
			- 같은 값이라도 다른 해시인덱스로 들어가게됨
		-   equals()를 구현하지 않은 경우
			- 같은 인덱스 중에서 어떤 값을 꺼내야할지 알 수 없음
			- 같은 값이 같은 인덱스에 저장됨
- 자바 set
	- 배열의 크기가 75% 넘어가면 해시 인덱스가 자주 충돌하기 때문에 배열 크기를 2배로 늘림
	- 구현체
		- HashSet
			- 기본적인 Set이며 데이터 순서를 보장하진 않음
		- LinkedHashSet
			- 연결리스트로 이루어져 데이터 순서를 보장함
				- 각 노드로 연결되기 때문에 요소들이 추가된 순서를 유지할 수 있음
		- TreeSet
			- 트리구조를 사용
				- 이진탐색트리 사용![[Pasted image 20240922115233.png]]
					- O(logn) 성능을 가짐
					- 중위 순회
						- 트리에서 데이터를 차례대로 순회하기 위해 사용함
						- 왼쪽 서브트리를 방문 후 현재노드를 처리하고 마지막으로 오른쪽 서브트리를 방문
						- 예시![[Pasted image 20240922120646.png]]![[Pasted image 20240922120653.png]]
				- 이진 탐색 트리를 개선한 레드-블랙 트리를 사용
					- 트리 균형을 동적으로 맞추는 트리
						- 이진 트리가 한쪽으로 치우치게 되면 최악의 성능이 나옴(O(n))![[Pasted image 20240922120105.png]]
			- 정렬된 순서를 유지함
				- Comparator를 통해 순서기준을 변경할 수 있음
- 자바 Map
	- 특징
		- Key - Value를 양식으로 저장하는 자료 구조
		- 키는 Map 내에서 유일해야함
			- 같은 키로 데이터 저장 시 덮어씌워짐
		- 키를 통해 빠르게 검색 (O(1))
		- 값은 중복될 수 있음
		- 순서를 유지하지 않음
		- Entry
			- Map의 키와 값을 하나로 묶을 수 있는 객체
			- entrySet을 사용하여 구현
	- 구현체
		- Set 구현체와 거의 같음
			- 사실 상 Map과 Set은 Value의 유무 차이 뿐이다.
			- Map에 Value만 비워두면 Set으로 사용할 수 있다.(실제로 HashSet은 HashMap으로 이루어져 있다.)
		- HashMap
			- Key를 사용하여 해시코드를 생성
			- Key뿐만이 아니라 Value값도 추가로 저장되어야하기 때문에 Entry 객체를 사용하여 하나로 묶어서 저장함
			- 단, Key로 사용되는 객체는 반드시 equals, hascode를 재정의 해야함
			- 구조![[Pasted image 20240922125226.png]]
		- LinkedHashMap
		- TreeMap
			- Key값을 기준으로 정렬
- 자바 Stack
	- 후입선출
	- 안 쓰는 것이 좋음
		- Vector 자료구조를 쓰기 때문에 느림
		- Deque를 사용하는 것이 좋다
- 자바 Queue
	- 선입선출
- 자바 Deque
	- Double Ended Queue의 약자
	- 양쪽 끝에서 요소를 추가하거나 제거 가능하여 유연함
	- Deque를 Stack과 Queue처럼 사용하는 메서드까지 제공함
	- 구조![[Pasted image 20240922131251.png]]
	- 구현체
		- 둘의 차이는 ArrayList와 LinkedList와 비슷함
		- ArrayDeque
			- 구현체 중  모든면에서 제일 빠름
		- LinkedList
			- Deque와 List를 구현받음
- 순회
	- 자료구조에 들어있는 데이터를 차례대로 접근해서 처리하는 것
	- 자료구조마다 순회하는 방법이 다름
		- 배열 > 인덱스를 늘려 순회
		- 연결리스트 > node의 다음 위치값을 순회
	- Iterable, Iterator
		- 자료구조와 관계없이 모든 자료구조를 동일한 방법으로 순회할 수 있는 방법
		- 자료구조에 Iterable, Iterator의 메서드를 구현하고 재정의 하여 해당 이름의 메서드를 통해 순회할 수 있다. 
		- 주요 메서드![[Pasted image 20240923212907.png]]
			- Iterator
				- hasnext(), next() 메서드를 통해 순회에 대한 구현을 할 수 있음 
			- Iterable
				- Iterator() 메서드를 통해 순회할 iterator를 구현한 클래스를 해당 자료구조에 적용시킬 수 있음
		- 향상된 for문
			- Iterator를 이용하여 보다 간단하게 순회가능한 문법이다.
			- 배열이거나 Iterable 인터페이스가 구현한 객체여야한다.
			- Iterator의 hasNext(), next()를 사용할 필요없이 간단하게 순회가능하다.![[Pasted image 20240923215421.png]]
- 정렬
	- 자바 초기에는 퀵소트 사용 이후 데이터가 작을 땐(32개 이하) 듀얼 피벗 퀵소트를 사용하고 데이터가 많을땐 팀소트를 사용
	- 순서가 있는 자료구조에 사용할 수 있다.
	- Comparator
		- 비교자
		- 비교할때 비교기준을 제공함
		- 구조![[![[Pasted image 20240924203539.png]]Pasted image 20240924203539.png]]
	- Comparable
		- 같은 객체끼리의 비교 기능을 추가해준다
		- 구조![[Pasted image 20240924204559.png]]
		- Comparable로 구현한 필드의 비교가 아닌 다른 필드값으로 정렬하고 싶을 땐 Comparator을 통해 새로운 비교기준을 만들어서 Arrays.sort(배열, Comparator)를 통해 적용
		- Comparator 비교가 더 우선순위를 가짐
	- 정렬 메서드
		- 배열
			- Arrays.sort(배열, 비교자)를 통해 배열을 정렬
		- 리스트
			- Collections.sort(리스트, 비교자)
				- 리스트를 넣어  정렬
			- list.sort(비교자)
				- 정렬
				- 매개변수에 null을 넣은 경우 리스트 객체 스스로가 가지고 있는 정렬 메서드를 사용하여 정렬
		- 트리
			- 이진 탐색 트리의 경우 데이터를 보관할 때 데이터를 비교하여 정렬 후 저장하기 때문에 ==비교자가 반드시 필수이다.==
	- 
- 컬렉션 유틸
	- Collections 정렬 관련 메서드
		- Collections.max(컬렉션)
			- 정렬기준 큰값
		- Collections.mim(컬렉션)
			- 정렬 기준 작은값
		- Collections.shuffle(컬렉션)
			- 랜덤하게 섞음
		- Collections.sort(컬렉션)
			- 정렬 기준으로 컬렉션 정렬
		- Collections.reverse(컬렉션)
			- 정렬 기준으로 반대로 컬렉션 정렬
	- 편리한 불변 컬렉션 생성 메서드
		- 불변 컬렉션이기에 추가, 제거가 불가능함
		- List.of() : 불변 리스트 생성
		- Map.of() : 불변 맵 생성
		- Set.of() : 불변 셋 생성
		- 불변 컬렉션을 가변으로 변경
			- 구현된 클래스를 생성하면서 생성자에 해당 불변 컬렉션을 넣어준다
			- 예시![[Pasted image 20240925211539.png]]
	- 멀티스레드 동기화
		- Collections.synchronizedXXX(컬랙션)
			- list, set, map을 동기화 시킬 수 있는 메서드
