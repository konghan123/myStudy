1. JDBC
- 과거에 DB마다 연결하는 방법이 달랐고
  포맷이 달랐다. 그래서 DB마다 연결, Sql전달, 결과 받는 방법을 각각 배워야했다.
  그래서 자바에서는 모든 데이터 베이스에 접속할 수 있게
  표준 인터페이스를 만들게 되는데 그것이 JDBC이다.   
  그래서 각각 DB들은 JDBC인터페이스에 맞게 구현해서 라이브러리로
  제공하는 것이 JDBC드라이버라고 한다
- 연결(connection), sql전달(statement), 결과 응답값(ResultSet)

- 하지만 sql의 경우 각각의 데이터베이스에 맞는 쿼리를 적용해야한다는
   한계점이 존재

** 데이터베이스 커넥션 연결은 주로 TCP/IP로 연결

- JDBC를 직접 사용해도 되지만 사용방법이 복잡하다
  그래서 JDBC를 편리하게 사용하기 위해 sqlMapper와 ORM기술이 등장

- sqlMapper
-- 장점
--- JDBC를 편리하게 사용하도록 도와줌
--- 응답결과를 객체로 편리하게 변환
--- sql만 알면 금방 배워서 사용가능
-- 단점
--- sql을 직접 작성

- ORM
-- 객체를 관계형 데이터베이스테이블과 매핑해주는 기술

-- 개발자 대신 sql을 동적으로 만들어 실행해줌

--장점
--- sql을 작성하지 않아도됨
--- 데이터베이스마다 다른 sql을 사용하는 문제를 해결
-- 단점
--- 깊이있는 학습이 필요

- JDBC 사용하기

-- DB연결하기

-- DriverManager.getConnection(URL, USERNAME, PASSWORD)
    해당 구문으로 드라이버연결하여 DB연결

-- 받은 DB드라이버 라이브러리에 따라 해당 드라이버의 
    Connection 인터페이스 구현체를 제공하여 연결시킴  

-- 만약 드라이버가 여러개의 경우
    URL정보에서 "jdbc:데이터베이스" 를 통해 해당 DB드라이버에 
    연결하여 커넥션을 반환함
    처리할 수 없으면 다음 드라이버 순서를 넘김

-- DB에 INSERT하기
--- String으로 sql문 짜고 Connection객체를 들고와서
    그 객체로 prepareStatement() 객체를 들고옴
    그리고 sql문의 ? 부분에  prepareStatement객체.set타입(?순서, 값)
    을 통해 sql값 세팅 그 후 executeUpdate()로 DB에 sql을 넘겨서 값을 받음

--- 이후 prepareStatement, Connection순으로 객체를 닫아줘야함!
    (반드시 finally에서 호출)

-- DB에서 SELECT하기

--- String으로 sql문 짜고 Connection객체를 들고와서
    그 객체로 prepareStatement() 객체를 들고옴
    그리고 sql문의 ? 부분에  prepareStatement객체.set타입(?순서, 값)
    을 통해 sql값 세팅 그 후 ResultSet을  prepareStatement를 통해 불러와서
    rs.next()로 한번 넘어가 쿼리에 대한 값을 불러오고
    그 값들을 DTO에 담는다!

--- ResultSet
---- select 쿼리 결과가 들어가 있음
---- ResultSet 안에는 커서가 존재하여 rs.next()하면
      커서가 다음으로 이동한다
      (최초의 커서는 데이터를 가르키지 않기에 rs.next()를 한번 해줌)


2. 커넥션 풀

- 디비 커넥션 획득 과정
-- 애플리케이션 로직은 DB 드라이버를 통해 커넥션을 조회한다. 
-- DB 드라이버는 DB와 TCP/IP 커넥션을 연결한다. 물론 이 과정에서 3 way handshake 같은 TCP/IP 연결을 위한 네트워크 동작이 발생한다. 
-- DB 드라이버는 TCP/IP 커넥션이 연결되면 ID, PW와 기타 부가정보를 DB에 전달한다. 
-- DB는 ID, PW를 통해 내부 인증을 완료하고, 내부에 DB 세션을 생성한다. 
-- DB는 커넥션 생성이 완료되었다는 응답을 보낸다. 6. DB 드라이버는 커넥션 객체를 생성해서 클라이언트에 반환한다.

- 획득 과정의 문제점
-- 매번 커넥션을 생성해야하므로 매번 리소스 소모
-- 커넥션 만드는 시간이 필요하므로 응답 시간 증가

- 커넥션풀
-- 커넥션을 미리 생성해두고 그 커넥션을 관리하는 방식
-- DB드라이버를 통해 새로운 커넥션을 얻는 것이 아닌 커넥션 풀에서 
    커넥션 객체를 반환받음

- DataSource
-- 커넥션을 획득하는 방법을 추상화한 인터페이스이다.
-- 커넥션풀, 드라이버에 직접의존하지 않고 해당 인터페이스에 의존하여
    커넥션 풀 구현 기술을 변경하고 싶다면 해당 구현체를 갈아끼우면됨
-- 스프링에서는 해당 DataSource를 지원해줌
    (DriverManagerDataSource)
    처음 객체를 생성할때만 파라미터를 넘기고 커넥션을 획을할땐
    메서드만 호출하면됨 (설정과 사용을 분리함)


3. 트랜잭션

- 데이터베이스를 쓰는 이유는 트랜잭션을 지원하기 때문

- 트랜잭션이란? 하나의 거래를 안전하게 처리하다록 보장해주는 것

- 커밋 -> 모든 작업을 성공해서 데이터베이스에 정상 반영한 것

- 롤백 -> 작업 중 하나라도 실패해서 거래 이전으로 되돌리는 것

- 트랜잭션 ACID
-- 원자성 : 트랜잭션 내에서 실행한 작업은 마치 하나의 작업인것처럼 모두 성공 또는 모두 실패해야함
-- 일관성 : 모든 트랜잭션은 일관성이 있는 데이터베이스 상탤르 유지해야함 
               (무결성 제약 조건을 항상 만족해야함)
-- 격리성 : 동시에 실행되는 트랜잭션은 서로에게 영향을 미치지 않도록 격리
               (멀티쓰레드때문에 격리성을 완벽히 보장하려면 트랜잭션을 순서대로 실행해야하는데
                문제는 그러면 성능이 매우 나빠짐 그래서 트랜잭션의 격리 수준은 4단계로 나뉨)
--- 트랜잭션 격리 수준 (아래로 갈수록 성능이 느려짐)
---- READ UNCOMMITED - 커밋되지 않은 읽기
---- READ COMMITED - 커밋된 읽기 (보통은 이 단계를 많이씀)
---- REPEATABLE READ - 반복 가능한 읽기 (두번째로 많이 씀)
---- SERIALIZABLE - 직렬화 가능

-- 지속성 : 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야함
               중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을
               복구할 수 있어야함


- 데이터베이스 연결 구조
-- 커넥션이 연결되면 DB세션을 생성해서 트랜잭션을 시작해서 커밋까지 이어짐
-- 커넥션이 만들어진 만큼 세션이 만들어짐

- 트랜잭션 사용법
-- 쿼리를 실행하고 그결과를 반영하려면 Commit을 호출하고 
    반영하고 싶지않으면 rollback명령어를 호출
    (커밋을 호출하기 전까지 임시로 데이터를 저장함)
    (보통 자동 커밋 모드로 설정되어 있음)

-- 임시로 저장된 데이터는 해당 세션만 볼 수 있으며 다른 세션은 확인 불가능하다
    (격리수준 1단계로 지정하면 임시 저장된 데이터도 볼 수 있다)

-- 자동 커밋 
--- 쿼리 실행 직후에 자동으로 커밋을 호출함
--- 커밋, 롤백을 직접 실행하지 않아도 되서 편함
--- 자동으로 커밋이 되기에 트랜잭션 기능을 제대로 실행할 수 없음
--- 설정방법 : SET autocommit true;
                   
-- 수동 커밋 
---  commit; 명령어를 실행해야 변경된 내용이 적용됨
--- 변경을 원치 않으면 rollback;을 통해 되돌림
--- commit, rollback을 안하면 timeout으로 변경 전 내용으로 되돌아감
     (timeout 시간은 설정 가능하다)
--- 설정방법 : SET autocommit false;










