- 코드 컨벤션
	- 이름
		- 변수이름 : cameCase (명사)
		- 함수이름 : cameCase (동사)
		- 클래스이름 : CameCase
		- 패키지이름 : camecase
		- 상수이름 : CAME_CASE
	-  줄여쓰기
		- 가능한 풀어서 쓰는 것이 좋음
		- 허용하는 몇몇개의 단어는 줄여써도 됨
		- 줄여서 쓸 경우 대문자로 쓰지않는다
			- ex. userID (x) userId
	- 클래스이름
		- 무언가 생성하기 위한 클래스 -> ~Factory
		- 생성 외 변환을 위한 클래스 -> ~Util
		- 클래스 이름의 단어조합은 3개 이하로
	- 함수이름 
		- get vs find
			- get  
				- return 값이 인스턴스
				- 가지고 있는 값을 그대로 돌려줌
			- find
				- return 값이 Optional
	- 롬복의 getter, setter
		- getter, setter를 남발하는 것은 캡슐화가 깨질 수 있음.
		- 객체를 능동적이게 하라 (TDA 원칙)
			- 객체 메서드를 추가하여 일을 시켜라 
	- 주석
		- 주석은 정말 필요할 때만 쓰는 것
		- 주석이 달고 싶다는 느낌이 든다면 그건 메서드를 분리하라는 의미
		- ![[Pasted image 20240629140951.png]]![[Pasted image 20240629141000.png]]
	- Optional
		- 자주사용하는 것을 추천(의미가 부합하는 선에서)
		- nullPointException을 줄여줌
	- 범위를 포함하는 매개변수
		- 출발은 포함, 끝은 미포함![[Pasted image 20240629141314.png]]
		- 
- 객체지향코드 짜기
	- 객체 종류
		- 객체 종류보다 중요한점
			- 어떠한 값을 불변으로 만들 것인가?
			- 어떠한 메서드를 public으로 만들 것인가?
		- VO객체(Value Object)
			- 값 객체 = 변할 수 없는 객체
			- 모든 변수를 final로 선언
			- VO는 불변해야하며 동일하게 생성된 두 VO는 영원히 동일한 상태를 유지되어야한다는 것
			- 즉, ==VO는 항상 유효==하기에 버그를 줄이는데 유용
			- 어떠한 메서드에 객체를 매개변수로 넣었을 때 그 객체의 멤버변수가 변경되는 일을 막아줌
			- VO를 생성할 때 항상 값이 유효한지 검증이 필요함
			- VO에도 변경자(메서드)가 들어갈 수 있음
				- 변경자 이름은 전치사로 지정하는 것이 좋음
				-  변경자 리턴값은 VO객체로 리턴해야함
			- ![[Pasted image 20240629142205.png]]
		- DTO객체
			- 데이터 전송 객체
			- 메서드간, 클래스간, 프로세스간에 데이터를 주고받을 때 쓰는 객체
			- DTO는 상태를 보호하지 않으며 모든 속성을 노출함 (즉, 모든 멤버 변수가 public이여도 상관x)
		- 엔티티(Entity)
			- 유일한 식별자 존재
			- 수명 주기 존재
			-  어떠한 저장소에 저장하기 위해 존재 (DB 저장만을 위한 것은 아님)
			- ![[Pasted image 20240629143039.png]]
			- 도메인 엔티티 vs DB 엔티티
				- 호불호의 영역
					- 두 개념을 같은 개념으로 보는 사람들도 많음
				- 도메인 엔티티
					- 비즈니스 영역을 해결하는 모델
				- PO
					- DB의 레코드에 연결되는 객체
				- DB 엔티티
					- RDB에 저장되는 객체 (NoSQL에서는 해당되지 않음. 오직 RDB만!!!)
				- ![[Pasted image 20240703212612.png]]
		- PO(Persistence Object)
			-  = DB Entity (의미는 살짝 다르지만 거의 같은 결)
			- 데이터베이스에 저장하기 위한 Entity
			- JPA의 Entity는 PO에 해당됨
	- 디미터 법칙
		- 최소 지식의 법칙
		- 모듈은 자신이 조작하는 객체의 속사정을 몰라야함
		- 위반사례![[Pasted image 20240629143949.png]]
		- 우수사례(디미터 + TDA)
		  디스크 용량이 얼마인지 물어봐서 출력하지 말고 객체가 디스크 용량을 출력시키는 일을 하게함![[Pasted image 20240629144017.png]]
	- 객체 만들기
		- 행동 위주의 사고로 클래스를 만드는 것이 객체지향적일 확률이 높다.
		- 행동이 객체를 정의하는데 중요한 요소이다.
		- 왼쪽은 structure, 오른쪽은 class![[Pasted image 20240629144329.png]]
	- 순환참조
		- 가급적 만들지마라
		- 지나치게 결합도가 높아짐
		- Serialize가 불가능함
		- 순환참조 예시![[Pasted image 20240629144843.png]]
		- 해결법
			- 간접참조 (id 값으로만 찾아옴)![[Pasted image 20240629144924.png]]
			- 이러한 기능을 별도의 클래스로 분할할 수 없는지 검토![[Pasted image 20240629144955.png]]
		- 
- 객체지향 설계
	- SOLID
		- Single response
			- 단일 책임 원칙
			- 원칙무시현상
				- 코드가 100줄 이상 넘어갈 경우
		- Open-Closed
			- 개방-폐쇄 원칙
			- 기존의 코드를 변경하지 않고도 기능을 추가할 수 있어야함
			- 원칙무시현상
				- 인터페이스화가 부족한 경우
		- Liskov substitution
			- 리스코프 치환 원칙
			- 하위 자료형이 상위 자료형의 모든 행동을 완전히 대체 가능해야함
			- 원칙무시현상
				- 상위 클래스와 하위 클래스 사이 계약(public 메서드)이 깨짐
				- 예시
					- 사각형을 상속받은 정사각형이 있지만 setHeight()라는 사각형의 메서드로 인해 정사각형의 높이 값이 변경될 수 있음 (정사각형은 모든 변의 길이가 같음)
		- interface-Segregation
			- 인터페이스 분리 원칙
			- 인터페이스를 하나로 합쳐버리면 나중에 클래스를 구현할때 불필요한 메서드까지 구현해야하기 때문에 인터페이스는 사용하지 않는 메서드는 인터페이스를 분리해야함
		- Dependency inversion
			- 의존성 역전 원칙
			- 구현 클래스에 의존하지말고 인터페이스에 의존해야함
			- 변하는 값은 추상화하라
				- 테스트 시 어떠한 객체를 사용하려면 테스트용 객체를 만들어 사용할 수 있게 인터페이스화하여야한다.![[Pasted image 20240629154518.png]]
				- 이러한 추상화를 통해 여러 구현객체를 만들어 테스트, 수정 운영이 가능해짐![[Pasted image 20240629154300.png]]
			- 의존성 주입
				- 의존성을 약하게 만드는 것이지 없애는 것이 아님
	- CQRS
		- 명령과 질의의 책임을 분리하라
			- 명령메서드
				- 상태를 변경시키며 리턴값을 가지지 않는 메서드
			- 질의메서드
				- 상태를 물어보는 메서드
- 팁
	- 500 에러
		- 500에러는 사실상 장애이며 API가 실패한다면 원인을 반드시 response해야함
	- 디자인 패턴에 매몰되지마라
		- 패턴은 단지 도구일 뿐 (패턴으로 인해 어떠한 개발을 못하는 상황이라면 변경해야함)
	- OOP
		- 객체지향 프로그래밍
			- 클래스지향 프로그래밍이 아님
		- 역할 책임 협력
			- 역할과 책임을 가진 객체들이 서로 협력하여 하나의 프로그램이 만들어짐
	- 상속은 지양, 컴포지션은 지향
		- 컴포지션
			- 공통 기능을 별도의 컴포넌트로 분리하고 그 컴포넌트를 멤버변수로 가지고 있어서 기능을 이용하는 것
- 스프링 OOP 패턴
	- Controller는 어떤 서비스를 실행할지 정도만 선택
	- 레이어 아키텍쳐를 지향해야함(컨트롤러에서 레파지토리로 바로 가는 아키텍쳐는 지양)![[Pasted image 20240630153406.png]]
	- DDD아키텍쳐
		- 4개의 레이어로 나눔
		- 서비스 계층이 아닌 도메인 계층이 비즈니스 로직을 가지고 있어야함
		- 서비스가 너무 많은 로직을 가지고 있으면 테스트코드를 짜는데 어려움이 생김 (객체에게 역할 위임 필요)
		- 서비스 계층 역할
			- 도메인 객체에 작업을 위임(그래서 서비스 객체는 최대한 얇아야함)
		- 도메인 계층 역할
			- 실질적인  비즈니스 로직을 실행
		- 가격 계산 처럼 객체로 표현하기 애매하고 논리 로직 자체가 목적인 경우 도메인 서비스라고 하여 새로운 객체를 만듬 (ex.PriceCalculator)
		- 아래 그림과 달리 도메인계층이 레파지토리를 안가지고 있는 설계도 존재 
		  (즉, 서비스계층이 레파지토리를 가질 것인지 도메인 계층이 레파지토리를 가질 것인지는 장단점이 존재하기에 설계에 따라 달라짐)![[Pasted image 20240630153517.png]]
- 추상화는 어디까지 해야하는가
	- 시스템 외부 연동, 레파지토리는 항상 추상화가 필요
		- DB, 또는 외부 시스템이 언제 변경될지 모르기 때문
	- 서비스계층의 추상화는 굳이 안해도됨
		- 서비스계층은 한번 생성되면 평생 같은 일을하게 되기 때문에 변경될 일이 없음
	- ![[Pasted image 20240630160304.png]]
- 서비스란 무엇인가?
	- 서비스의 멤버변수는 모두 final이여야한다
		- 서비스는 한번 생성되면 변경되지 않기 때문
- 테스트
	- 테스트 종류
		- 소형 테스트 (단위 테스트)
			- 단일서버, 단일 프로세스, 단일 스레드
			- DB, 네트워크 콜을 사용하지 않음
			- ![[Pasted image 20240630163820.png]]
		- 중형 테스트 (통합 테스트)
			- 소형 테스트 조건 + 멀티스레드, 멀티프로세스 사용
			- 테스트 용 DB사용 가능
		- 대형 테스트 (API 테스트)
			- 중형 테스트 + 멀티서버 사용
	- 테스트에 필요한 개념
		- SUT (System under test)
			- 테스트하려는 대상
		- TDD
			- 테스트 주도 개발
			- 원하는 기능의 코드 작성 전 기능의 대상을 테스트 코드를 작성
			- 실패하는 테스트 코드를 작성하여 실패확인
			- 그 후 실제로 구현 (테스트를 통과하는데 우선)
			- 그다음 코드 퀄리티를 위한 리팩토링
		- BDD
			- Behaviour driven development
			- 시나리오에 기반한 테스트 방식
			- given - when - then
				- 어떠한 상황이 주어지고 (given)
				- 어떤 행동을 할 떄 (when)
				- 어떤 결과가 나온다(then)
		- 테스트 더블
			- 테스트 대역 (가짜 객체)
			- 종류
				- Dummy
					- 아무런 동작하지 않고 그저 코드가 정상적으로 돌아가기 위해 전달하는 객체
					- 테스트에 필요한 인터페이스를 구현한 더미객체 (자제 로직 x)
					- ![[Pasted image 20240630165347.png]]![[Pasted image 20240630165353.png]]
				- Fake
					- 인터페이스를 구현하여 자체 로직이 존재하는 객체
				- stub
					- 별 로직 없이 미리 준비된 값을 출력하는 객체![[Pasted image 20240630165720.png]]
				- Mock
					- 메서드 호출을 확인하기 위한 객체
					- 사실상 테스트 더블과 동일한 의미로 사용됨
				- spy
					- 모든 메서드 호출을 기록해두고 있는 객체
				- 
	- 테스트 팁
		- private 메서드는 테스트하지 않는다
			- 만약 테스트하고 싶은 느낌이 든다면 다른 클래스로 위임하고 public으로 만들어야함
			- 즉, 중요한점은 행위에 대한 책임을 제대로 수행했는지 검증해야함
		- 테스트 코드는 DAMP
			- 테스트코드를 작성할 땐 중복을 신경쓰기보단 테스트하나하나마다 독립적이고 의미있는 테스트를 만드는 것이 좋다
		- 테스트에는 논리(+, for, if)넣지 않는다
			- 예측하지 못한 버그가 발생함
			- ![[Pasted image 20240630170812.png]]
			- ![[Pasted image 20240630170905.png]]
	- 테스트 기법
		- 의존성 추상화
		- 이벤트 기록
			- 어떤한 객체의 멤버변수 값을 확인해야하는데 테스트 때문에 그 값을 확인하는 메서드를 추가해야할 때 유용
- 실무에 필요한 개념
	- CDN
		- 컨텐츠를 효율적으로 전달하기 위해 여러 노드를 가진 네트워크에 저장하여 제공하는 시스템
		- 매번 서버에게 요청하기엔 disk i/o가 발생하기 때문에 서버 자원이 낭비됨
		- 그래서 이미지같은 컨텐츠를 CDN서버에 올려두고 네트워크 캐시처럼 이용
		- ![[Pasted image 20240701204129.png]]
	- ACL
		- 네트워크에 접근을 허거하는 IP리스트
		- 서버에 적용되며 일반적인 접근은 전부 제한되고 일부 IP, 일부 port에 대해 접근가능
	- Xaas
		- IaaS
			- infrastructure as a Service
			- 아마존 EC2 등 VM을 제공해주는 서비스
		- PaaS
			- Platform as a Service
			- 구글의 Colab 등
		- SaaS
			- SoftWare as a Service
			- 온라인으로 액세스 가능한 소프트웨어
			- 구글 드라이브 등
	- 다중화
		- 시스템의 일부 어떠한 장애가 발생할 경우를 대비하여 백업 장치를 배치해 운용하는 방식
		- Master-Slave
			- Write작업은 마스터에서만 Read작업은 마스터/슬레이브 모두 작업하는 방식이며
			- Write되었을때 Slave가 마스터의 데이터를 복제
			- 주로 MySQL에서 사용되는 방식
	- DR
		- 시스템이 장애가 발생했을 때 어떠한 방식으로 시스템을 복구하겠다는 계획
		- 다중화 이상의 장애 대응 메뉴얼을 작성하는 것 
	- Failover
		- 장애가 발생했을 때 예비 시스템으로 자동전환되는 기능
	- switchover
		- 장애가 발생했을 때 예비 시스템으로 수동전환하는 기능
	- Failback
		- Failover에 따라 전환된 시스템을 장애가 발생하기 전으로 되돌리는 처리
		- 대부분 수동처리
	- 젠킨스
		- 스크립트 처리기
		- 스크립트를 이용하여 코드를 빌드 / 배포함
	- ELK
		- 로그모니터링 도구들
		- 엘라스틱 서치, 로그스태치, 키바나를 합쳐 사용
		- 엘라스틱서치
			- 로그 저장소
		- 로그스태치
			- 생성된 로그를 이동시킴 (엘라스틱 서치로 이동)
		- 키바나
			- 로그로 데이터들을 가공하여 보여줌
	- Vault
		- DB의 비밀스러운 값은 Vault에 저장하고 해당 데이터에 접근 가능한 토큰을 반환받아 DB에 기록
		- 패스워드 등 데이터에 사용됨
	- CI/CD
		- 자동 빌드 / 자동 배포
		- 젠킨스 이용(스크립트 사용)![[Pasted image 20240701211919.png]]
		- githubAction 이용(스크립트 사용)![[Pasted image 20240701211957.png]]
		- 도커 / 쿠버네티스 / 젠킨스 이용 (가상 컨테이너 이용)![[Pasted image 20240701212049.png]]
	- 쿠버네티스
		- 컨테이너 오케스트레이션 도구
		- 컨테이너를 자동으로 배포, 관리, 스케일링할 수 있도록 도와주는 도구
		- 대표적으로 쿠버네티스, 도커 스웜이 존재
		- 설정된 값에 따라 ![[Pasted image 20240701213027.png]]
	- NoSQL
		- 모든 상황을 RDB하나로 해결하지 않고 섞어서 쓴다.
		- Key - value DB
			- key-value로만 이루어져 있는 거대한 Map
			- redis
				- 중앙화 된 캐시가 필요한 경우
				- 해당 Map이 메모리에 올라와 있기 때문에 빠르게 데이터를 가져올 수 있음
				- 싱글 스레드
		- Wid column DB
			- 대량의 데이터를 write하는 DB
			- cassandra
				- consistent hashing (데이터 저장 방식)
				- Write 성능이 뛰어남
		- Document DB
			- json처럼 생긴 데이터를 저장하는 DB
			- mongo DB
				- 확장성이 높음
				- 전문 검색 지원
			- elasticsearch
				- 검색엔진이 필요한 경우
				- 검색에 탁월
				- 통계에 유용
		- Message system
			- DB라기엔 애매함, 거대한 Queue
			- kafka, RebbitMQ
				- 통신에 있어 데이터 유실이 없어야 하는 경우
	- 개발용어
		- OAuth
			- 다른 웹사이트 상의 자신들의 정보에 대해 어떠한 웹, 애플리케이션의 접근 권한을 부여할 수 있는 공통적인 수단
				- 네이버 로그인, 카카오 로그인
		- 인증 vs 인가
			- 인증 (Authentication)
				- 이 토큰은 유효한 토큰인가?
				- 에러시 401
			- 인가 (Authoriztion)
				- 이 토큰은 이 리소스에 접근 가능한가?
				- 에러시 403
		- 함수형 프로그래밍
			- 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임
			- 불변값이 이에 대응
		- 라이브러리 vs 프레임워크
			- 컴포넌트 생성과 호출의 주체가 누구인가?
			- Ioc Container의 유무에 따라 나뉨
		- CORS
			- 교차 출처 리소스 공유
			- 어떠한 도메인에서 어떠한 서비스를 호출하는 것을 막기 위한 정책
			- 웹 페이지 상 제한된 리소스를 다른 도메인으로부터 요청 못하게 하는 구조
			- API서버가 지정한 도메인에서만 통신
		- 멱등성
			- 여러번 실행해도 실행결과가 같음
	- RDB 조언
		- 실행계획
			- 인덱스가 제대로 타는지 확인하기 위해 실행계획을 보아야함
			- EXPLAIN 
				- select 쿼리 앞에 붙여준다.
				- 컬럼
					- type
						- 이 컬럼을 통해 인덱스를 탔는지 안탔는지 알 수 있음
					- key
						- 의도한 인덱스를 탔는지 확인할 때 사용
		- 외래키 사용을 지양
			- 외래키는 CUD 시 락 경합을 유도하고 성능을 저하시킴
		- 한방쿼리를 지양
			- Case, if then, 서브쿼리를 지양
			- 차라리 쿼리를 여러개로 쪼개는게 나음
		- IN 
			- IN 쿼리의 갯수가 특정 이상 넘어가면 풀스캔으로 변경되기에 유의 (보통 100개이상이면 쿼리를 쪼개야함)
		- 
- 헥사고날 아키텍처
	- 레이어드 아키텍쳐
		- ![[Pasted image 20240703204538.png]]
		- 문제점
			- 결과물이 엉망
			- 절차지향적 프로그래밍을 하게됨 (객체에 대한 진지한 고민이 없음)
		- 수정
			- 도메인 계층을 추가
			- ![[Pasted image 20240703205102.png]]
			- 테스트에 유리
				- 도메인 계층은 순수 자바이기에 인스턴스 생성이 쉬움
				- 서비스 계층은 도메인, 레파지토리 두 계층에 의존
					- 도메인은 순수자바이기에 쉬움
					- 레파지토리의 경우 의존성 역전을활용하여 레파지토리 인터페이스를 만들어 Mock, Fake를 넣어 테스트![[Pasted image 20240703205416.png]]
				- 컨트롤러 계층은 3개의 의존성을 가지게 되지만 의존성 역전을 하여 서비스 인터페이스를 만들고 Fake, Mock을 넣어 테스트![[Pasted image 20240703205731.png]]
	- 헥사고날 아키텍쳐
		- 사실 상 이그림이 헥사고날 아키텍쳐![[Pasted image 20240703211215.png]]
		- ![[Pasted image 20240703211256.png]]
		- 장점
			- 상향식 접근이 가능해짐![[Pasted image 20240703211414.png]]
				- 기존 레이어 아키텍쳐이 이부분이 굉장히 모호했음
	- 클린아키텍쳐
		- 헥사고날 아키텍쳐는 클린 아키텍쳐의 실천 방식 중 하나
		- 결국 결이 같다
		- ![[Pasted image 20240703211527.png]]
- 코드 튜닝
	- 가벼운 문자열 합 연산은 + 가 아닌 StringBuilder를 통해!
		- String자체는 불변이기에! 합연산할 때마다 메모리에 새로운 객체가 할당됨
		-  하지만 가벼운 연산은 컴파일러가 알아서 튜닝해주고 튜닝을 안해주더라도 가독성을 위해 + 연산이 좋을 수 있음
		- 