1. 쓰레드 로컬
- 해당 쓰레드만 접근할 수 있는 특별한 저장소

- 그래서 지역변수가 아닌 전역변수에 값이 변경하여도
  해당 쓰레드만 쓰는 저장소이기에 구분이 됨

- 쓰레드 로컬을 모두 사용했으면 반드시 
  ThreadLocal객체.remove()을 통해 해당 저장소 값을
  제거해주어야함
  (WAS는 쓰레드를 쓸때 쓰레드 풀에서 해당 쓰레드를 가지고
   프로세스를 실행하는데 만약 해당쓰레드로컬값을 지우지 않은 경우
   쓰레드풀에서 쓰레드를 불러올때 해당 쓰레드로 할당되는 경우
   쓰레드로컬에서 이전에 들고있는 값을 그래도 사용하면서
   데이터의 문제가 생길 수 있다
   ex. A사용자가 사용 이후 B사용자가 해당 쓰레드로 할당이 되었는데
        조회하면서 해당 쓰레드로컬의 값을 불러오는데 
        쓰레드로컬값을 삭제하지 않았으므로 A사용자의 데이터를
        보여주게 됨
   )

- 사용법
-- 변경되는 필드 값에 대해
    ThreadLocal<해당 필드 타입> 이름 = new ThreadLocal<>();
    선언

-- 해당값을 저장할땐 ThreadLocal객체.set(넣을값)
    해당값을 불러올땐 ThreadLocal객체.get()
    해당값을 지울땐 ThreadLocal객체.remove()


2. 템플릿 메서드 패턴
- 핵심기능과 부가기능을 분리할 수 있는 디자인 패턴이다.

- 변하는 핵심기능과 변하지 않은 부분을 따로 분리하여 모듈화

- 상속을 사용하기 때문에 자식클래스와 부모클래스가 컴파일시점에서
   강하게 결합되며 해당 템플릿 메서드 패턴은
   자식클래스 입장에서는 부모클래스의 기능을 다 사용하지 않는다
   부모 클래스가 변하면 자식클래스도 영향을 받음
   상속 자체가 단점이 됨

- 원리
-- 상속 받을 추상 클래스를 하나 만들고
    핵심기능이 들어갈 로직의 메서드를 만드는데
    추상 메서드로 만듬
    (해당 추상 클래스를 상속받은 클래스에서 직접 기능 구현)

--  부가기능 로직에 대한 메서드를 만들어서 
     해당 핵심기능이 들어가는 추상메서드를 넣어준다.
    그렇게 해서 상속받은 클래스에서는 해당 부가기능 메서드를
    사용
    (이러면 매 로직마다 클래스로 나누어서 만들어야하지 않나?
     >> 익명 내부 클래스를 이용해 매번 클래스를 만들 필요는 없음
    ex.) AbstractTemplate template1 = new AbstractTemplate() {        
          	@Override        
           	protected void call() {            
           	       log.info("비즈니스 로직1 실행");       
           	}   
          };
     즉, 굳이 상속받을 클래스를 만들 필요 없이 
     익명 내부 클래스를 만들어 적용시킴

3. 전략 패턴
- 변하지 않는 부분(context), 변하는 부분(strategy)로 나누고
   strategy라는 인터페이스를 만들고 context클래스에 변하지 않는 로직을 넣어
   그 사이에 strategy넣고 strategy를 의존성주입을 구현체를 외부에서 받아서 사용
   상속을 사용하지 않아 강한 결합이 없어짐
   
- 전략을 필드가 실행메서드의 파라미터로 받아서 
  메서드에 해당 파라미터로 전략을 받아
  선조립할 필요없이 실행할때마다 전략을 바꿀 수 있어서
  유연하게 됨. (람다 사용)
  (이렇게 사용한는 것을 스프링에서 템플릿 콜백 패턴이라고 함)
  (xxxTemplate이라고 되어있다면 템플릿 콜백패턴으로 만들어져있음) 

4. 프록시
- 직접 요청하는 것이 아니라 어떤 대리자를 통해 간접적으로 요청

- 부가기능을 추가하거나 캐싱 또는 권한에 따른 접근차단을 하는데 사용됨

- 객체에서 프록시가 되려면 클라이언트는 서버에게 요청한 것인지 프록시한테
  요청한 것인지 몰라야하기에 인터페이스를 사용하고 서버 대신 프록시로 대체함

- GOF 디자인 패턴에서는 의도에 따라 프록시를 구분함
-- 프록시 패턴 : 접근 제어가 목적 (캐시를 이용)
-- 데코레이터 패턴 : 새로운 기능 추가가 목적 

- 클라이언트가 프록시를 호출하면 최종적으로는 실제 객체를 호출해야하며
   모양이 같아야하기에 실제 객체의 구현 인터페이스를 통해 구현체로 만듬
   프록시 객체는 실제 객체를 참조해야함

- 프록시는 스스로 존재할 수 없으며 내부의 실제 객체가 필요하다.

- 인터페이스 기반, 클래스 기반으로 만들 수 있다!
  (인터페이스가 좋다 유일한 단점은 인터페이스를 만들어야함) 
   
- 동적 프록시
-- 프록시를 사용하려면 클래스 수만큼 프록시 클래스를 만들어야한다
    하지만 JDK 동적 프록시를 사용하여 프록시를 적용할 코드 하나만 만들어주고
    프록시 객체를 찍어낼 수 있음

-- 리플렉션
--- 클래스, 메서드의 메타정보를 활용하여 코드를 동적으로 호출

--- 해당 메타정보를 얻는 메서드덕에 메서드를 동적으로 호출할 수 있게 됨
     실제객체와 해당하는 메서드객체만 있다면 해당 객체의 메서드를 호출 가능해짐
      (메서드를 공통로직에 포함할 수 있다)

--- 주의
---- 리플렉션을 사용하면 런타임에 동작하기에 컴파일로 잡을 수가 없음

--- 사용 메서드
---- Class.forName("경로") >> 해당 경로의 클래스 메타정보를 클래스 객체로 반환
      (내부 클래스의 경우 .이 아닌 $로 구분)

---- Class객체.getMethod("메서드 이름") >> 해당 클래스의 메서드 메타정보를 메서드객체로 반환

---- Method객체.invoke(실제 객체, 해당메서드 파라미터[배열]) >> 획득한 메서드 메타정보를 실제 객체의 메서드에서 호출
      (오브젝트 형태로 반환함)

-- JDK를 활용한 동적 프록시 생성 (인터페이스가 필수임)
--- InvocationHandler 인터페이스를 구현함
     (클래스에 적용할 공통로직을 호출할 역할을 하게될 클래스)
     public interface InvocationHandler {
     	public Object invoke(Object proxy, Method method, Object[] args)        throws Throwable; 
     }

--- 사용할 땐 해당 핸들러를 생성하고 난 후
     Proxy.newProxyInstance(실제로직클래스.class.getClassLoader(), new Class[]{해당클래스.class}, 핸들러객체)
     를 통해 해당 클래스에 맞는 프록시 객체를 생성한다.(클래스 구현없이)
     (Object형으로 반환하기에 캐스팅해줘야함 인터페이스로 만들었다면 인터페이스를 .class해준다)

--- 만든 프록시객체.call()을 통해 호출한 결과를 반환!

--- 프록시 로직을 적용하고 싶지 않은 메서드가 있다면
     PatternMatchUtiles.simpleMatch()를 이용하여
     해당 메서드 이름에 해당하는 로직들은 거르도록 구현하면됨

--- 단점: 인터페이스가 적용된 클래스만 가능 필수!

- CGLIB
-- 바이트코드를 조작해서 동적으로 클래스를 생성하는 라이브러리

-- 해당 라이브러리로 인터페이스가 없어도 구체 클래스만으로도 동적 프록시를 생성할 수 있다.

-- 클래스를 상속받아 프록시를 생성하기 때문에 클래스,메서드에 final이 붙으면 사용할 수 없음

-- 사용방법
--- MethodInterceptor를 구현받은 구현체 생성
     (클래스에 적용할 공통로직을 호출할 역할을 하게될 클래스)
     public interface MethodInterceptor extends Callback {    
     	Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable; 
     }
 
--- 공통로직 만들고 본 로직은 methodProxy.invoke(실제객체, 파라미터)
     통해 동적으로 호출하게 만듬
     (성능상 methodProxy를 사용하는것을 권장함)

--- 만든 구현체를 사용할 땐
     Enhancer객체를 생성하고 Enhancer객체.setSuperclass(실제로직객체.class)
     		             (구체 클래스를 상속받을지 지정)
     그리고 Enhancer객체.setCallback(MethodInterceptor구현체의객체)
               (프록시에 적용할 실행 로직을 할당)
     Object proxy = enhancer.create()로 프록시 객체를 생성
     (캐스팅 필수)
     그후 프록시객체.call()로 프록시 로직 호출

- 프록시 팩토리
-- 인터페이스가 있다면 JDK동적 프록시를 사용하고
    구체 클래스만 있다면 CGLIB를 사용하게 설정할 수 있다.
  
-- 스프링에서는 각 케이스마다 MethodInterceptor, InvocationHandler를 만들 필요 없이
    Advice를 사용하여 프록시 팩토리 내부에서 호출한다.
    (스프링에서는 케이스에 따른 인터페이스의 구현체를 자동으로 생성 후 Advice를 호출하기 때문에
    개발자는 공통로직에 대한 코드의 Advice만 만들어주면 됨)
    (프록시 생성(스프링)과 공통로직(개발자)을 분리함)

-- 특정 조건에 맞을때만 공통로직을 사용하고 싶다면 포인트컷을 도입하여 적용가능함

-- 사용법
--- 해당 advice를 구현
     package org.aopalliance.intercept;
     public interface MethodInterceptor extends Interceptor {    
     	Object invoke(MethodInvocation invocation) throws Throwable; 
      }
      (org.aopalliance 패키지명을 조심!)
      (MethodInvocation에 프록시 모든 정보가 포함됨)
      (부모로 advice를 구현받고있음)

--- 구현클래스에서는 본로직(target)을 필드로 넣을 필요가 없다.
     (프록시 팰토리로 프록시를 생성하는 단계에서 이미 target정보를 파라미터로
      전달 받았기 때문  MethodInvocation에 포함됨)
     공통로직을 구현 후 
     오버라이딩 메서드의 파라미터 MethodInvocation객체.proceed()를 통해
     타겟 클래스를 호출하고 그 결과를 반환받음

--- 사용할땐 프록시팩토리 객체를 생성하여 실제로직객체(target)를 넣어줌
     그 후 프록시팩토리객체.addAdvice(해당 공통로직 구현체)로 넣어줌
     (또는 프록시팩토리객체.addAdvisor(해당 어드바이저) 로 어드바이저를 넣을 수 있다)
     그리고 프록시팩토리객체.getProxy()로 해당 프록시객체를 꺼내오고 빈 주입

--- 프록시팩토리객체.setProxyTargetClass(true)로 설정하면
     인터페이스가 존재해도 CGLIB 사용하여 클래스기반으로 프록시를 생성함
  
-- 스프링 AOP (프록시 한정)
--- 포인트컷 : 어디에 공통로직을 적용할지, 안할지 판단하는 필터링 로직 (공통로직과 필터의 역할을 나누기 위함)
--- 어드바이스 : 프록시가 호출하는 공통로직
--- 어드바이저 : 단순하게 하나의 포인트컷과 하나의 어드바어스를 가지고 있는 것
          
--- 프록시를 호출하면 포인트컷로 먼저 필터하고 advice가 호출됨

--- DefaultPointcutAdvisor(포인트컷객체, 어드바이스객체)를 통해 
     포인트 컷 하나와 어드바이스 하나의 어드바이저 객체를
     생성 후 프록시팩토리객체.addAdvisor 해준다!
     (addAdvice는 포인트컷이 항상 true인 어드바이저를 만든 편의 메서드이다)

--- 여러 공통로직을 적용시키고 싶을 땐
     프록시를 여러개 만드는 것보다 최적화를 위해
     하나의 프록시에 여러 어드바이져를 넣는 형식으로 진행한다

*** 스프링 AOP는 target마다 하나의 프록시만 생성!!!
     (어드바이저만 여러개 적용됨)
--- 직접 pointcut 만들기
---- Pointcut인터페이스를 구현한 구현체를 만들어야함
---- `ClassFilter` 와 `MethodMatcher' 두개의 객체로 이루어지는데
      해당 클래스가 맞는지, 해당 메서드가 맞지는 판단하며
      둘다 true여야 advice를 적용할 수 있다.

--- 스프링이 제공하는 pointcut
---- NameMatchMethodPointcut객체를 생성 이후
      NameMatchMethodPointcut객체.setMappedNames("메서드이름")
      을 통해 간단히 등록

---- 다양한 스프링제공 pointcut
----- NameMatchMethodPointcut : 메서드 이름을 기반으로 매칭한다. 
        내부에서는 `PatternMatchUtils` 를 사용한다. 
----- JdkRegexpMethodPointcut : JDK 정규 표현식을 기반으로 포인트컷을 매칭한다. 
----- TruePointcut : 항상 참을 반환한다. 
----- AnnotationMatchingPointcut : 애노테이션으로 매칭한다. 
----- AspectJExpressionPointcut :  aspectJ 표현식으로 매칭한다.
        (실무에서 가장 많이 쓰고 편리하고 기능도 가장 많다)

5. 빈후처리기 (BeanPostProcessor)
- 스프링 컨테이너에 빈이 생성 후 빈이 등록되기 직전에 빈을 조작 할 수 있음

- 생성된 객체를 빈 저장소에 등록하기 직전에 빈후처리기에 전달된 후
  작업이 끝나면 빈저장소에 등록이 됨.

- 등록 이전에 빈을 조작 즉, 특정 메서드를 호출 가능해진다.
   그래서 빈후처리기를 통해 컴포넌트 스캔을 통해 자동으로 빈을 등록해줄 때
   프록시 빈으로 바꿔치기할 수 있음!

- 사용법
--  해당 인터페이스를 구현하고 스프링빈으로 등록하기만 하면됨
     public interface BeanPostProcessor {    
     	Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException    
      	Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException 
      }
      (postProcessBeforeInitialization >> 객체 생성 이후 @PostConstruct 초기화 이전에 호출)
      (postProcessAfterInitialization >> 객체 생성 이후 @PostConstruct 초기화 이후에 호출)

-- 모든 빈에 해당되기 때문에 적용하지 않고 싶은 빈이 있다면
    걸러줘야함(포인트 컷으로 깔끔하게 가능)

-- 프록시 빈으로 대체하고 싶다면 해당 구현체에 프록시 팩토리 로직을 넣어주고 프록시를 반환하면 됨

- 스프링에서 제공하는 빈후처리기
-- 자동 프록시 생성기 ( AnnotationAwareAspectJAutoProxyCreator)
--- 해당 빈은 스프링부트aop관련 라이브러리를 적용하면
     자동으로 빈으로 등록되며 자동 프록시 빈 생성을 담당함

--- 빈이 생성되고 빈 후처리기가 처리하면서 모든 advisor빈을 조회한다
     그 후 advisor의 포인트컷을 사용하여 프록시 적용대상인지 아닌지 해당 객체의 모든 메서드에 매칭하여 
     판단 후 하나의 메서드라도 만족하면 해당 객체는 프록시객체로 빈으로 등록

--- 사용할땐 빈후처리기는 이미 스프링에서 자동으로 등록하엿기 때문에
     개발자입장에서는 advisor만 빈으로 등록하면됨

--- 여기서 포인트컷은 두가지로 사용됨
---- 프록시 생성 단계 >> advisor의 포인트컷들을 보고 모든 메서드를
       체크하는데 하나라도 조건에 만족하면 프록시객체를 생성해서 빈 등록

---- 프록시 사용 단계 >> 해당 메서드를 사용할 때 advisor의 포인트컷을 보고
      조건에 만족하면 advice를 호출하여 프록시로직을 실행 후 실제 로직을 실행            
      조건에 부합하지 않는다면 바로 실제로직 실행

--- 정밀한 포인트컷
---- 포인트컷에서 매우정밀하게 지정해주지 않으면 원하지 않는 빈에도 적용이 됨.
      그래서 AspectJ표현식을 사용하는 포인트컷을 사용하여 보다 정밀하게 조건을 지정해줌
       (AspectJExpressionPointcut)
---- AspectJExpressionPointcut객체.setExpression("표현식")
      ex. pointcut.setExpression("execution(* hello.proxy.app..*(..))");
---- * : 모든 반환 타입
---- hello.proxy.app.. : 해당 패키지와 그 하위 패키
---- *(..) : * >> 모든 메서드 이름, (..) >> 파라미터는 상관 없음
     
6.@Aspect
- 스프링은 @Aspect 어노테이션으로 편하게 어드바이저를 만들 수 있다.

- AspectJ에서 제공하는 어노테이션이다.

- 자동프록시 생성기(AnnotationAwareAspectJAutoProxyCreator)는
  추가로 @Aspect가 있는 빈을 찾아 이것을 advisor로 변환해줌
   (BeanFactoryAspectJAdvisorsBuilder로  @Aspect의 정보 기반으로 
    포인트컷과 어드바이스를 만들고 그것을 감싼 어드바이저를 생성함)

- 사용법
-- 클래스단에 @Aspect를 붙여줌
-- 메서드단에 @Around("AspectJ표현식[조건]")을 넣어줌(포인트컷)
-- 메서드를 생성하고 파라미터에 ProceedingJoinPoint를 넣어줌
-- 공통로직 구현 후 실제 로직에 ProceedingJoinPoint객체.proceed() (어드바이스)


7. 스프링 AOP
- 핵심기능과 부가기능
-- 핵심기능은 혼자 사용된다
-- 부가기능은 핵심기능을 서포팅하는 기능이며
    혼자 사용될 수 없다

- 핵심기능과 부가기능을 분리하고 
  해당 부가기능을 어디에 적용할지를 하나의 모듈로 만들었는데
  그것을 '애스펙트'라고 함

- 애스펙트를 사용한 프로그래밍 방식을 AOP라고 함

- OOP를 부족한 부분을 보조하는 목적으로 개발됨

- AOP의 대표적인 구현 프레임워크로 AspectJ가 있음
 
- AOP적용방식
-- 컴파일 시점
--- .class로 만들어지는 사이에 부가기능로직을 넣음
     (.class로 만들어질 때 애스팩트관련 호출코드가 들어감)

--- 단점: 특별한 컴파일러가 필요하고 복잡해서 잘 인쓰임

-- 클래스 로딩 시점
--- .class파일을 JVM내부의 클래스 로더에 보관하는데 그 시점에
     .class파일을 조작한 다음 JVM에 올림 (java instrumentation)
     
--- 단점 : 이것도 번거럽고 운영이 힘듬

-- 런타임 시점
--- 자바가 실행되고나서 부가기능로직을 적용하며
     프록시 방식의 AOP이다. (스프링이 존재하면 간단하게 설정가능)

--- AOP일부 기능의 제약이 있지만 복잡한 옵션이나 조작기를 설정하지 않아도 됨.
    (final, 생성자에 대한 적용 제약이 있어서 메서드만 가능하다)

- AOP적용 위치 (조인 포인트)
-- 프록시를 사용하는 AOP가 아니라면 메서드 시점만이 아니라
    생성자, 필드값 , 메서드 접근, static 메서드 접근에도 다 적용 가능하다.

- AOP 용어
-- 조인포인트 >> AOP를 적용할 수 있는 위치 
   (메서드실행시점, 생성자 호출시점, 필드값 접근 시점, static메서드 접근 시점 등등)
-- 포인트컷 >> 조인 포인트 중에서 어드바이스가 적용될 위치를 선별하는 기능
-- 타겟 >> 어드바이스를 받는 객체
-- 어드바이스 >> 부가기능
-- 어드바이저 >> 하나의 어드바이스와 하나의 포인트 컷으로 구성
                        (스프링 AOP에만 사용됨)
-- 애스펙트 >> 어드바이저(어드바이스 + 포인트컷)을 모듈화 한 것
-- 위빙 >> 포인트컷으로 결정한 타겟의 조인 포인트에 어드바이스를 적용한 것
               (AOP를 적용하기 위해 애스펙트를 객체에 연결한 상태)
