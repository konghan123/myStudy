- 리눅스란
	- 다양한 배포판이 존재
		- 리눅스 기반이기에 공통점도 존재하지만 차이점도 존재
		- 대표적으로 우분투, 센토스 페도라 등등
		- 배포판의 공통점
			- 리눅스 커널을 사용
			- GNU단체에서 만든 소프트웨어를 탑재
		- 배포판의 차이점
			- 운영체제를 구성하는 요소의 프로그램이 다름
				- 데스크탑 관리자
				- 패키지 매니저
				- 기본 파일 시스템
		- 필요한 리눅스를 골라 사용하면 됨
- 운영체제
	- 구성요소
		- 커널
			- 하드웨어들을 관리
			- 대부분의 구성요소에 관여함
		- 프로그램실행, 멀티 테스킹
			- 프로세서 스케줄러 존재
		- 인터럽트
			- 하드웨어가 OS에게 알려주는 신호
		- 메모리 관리
		- 파일 시스템
		- 디바이스 드라이버
		- 네트워킹
		- 사용자 인터페이스
- 패키지 관리 시스템
	- 패키지 매니저를 통해 패키지 저장소에 요청하여 필요한 어플리케이션을 설치
	- 기본구조![[Pasted image 20240818135027.png]]
	- 패키지 간 의존성
		- 어떠한 어플리케이션이 정상적으로 동작하기 위한 어플리케이션들이 존재
		- 그러한 의존관계를 관리하고 자동으로 설치해줌( 이전엔 이러한 의존관계를 파악하고 일일이 설치함)
- 리눅스 쉘 명령어
	- 리눅스 쉘
		- 사용자가 리눅스 시스템을 사용하기 위한 매개체![[Pasted image 20240821194240.png]]
		- bash (born again shell)
			- 리눅스 쉘 프로그램
		- 터미널을 통해 쉘을 사용
			- 정확히는 bash라는 프로그램을 터미널 프로그램으로 실행
		- ==리눅스는 확장자로 동작하지 않음==
	- 기본 쉘 명령어![[Pasted image 20240821195605.png]]
		- man + 커맨드 : 커맨드의 메뉴얼 확인 가능
		- 폴더이동
			-  cd
				-  + 폴더 : 해당 폴더로 이동
				-  + .. : 루트상 이전 폴더로 이동
				-  + - : 직전에 위치했던 폴더로 이동
		- pwd : 현재 폴더 위치
		- ls : 현재 폴더에 존재하는 파일 및 폴더 표기
			- + -al : 현재 폴더에 존재하는 파일 및 폴더의 자세한 정보 표기
			- + -i : 현재 폴더에 존재하는 파일의 아이노드의 정보 표기
		- 파일보기
			- cat + 파일이름
				- 터미널 버퍼크기만큼 파일 내용을 열람
			- head + -n + (줄수) + 파일이름
				- 해당 파일의 위에서 몇줄 내용만 열람 (기본 10줄)
			- tail + -n + (줄수) + 파일이름
			- less(more) + 파일이름
				- 한화면에 모든 파일 내용 열람 가능
		- 파일 내용 검색
			- grep + -(옵션) + "내용" + 파일이름
				- 파일 안 내용에서 원하는 내용을 찾기 가능
		- 파일 정보
			- stat + 파일이름
		- 파일검색
			- find
				- + 디렉토리 경로 + - name + "파일명" + 수식
				- 기본 경로는 현재 디렉토리
				- 기본 수식은 -print
				- 검색시 그 디렉토리를 포함하는 하위 디렉토리들을 전부 포함하여 검색함
				- 현재디렉토리 경로는 '.' 으로 표현함
				- 파일명의 경우 모두 포함되는 경우 \*\로 표시
				- 절대경로 표시 : /디렉토리/디렉토리
				- 상대경로 표시 : ./디렉토리/디렉토리
		- 디렉토리 생성
			- mkdir + 폴더이름
				- 폴더이름으로 폴더 생성
		- 비어있는 디렉토리 삭제
			- rmdir + 폴더이름
				- 폴더이름으로 폴더 삭제
				- 하지만 파일이 존재할 경우 실패
		- 파일 or 디렉토리 삭제
			- rm + -rf + 폴더(파일)이름
		- 파일 경로(이름)바꾸기
			- mv
				- + 원래경로 + 바꿀경로
				- 파일이 이동한것처럼 보임
				- . 으로 현재경로 표시 가능
		- 압축관련
			- gzip
				-  + 파일이름
				- 해당 파일을 gzip으로 압축
				- 기존 파일은 없어지고 압축된 파일로 변경됨
			- gunzip
				- + 파일이름
				- 해당 압축파일을 파일로 압축해제
				- 기존 압축된파일은 없어지고 압축 푼 파일로 변경됨
			- tar
				- tar 파일이란?
					- 여러 파일을 연결한 파일
				- tar 툴을 사용하는 커맨드
				- + -cf + tar파일이름 + 압축할 파일 + ... + ... : 해당파일들을 tar파일이름으로 tar파일로 만듬
				- + -czf + 압축할이름 + 압축할 파일 + ... + ... : 해당파일들을 tar파일이름으로 tar파일로 만들고 압축함
				- + -zxf + 압축풀 파일경로 : 현재경로에 압출풀 파일경로의 tar.gz파일을 압축해제
			- file
				- + 파일이름
				- 파일에 대한 정보를 알 수 있음
		- 시간관련 커맨드
			- date
				- 현재 시간 출력
				- + +포맷 : 포맷에 맞게 현재 시간 출력 
			- cal
				- 달력을 출력
				- + 년도 : 년도의 전체 달력을 출력
				- + -A(B) + 숫자 : 현재 시간의 숫자달 이후(이전)의 달을 보여줌
		- 기타 커맨드
			- history
				- 커맨드 히스토리 출력
				- 커맨드 실행 순서가 매겨짐
				- 매겨진 순번으로 '  !순번  ' 커맨드를 통해 해당 순번의 커맨드를 실행 시킴
			- !!
				- 직전 커맨드 실행
			- exit
				- 쉘을 빠져나오는 커맨드 (터미널을 끝내는 커맨드가 아님)
				- 여러 쉘이 존재할 때 해당 쉘을 종료할 때 쓰임
			- echo
				- + 텍스트 or 변수
				- 텍스트 or (변수에 저장된 값)을 출력해줌
				- bash의 변수 설정 시 변수를 출력할 수 있음
				- $PWD 의 $는 뒤에 변수가 나온다는 의미
			- env
				- 환경변수로 설정된 변수들을 출력
			- which
				- + 명령어 : 명령어의 위치를 출력
		- 관리자 권한 실행
			- sudo
		- 패키지 관리 시스템
			- 레파지토리에서 필요한 패키지 검색하여 내 PC에 설치하고 삭제할 수 있음
			- apt
				- + 옵션 + 설치(삭제)할패키지이름
				- ex. sudo apt install 패키지이름
		- 텍스트 에디터
			- nano
				-  커맨드 입력 시 나노창으로 이동
				-  + 파일이름 : 해당 파일 내용을 텍스트 에디터를 실행
				- 나노 에디터 내 커맨드
					- ^ = ctrl      M = alt
		- 하드링크, 소프트링크 파일 추가
			- ln
				- + 파일이름 + 하드링크로추가할파일이름
				- 하드링크의 갯수![[Pasted image 20240825125842.png]]
				- + -s 파일이름 + 소프트링크로추가할 파일이름
		- 계정 관련 커맨드
			- 현재 계정 확인
				- whoami
			- 계정 추가
				- adduser
					- + 계정이름 + [옵션]
					- 관리자 권한으로만 사용 가능
					- 옵션![[Pasted image 20240825142205.png]]
			- 계정 삭제
				- deluser
					- + 계정이름 + [옵션] 
					- 옵션![[Pasted image 20240825143624.png]]
			- 사용자변경
				- su
					- + - + 계정이름
				- exit
					- 해당 계정 종료
			- 그룹 추가
				- addgroup
					- + 그룹이름
		- 권한 관련 커맨드
			- chmod
				- + 표기법 + 파일이름
				- 디렉토리에도 권한이 존재함 (파일을 추가할 때 필요)
				- 예시
					- ex. chmod 664 파일이름
					- ex. chmod g+w 파일이름
		- 프로세스 관련 커맨드
			- ps
				- + -f : 더 자세한 정보를 출력
				- + -e : 현재 터미널에서 실행한 프로세스 이외에도 모든 프로세스를 출력
					- 대괄호로 묶인 커맨드는 커널에서 관리하는 프로세스를 뜻함
				- + --forest : 프로세스 계층에 따라 트리구조로 출력
				- 프로세스 목록을 출력
- 파일
	- 경로 + 이름 으로 위치를 구분
	- 같은 디렉토리 내에선 같은 이름의 파일이 존재할 수 없음
	- 파일시스템
		- 파일들을 관리하기 위한 OS 계층에 존재하는 시스템 (소프트웨어)
		- tree형태의 구조
			- 리눅스의 트리구조는 반드시 최상위 '루트'가 존재하고 나머지 파일들을 하위에 존재하게 됨
			- 윈도우처럼 디스크별로 나뉘지 않기에 만약 새로운 디스크의 파일들을 확인하고 싶다면 새 폴더를 만들고 그 폴더에 해당 디스크를 mount해야함
	- 파일의 종류
		- ![[Pasted image 20240824125441.png]]
		- 디바이스 파일
			- 유저모드 어플리케이션에서 OS수준의 디바이스 드라이버에 명령을 조달할 수 있는 파일
			- 디바이스 특성에 따라 어떤 식으로 처리할 지 달라짐
				- 영역을 공유할때 블록
				- 순차적인 동작을 처리할 때 문자
		- 파이프 파일
			- 구동중인 프로세스와 다른 프로세스가 통신할때 사용되며 그때 생성됨
		- 소켓 파일
			- 구동중인 프로세스와 다른 프로세스가 통신할때 사용되며 그때 생성됨
	- 대표적인 디렉토리
		- ![[Pasted image 20240824131820.png]]
		- /etc
			- 시스템 구성에 여러 설정파일들이 존재(주의필요!)
		- /proc, /sys
			- 운영체제의 정보를 조회, 설정할 수 있는 파일들이 존재 (실제 디스크의 파일들이 아닌 운영체제가 만들어낸 가상 파일
	- 
- 스크립트 파일
	- 명령어를 모은 파일
	- 생성 시 파일 첫줄에 \#!/bin/bash로 지정해줌
	- 스크립트 실행
		- 해당 파일의 절대경로를 입력하면 실행됨
		- 해당 파일의 상대경로를 입력하면 실행됨
			- ex ) ./파일이름 
- 아이노드
	- 파일에 대한 메타데이터들이 저장되어 있는 공간
	- 파일이름은 아이노드에 포함되지 않음
	- 파일은 파일이름, 아이노드, 파일데이터로 구성됨
	- 파일의 구조![[Pasted image 20240825121615.png]]
- 소프트링크 vs 하드링크
	- ![[Pasted image 20240825121828.png]]
	- 소프트링크(심볼릭링크)
		- '바로가기' 파일과 비슷함
		- 새로운 아이노드가 생성됨
		- 대상 파일의 경로만 저장하기에 대상파일 삭제시 접근 불가
		- 절대경로로 지정할 경우 소프트링크 파일의 경로를 변경해도 접근 가능
		- 해당 파일 이름을 기준으로 링크하기에 삭제 후 다시 만들면 새로만든 파일에 접근됨
	- 하드링크
		- 해당 파일의 아이노드를 공유하는 방식
		- 파일의 이름만 다름
		- 원본 파일 삭제해도 접근 가능
		- 경로가 변경되어도 접근 가능
- 사용자와 그룹
	- 루트 계정(관리자)가 존재하며 일반사용자계정과 일반사용자계정들이 묶인 그룹이 존재함 ![[Pasted image 20240825134314.png]]
	- 파일의 소유권![[Pasted image 20240825134847.png]]
		- Owner가 파일의 소지자이며 그 Owner가 포함된 그룹이 존재하며 그값이 Group이다.
	- 유저 설정 확인
		- /etc/passwd 파일을 통해 확인 가능![[Pasted image 20240825141713.png]]
	- 파일의 권한
		- Owner와 Group 사용자, 그외 사용자에 대한 해당 파일 권한은 permission에서 지정됨
		- 실행권한은 실행가능한 파일만 부여함
		- ![[Pasted image 20240825135726.png]]
		- 권한 설정
			- 8진표기법 사용
				- 
				- ![[Pasted image 20240825140903.png]]![[Pasted image 20240825140909.png]]
			- 의미표기법 사용
				- ![[Pasted image 20240825141249.png]]
	- 
- 프로세스와 시그널
	- PID
		- 프로세스의 유니크한 아이디
	- 부모, 자식 프로세스
		- 어떠한 한 프로세스(부모)가 다른 여러개의 프로세스(자식)를 만듬
	- init 프로세스
		- 부팅되어 커널이 하드웨어들을 초기화하고 프로세스들을 초기화하는데 그때 프로세스가 아무것도 없는 상태에서 커널이 만든 프로세스
		- PID 1번을 가짐
		- init프로세스가 다른 여러 프로세스를 만들게 됨
	- 프로세스 종료
		- 프로세스가 종료될 때 해당 프로세스가 사용하던 메모리 등은 일부 남기게 되며 그것을 부모 프로세스가 처리해줌
		- 이때 부모 프로세스가 자식 프로세스 종료 처리를 제대로 하지 못하면 문제가 생김 
			- 고아 프로세스
				- 자식보다 부모프로세스가 먼저 종료되어 남겨진 프로세스
				- 고아 프로세스가 생기면 부모 프로세스를 init 프로세스로 변경해줘서 처리함
			- 좀비 프로세스
				- 운영체제쪽에서 자식프로세스가 종료되는 시그널을 부모프로세스에게 보내주었지만 부모프로세스는 다른 처리를 진행중이여서 자식프로세스 종료처리를 안하고 있는 상태
				- 자식 프로세스가 반쯤 종료된 상태로 계속 대기하게됨
				- 메모리를 차지하는 등 리눅스 내 여러 자원들을 차지하게 됨
		- 프로세스 종료 상태
			- 자식 프로세스가 종료될 때 부모 프로세스에게 종료 상태 정보를 넘겨줌
				- 정상 종료 여부(integer값으로 받으며 0이 성공 나머지 값은 실패)
				- 시그널 종류 및 시그널을 받아 종료여부
				- 코어 덤프 생성 여부
	- 표준스트림
		- 모든 프로세스가 가지고 있는 표준적인 스트림
			- 표준입력
			- 표준출력
			- 표준에러
			- ![[Pasted image 20240827193203.png]]
		- 프로세스들끼리 소통을 위한 입출력
	- 파일 디스크립터
		- 파일을 대변하는 객체
		- 파일에 대한 작업을 하기 위해선 파일 디스크립터를 열어야함
		- 파일디스크립터에 명령을 내려서 파일에 읽고 쓰는 작업을 함
		- ==프로세스별==로 열려있는 파일(스트림)에 대해 파일 디스크립터로 관리함
	- 포어그라운드 프로세스 vs 백그라운드 프로세스
		- 공통점
			- 표준 출력, 표준 에러는 쉘과 연결됨
		- 차이점
			- 쉘의표준입력이 연결 유무
			- 사용자의 입력이 필요에 따라 나뉨
			- 사용자입력을 받아 진행하는 스크립트의 경우 포어그라운드, 
			  사용자입력없이 반복적으로 실행되는 스크립트의 경우 백그라운드
	- 데몬 프로세스
		- 백그라운드 프로세스로 동작하기 위해 만들어진 프로세스
		- 표준 스트림을 갖지만 쉘과 입출력을 닫아버림
		- 부모 프로세스를 init 프로세스로 변경
	- 시그널
		- 비동기 이벤트를 처리하기 위한 프로세스간 통신![[Pasted image 20240827200949.png]]
			- SIGCHILD : 자식 프로세스가 종료되면 부모 프로세스에게 알리는 시그널
			- SIGTERM : 조건적으로 종료를 미룰 수있는 시그널
			- SIGKILL : 강제종료 시그널
	- 리디렉션
		- 
		- 추가 모드 출력 리디렉션
			- >>
				-  명령어 + >> + 대상 파일
				- 스트림을 대상 파일 끝에 저장
				- 대상 파일이 존재하지 않는 경우 생성 후 목령어 진행
		- 파일 디스크립터로 리디렉션
			- 명령어 + >& + 파일디스크립터
			- 표준 출력과 표준 에러를 한꺼번에 출력하고 싶을 때 사용됨
		- 표준 출력 및 표준 에러 동시 리디렉션
			- &> 대상 파일
			- 파일 디스크립터 리디렉션 문법 대신 편하게 쓸 수 있음
		- 입력 리디렉션
			- 명령어 + < + 대상 파일
			- 사용자의 입력을 기다리거나 필요한 툴에 대해 사용됨
			- 파일의 내용을 툴에게 전달
		- Here documents
			- 명령어 + << + DELIM 
			- ex.) ![[Pasted image 20240901154716.png]]
			- DELIM
				- 표준입력으로 멀티라인의 문자를 전달해줌
				- 직접 멀티라인으로 작성해줌![[Pasted image 20240901154649.png]]
	- 파이프라인
		-  (출력)명령어 + | + (입력)명령어 + ....
			- 앞의 프로세스의 표준 출력이 뒤 프로세스의 표준 입력으로 연결됨
		- 명령어 + |& + 명령어 + ....
			- 앞의 프로세스의 표준 출력과 표준 에러가 뒤 프로세스의 표준 입력으로 연결됨
		- 프로그램 간 상호작용
		- 프로세스의 표준스트림을 연결해줌
			- A프로세스의 표준출력과 B프로세스의 표준입력을 연결![[Pasted image 20240901155555.png]]
		- 중간에 파일을 만들지 않고 리디렉션해줌
		- 각각 명령어는 서브쉘에서 실행됨
		- 전체 파이프라인의 exit status는 마지막 실행 커맨드의 exit status임
			- 마지막 커맨드 성공상태만 취급함
			- pipefail 옵션이 설정되어 있다면 실패한 커맨드가 존재하면 실패로 처리
- VIM
	- 텍스트 기반의 에디터 툴
	- vim + 옵션 + 파일
	- ![[Pasted image 20240902201224.png]]
	- VIM은 모드가 존재![[Pasted image 20240902201253.png]]
		- Visual mode : 드래그를 통해 영역을 선택하여 동작하는 모드
	- 커맨드
		- i  
			- 입력모드로 전환
		- esc 
			- 노말모드로 전환
		- : + 숫자
			- 해당 숫자열로 이동
		- : + x
			- 저장하면서 vim 나옴
		- : + q
			- vim 나옴
		- : + q + !
			- 강제로 vim 나옴
		- : + e + 파일이름
			- 다른 파일로 vim 변경
		- 이동 커맨드![[Pasted image 20240902203746.png]]
			- f + 문자 
				- 해당 라인의 문자를 포함하는 단어로 이동 
			- { }
				- 문단단위로 이동
		- 편집 커맨드![[Pasted image 20240903204043.png]]
			- yy
				- 숫자 + yy 
				- 뒤 숫자줄 만큼 복사
			- s
				- 문자를 하나 지우면서 insert 모드
			- .
				- 마지막 행동 반복
		- 텍스트 검색 커맨드![[Pasted image 20240903211700.png]]
			- / + 단어 
				- 아래쪽으로 단어 검색 
			- ? + 단어
				- 위쪽으로 단어 검색
			- 단어 +\\ | + 단어
				- 여러 단어 검색
			- n
				- 단어 검색 후 n 클릭 시 해당 단어와 같은 단어를 정방향으로 검색
			- /\\\\<단어\\>
				- '단어' 단위로 검색
			-  #, *
				- 커서 위 키워드로 검색
		- 스트링 치환 커맨드![[Pasted image 20240904210545.png]]
			- :%s + / + 변경할 문자열 + / + 변경될 문자열
				- 단, 한 라인은 하나만 변경
			- :%s + / + 변경할 문자열 + / + 변경될 문자열 + / + c
				- 하나씩 문자열 변경
			- :%s + / + 변경할 문자열 + / + 변경될 문자열 + / + g
				- 한 라인에서 여러개 변경가능
			- 비주얼 블럭을 이용하여 변경할 수 있다
				- 비주얼 블럭으로 범위를 잡고 + : +s/ + 변경할 문자열 + / + 변경될 문자열
		- 정규식활용 ![[Pasted image 20240904212541.png]]
			- .
				- 모든 문자
				- ex.) /a.c  : a + 모든문자 + c
			- ^
				- 문자의 시작
				- ex.) ^abc : 문자 시작이 abc
			- $
				- 문자의 끝
				- ex.) ^abc : 문자 끝이 abc
			- *
				- 앞의 문자가 없거나 여러개이거나
				- ex.) /shm_.\*(.\*) : shm_ 에서 아무문자 여러개가 나올 수 있고 '(' 가 있는 문자열이면서 이후 또 여러 아무문자가 나올 수 있고 ')'가 있는 문자열을 찾음
			-  \\\\+
				- 앞의 문자가 하나이거나 여러개이거나
			- \\\\=
				- 앞의 문자가 없거나 하나이거나
		- 멀티 윈도우 커맨드![[Pasted image 20240905194511.png]]
			- :new
				- 분할하여 같은 파일 창을 띄움
			- :split
				- 분할하여 빈창을 띄움
		- 사용자 단축키 지정 커맨드
		- 모드마다 단축키를 설정함![[Pasted image 20240905202108.png]]
		- 단축키 지정 ![[Pasted image 20240905202229.png]]
			- :모드 단축키
				- + 키표현 + 입력 시 동작
				- ex. :imap + \<F8\> printf(); \<CR\> 
				  -> insert mode에서 F8을 누르면 print()출력
		- 기타 커맨드![[Pasted image 20240906173029.png]]
			- ctrl + P (insert mode일 때)
				- 자동완성
			- diff 모드
				- 파일끼리 내용 비교 가능
				- 비교하는 두 파일 모두 diffthis를 해주여야함
				- d + o 를통해 왼쪽 내용을 오른쪽에 복사
			- fold (불필요한 영역의 텍스트를 접는 기능)
				- zf
					- 폴더 생성
				- zd
					- 삭제
				- zo
					- 열기
				- zc
					- 닫기
			- 위치저장/이동
				- m + 알파벳
					- 위치마킹
				- ' + 알파벳
					- 마킹해둔 알파벳 위치로 이동
			- 들여쓰기
				- >> 또는 <<
				- 자동 들여쓰기
					- 영역 드래그 후  + ==
	- 플러그인![[Pasted image 20240906175850.png]]
		- 예전엔 계정마다 .vim/plugin 디렉토리를 만들어 .vim파일을 복사하여 적용
		- 플러그인 관리자
			- 요즘엔 플러그인 관리자를 통해 플러그인을 등록, 관리 
			- 대표 플러그인 관리자
				- vundle
				- pathogen
				- vim-plug
			- 
		- 원하는 플러그인 찾는 곳
			- http://vim.org
			- http://vimawesome.com

