1. 타임리프

- HTML을 동적으로 렌더링하는 용도로 사용
- 순수 HTML을 최대한 유지하는 특징
- 타임리프로 작성된 파일은 HTML마크업 결과가
  어떻게 되어있는지 파일만 보고 확인 가능
- 순수 HTML을 유지하면서 뷰 템플릿도 사용 할 수
   있는 것이 타임리프의 장점이며 '네츄럴 템플릿'이라고 한다.
- 스프링과 통합지원함.

2. 타임리프의 기본 기능

- 타임리프 사용 선언
-- <html xmlns:th="http://www.thymeleaf.org">

- 텍스트
-- th:text (ex. span th:text="${data}")

-- [[${data}]] >> 태그 안이 아닌 바깥에 출력하고 싶은 경우 

-- 이스케이프
--- HTML 엔티티
---- '<'의 경우 HTML에서 태그의 시작으로 인식한다
---- 그래서 해당 문자('<')를 문자 그대로 보여주는 것

--- 특수문자를 HTML 엔티티로 바꾸는 것이 이스케이프라고 함

--- 반대로 변환한느 것을 언이스케이프라고함

--- th:utext >> 이스케이프 기능을 끈 텍스트

--- [(${data})] >> 태그 안이 아닌 바깥에서 텍스트출력(언이스케이프) 

- 변수
-- ${data}

-- object
--- user.name
--- user['name']
--- user.getName()

-- List
--- list[0].name
--- list[0]['name']
--- list[0].getName()

-- Map
--- map['userA'].name
--- map['userA']['name']
--- map['userA'].getName()

-- 지역변수 선언
--- th: with="변수이름=${data}"


- 웹 기본 객체
-- ${#기본객체} 
ex. ${#request}, ${#session}, ${#response}
 (단, 스프링부트3.0부터는 기본객체를 지원하지 않음)
 (${#locale} 이건 지원함)

-- 편의 객체
--- ${param} >> http 요청 파리미터 편리 접근
  ex. param.파라미터  
--- ${session} >> 세션 편리 접근
  ex. session.담아둔값
--- ${@스프링빈.메서드} >> 스프링빈 접근
  ex. ${@helloBean.hello('')}

- 유틸 객체

-- 유틸 객체들 (앞에 ${}붙임)
#message: 메시지, 국제화 처리 
#uris: URI 이스케이프 지원 
#dates: java.util.Date 서식 지원 
#calendars: java.util.Calendar 서식 지원
 #temporals: 자바8 날짜 서식 지원
 #numbers: 숫자 서식 지원
 #strings: 문자 관련 편의 기능
 #objects: 객체 관련 기능 제공
 #bools: boolean 관련 기능 제공
 #arrays: 배열 관련 기능 제공
 #lists, #sets, #maps: 컬렉션 관련 기능 제공 
#ids: 아이디 처리 관련 기능 제공, 뒤에서 설명

- URL 링크
-- 절대경로 vs 상대경로
--- /경로 >> 절대경로
--- 경로 >> 상대경로

-- th:href="@{경로}"

-- 경로에 쿼리 파라미터 추가
   @{경로(param1=${param1}, param2=${param2})}
   @{경로?param1=${param1}&param2=${param2}}

-- 경로에 변수 두기
   @{경로1/{변수경로1}/{변수경로2}(변수경로1=${변수경로1}, 변수경로2=${변수경로2})}
   
-- 경로변수 + 쿼리파리미터
   @{경로1/{변수경로1}(변수경로1=${변수경로1}, 변수파람2=${변수파람2})}
    >> 경로/변수경로1?변수파람2=변수파람2 

-리터럴
-- 소스 코드상에서 고정된 값
ex. hello > 문자 리터럴
     10    > 숫자 리터럴

-- 리터럴 종류
--- 문자 , 숫자, 불린, null

-- 타임리프의 문자 리터럴은 항상 ''(작은다옴표)로 감싸야함!!
  ex. <span th:text="'hello'">
--- 공백없이 이어진다면 다옴표 생략 가능!!!
  ex. <span th:text="hello">
--- 만약 문자열에 공백이 들어간다면 생략 불가능
--- || 를 통해 리터럴 대체문법을 통하여 문자열로 치환시켜줌
  ex. <span th:text="|hello ${data}|">

- 연산

-- 비교연산자
---  >(gt), <(lt), >=(ge), <=(le), !(not), ==(eq), !=(neq, ne) 
  ("" 내에서 사용 가능)
--- gt 대신 &gt; 이렇게도 사용가능!

--- '?'를 통해 삼항연산자도 사용가능!

--- '?:'를 통해 있으면 해당 값을 없으면 :뒤에 값을 불러옴

--- '_'를 통해 해당 태그 타임리프를 무효화시킴(타임리프 태그 렌더링을 안함)

- 속성값 설정

-- th:속성 으로 속성을 지정하면 타임리프는 기존 속성을 지정한 속성으로 대체함
    (단, 기존 속성과 지정한 속성의 이름이 같을때)
    (지정한 속성이 없다면 새로 만든다)

-- 속성 추가  

--- th:attrappend >> 지정 속성 값 뒤에 값을 추가
   ex. th:attrappend="속성이름="' 값'"
--- th:attrprepend >> 지정 속성 값 앞에 값을 추가
--- th:classappend >> class속성에 자연스럽게 값 추가
   ex. th:classappend = "값"

-- 체크 값 처리

--- th:checked ="on/off"

- 반복

-- th:each="컬렉션변수 : ${컬렉션}"
-- th:each의 첫번째 변수는 컬렉션변수
                 두번째 변수는 반복상태값변수
                 로 지정됨
   ex. th:each="컬렉션변수, 반복상태값변수 : ${컬렉션}"  
   (굳이 반복상태값변수를 추가하지 않더라도 해당변수명 + Stat으로 자동으로 지정됨)

-- 반복상태값 변수의 프로퍼티
--- index: 0부터 시작하는 값 
--- count: 1부터 시작하는 값 
--- size: 전체 사이즈 
--- even, odd: 홀수, 짝수 여부(boolean) 
--- first, last:처음, 마지막 여부(boolean) 
--- current: 현재 객체

- 조건부(if)

-- th:if="조건" >> 해당 조건에 충족되면 태그 렌더링
   (단, 해당 조건에 충족되지않으면 해당 태그 자체가 나타나지 않음)
   ex. th:if="${user.age lt 20}"
-- th:unless="조건" >> 그 반대
-- th:switch="변수" >> 자바의 switch문 처럼 사용가능
    (case="*"인 경우 자바에서 default랑 같다)
ex.  <td th:switch="${user.age}">            
            <span th:case="10">10살</span>           
            <span th:case="20">20살</span>          
            <span th:case="*">기타</span>        
       </td> 	
     
- 블록
-- <th:block>
-- 타임리프 특성상 태그 안에 속성으로 기능을 정의해서 사용하는데
    굳이 새로운 태그를 만들지 않고 타임리프 속성만을 이용할 때가 있음
    그럴 때 사용된다 (each, if) 등등

- 자바스크립트 인라인
-- <script th:inline="javascript">
-- 변수 매핑 >> [[${변수}]]
--장점
--- 자바스크립트의 변수에 값을 넣어줄때 타입마다 자동적으로 맞춰줌
--- 주석처리되어 있는 값을 매핑해줌 (네츄럴 템플릿)
     (HTML을 안깨고 업무를 진행할 수 있음)
--- 객체를 넣어줄 때 자동으로 JSON형태로 넣어줌
     (기존에는 toString()으로 불러옴)

-- 인라인에서 each쓰기
--- [# th:each="컬렉션변수 : ${컬렉션}"]
        반복...
     [/]

- 템플릿 조각
-- 페이지 개발할 때 공통영역으로 재활용하는 경우가 있다
    그것을 조각으로 만들어놓고 간편하게 쓸 수 있음
-- th:fragment="조각변수"
    (템플릿 조각 선언)

-- <태그 th:insert="~{경로 :: 조각변수}"
    (해당 태그 안에 조각 삽입)

-- <태그 th:replace="~{경로 :: 조각변수}"
    (해당 태그를 조각을 대체)

-- th:fragment="조각변수 (파람1, 파람2)"
    (템플릿 조각 선언 및 파라미터 선언)

-- <태그 th:insert="~{경로 :: 조각변수 (파람1, 파람2)}"
    (해당 파람1,파람2가 넘어간 값의 조각을 렌더링)

-- 템플릿 레이아웃
--- 일부 코드 조각들을 레이아웃으로 넘김
--- <태그 th:insert="경로 :: 조각변수(~{::넣을 태그1}, ~{::넣을 태그2})
     (태그를 파라미터로 넣어 해당페이지에서 해당 태그를 넘겨 렌더링)
--- ${넣을 태그1} 
     (조각 템플릿에 해당 태그에 파라미터가 붙으면 넘어오는 값에 매핑됨)
   
- 입력 폼 처리
-- 타임리프가 제공하는 입력 폼
-- th:object="${오브젝트}" >> 빽단에서 들고오는 데이터 객체를 지정
--- *{...} >> th:object에 지정된 객체에 접근
      (${오브젝트.id}를 더 간단하게 *{id}로 가능)  
-- th:field="${데이터}" >> 해당 태그의 id,name,value속성을 자동으로 처리해줌
 
- 체크박스
-- 체크했으면 on이라는 값이 넘어감
   (스프링은 on 문자를 true타입으로 변환해줌)
   (기존 HTML 체크박스는 체크안하면 서버에 값 자체를 보내지 않음)
   (사용자가 의도적으로 체크를 해제시 아무것도 넘어가지 않음)
   (Spring의 경우 _on의 태그 네임을 가진 값만 전송된 경우 체크박스 값을 false로 변경함)

-- 체크박스에 th:field를 넣어주면 자동으로 히든 인풋 태그까지 만들어줌
-- 값이 true면 자동으로 checked 프로퍼티를 넣어줌

*** @ModelAttrinbute("이름")
    메서드단에 해당 어노테이션을 쓰면
    해당 메서드의 반환값을 자동으로 해당이름으로 모델에 담아줌

-- 멀티 체크박스

--- 동적 아이디 프로퍼티 생성
---- 루프문을 돌려서 id프로퍼티 값이 달라야할 경우
       루프문에 맞게 동적으로 id프로퍼티를 맞출 수 있는 기능이 있다.
---- #ids.prev('컬렉션') , #ids.next('컬렉션') 
---- th:for="${#ids.prev('regions')}"   

*** Enum
-- Enum클래스.values() >> Enum에 등록된 데이터 배열형태로 가져옴
-- Enum데이터.name() >> 해당Enum데이터의 이름을 가져옴(String타입)
-- 타임리프는 Enum에 직접 접근가능하다 
    (Enum 메서드 사용 가능)

- 라디오버튼
-- 체크박스와 같지만 hidden인풋은 들어가지 않음
    (무조건 한개는 선택이 되기 때문)

3. 메시지
- 다양한 하드코딩 값을 한곳에서 관리하는 것
- .properties파일에 key, value값을 둠
- 언어적용도 가능 (http헤더의 accept-language를 이용)
- 스프링에서도 기본적으로 제공함 
- 메시지 소스 세팅
-- application.properties 파일에 
     spring.messages.basename=messages  

-- 소스 세팅 시 스프링에서는 자동으로 빈으로 등록됨
 
-- basename에 맞는 메세지 properties파일을 만들어준다

- 메시지 사용
-- MessageSource 객체를 사용
-- MessageSource 객체.getMassage(code, 매개변수, 기본 메세지, Locale.getDefault())
-- 매개변수를 사용할 시 프로퍼티 파일에 key 값에 매개변수가 있어야하며
    ex. {0}, 해당 매개변수를 사용할 때 매개변수에 new Object[]{"메세지값"}을 넣어줌
    그렇게 하면 해당 value + 메세지값 으로 메세지를 보여줌
-- locale을 지정해주면 언어에 맞는 프로퍼티 파일을 읽어서 메시지를 보여줌
  ex. MessageSource 객체.getMassage(code, 매개변수, 기본 메세지, Locale.KOREA)
-- locale이 null일 경우 시스템 기본 locale을 불러와 ko_KR이므로 message_ko.properties를 불러옴

- 타임리프에서 메시지 사용
-- th:text=#{프로퍼티key값}
-- th:text=#{프로퍼티key값(${프로퍼티 key값})}
   (매개변수 사용법)

4. 검증

- BindingResult
-- 스프링에서 지원하는 검증오류 보관 객체

-- 타입바인딩오류, 비즈니스로직오류를 보관

-- 사용법
--- BindingResult객체.addError()
    (에러값을 추가)
--- BindingResult객체.addError(new FieldError("오브젝트이름", "필드이름", "오류 메시지")
    (에러값을 추가하고 해당 필드에 오류메시지 추가)
--- BindingResult객체.addError(new ObjectError("오브젝트이름", "오류 메시지")
    (에러값을 추가하고 전역에 오류메시지 추가)
--- BindingResult객체.hasErrors()
    (바인딩 객체가 에러값을 가지고 있는 경우 true)

-- 타임리프 사용법 
--- ${#fields.hasGlobalErrors()}
     (전역 오류가 있으면 true) 
--- ${#fields.globalErrors()}  
     (전역 오류 모두 꺼냄, list형식) 
     (th:each로 처리)
--- th:errors="*{필드이름}"
     (해당하는 필드이름의 에러값이 있는 경우 해당 태그를 에러값 보여줌)
     (th:if 의 편의 버젼)

-- BindingResult 객체는 자동적으로 Model에 담김 

-- 메서드 파라미터에 넣을 시 @ModelAttribute 객체 다음으로 와야함
   (순서가 중요함, 해당 객체의 바인딩된 값을 담기 때문에)
-- @ModelAttribute 바인딩 타입 오류가 발생해도 bindingResult객체가 있다면
    컨트롤러가 정상 호출된다.  (오류정보를 BindingResult에 담음) 
    (400 에러코드를 뱉지 않음)

-- FieldError
--- 생성자가 두가지로 나뉨
---- new FieldError(객체이름, 필드, 오류메시지)
---- new FieldError(객체이름, 필드, 거절된값, 바인드실패인지검증실패인지 구분값, 메세지코드, 메세지파라미터, 오류메시지)
                                               rejectedValue bindingFailure(true,false)             codes          arguments 

---- application.properties에 errors를 추가하여 error에 대한 프로퍼티파일을 따로 만들어서 사용할 수 있다.
      FieldError의 인자로 codes의 경우 errors.properties의 key값을 넣어주면 해당하는 value의 메세지값이 매핑됨
      (단, new String[]로 인자를 넣어야함)
      (배열로 받는 이유는 첫번째 key값을 못찾을 경우 두번째key로 찾음) 
      value값에 파라미터를 남긴경우 FieldError의 arguments인자에 new Object[]를 넣어줌
     ex.  FieldError(객체이름, 필드, 거절된값, 바인드실패유무, new String[]{"requir.item"}, new Object[]{"상품", "확인"}
      
-- ObjectError
--- FieldError처럼 유사한 생성자 두가지를 지원함 

-- rejectValue(), reject()
--- 굳이 FieldError, ObjectError를 사용하지 않고 간단하게 오류 구현 가능

--- 프로퍼티 key값을 넣을 때 축약된 값을 넣음
     ex. required.item.itemName -> required
     만약 required.item.itemName key와 required key 둘다 있으면??
      -> 자세할수록 우선순위로 잡음!!
     (이렇게 함으로 프로퍼티파일만 수정하여 오류메시지를 관리 가능하다)
---- 축약이 가능한 이유
      스프링이 지원해줌!! (MessageCodesReslover)
      rejectValue()를 쓸때 MessageCodesReslover를 호출하여 오류코드에 해당되는
      모든 메세지오류코드(key)를 불러온다음 우선순위를 메겨 rejectValue에 반환해줌
----- 메시지생성 규칙(우선순위)
------ 객체의 경우
      1. code + . + 오브젝트이름
      2. code
------ 필드의 경우
      1.code + . + 오브젝트이름 + . + 필드이름
      2.code + . + 필드이름
      3.code + . + 필드 데이터 타입
      4.code

--- 사용법
---- bindingResult.rejectvalue(필드이름, 축약된 에러 프로퍼티 key값, 파라미터값, 디폴트메세지) -- 필드
---- bindingResult.reject(축약된 에러 프로퍼티 key값, 파라미터값, 디폴트메세지) -- 전역

--- type에러의 경우 Spring에서 지원해주는 문구가 뜨는데
     해당 문구도 커스터마이징 가능!
     typeMismatch에 대한 값들을 에러 프로퍼티에 추가시켜줌

-- ValidationUtils
--- if문 쓸 필요도 없이 한줄만으로 간단하게 bindingResult를 써서 표현가능
     ex. ValidationUtils.rejectIfEmptyOrWhitespace(bindingResult, 필드, 에러 프로퍼티 key값)


- 오류코드 관리 전략
-- 핵심!! 구체적인 것에서 덜 구체적인 것으로!!
   정말 중요한 메세지는 구체적으로 구성
   별로 중요하지 않는 범용성이 넓은 메세지는 덜 구체적으로 구성

- Validator
-- Spring에서 지원하는 인터페이스이며 검증에 대한 로직을
    따로 작성하여 관리할 수 있음!

-- 빈으로 등록하고 해당 컨트롤러단에
    validator.validate(item, bindingResult)를 해주면 끝

-- 단위마다 검증할 구현체를 만들면 됨!

-- WebDataBinder를 사용하여 validator.validate()를 쓰지 않아도
    자동으로 컨트롤러를 불러올 때마다 검증이 가능하다
    메서드단에 @InitBinder를 넣고 WebDataBinder를 매개변수로 가지는 메서드를 만든다
    그리고 해당 WebDataBinder객체의 addValidators(구현체)를 통해
    만든 검증구현체를 넣어줌
    그리고 @ModelAttribute앞에 @Validated를 넣어주면 끝
    (@Validated는 검증을 실행하라는 어노테이션)
    예시)
    public void init(WebDataBinder dataBinder) {
        dataBinder.addValidators(itemValidator);
    }

-- 한 컨트롤러에 여러 검증 구현체가 있다면
    Validator 인터페이스의 support를 통해 구분된다

-- 글로벌하게 검증기를 넣을 수 있음 (모든 컨트롤러에 해당 검증 적용)
    @SpringBootApplication이 적용된 클래스에
    WebMvcConfogurer 인터페이스를 구현받고
    해당 인터페이스의 getValidator()를 추가하여
    리턴값으로 해당하는 Validator 구현체를 넣어주면 된다.

5. Bean Validation

- VO의 필드 값에 @NotNull 등으로 어노테이션을 넣어
  따로 검증 로직을 넣을 필요없이 어노테이션만으로 간단하게 검증이 가능하다

- implementation 'org.springframework.boot:spring-boot-starter-validation'를 gradle에
  추가해야함
-- 해당 라이브러리를 넣으면 자동으로 BeanValidator를 넣고 스프링과 통합한다.
    그리고 글로벌 Validator로 등록하고 어노테이션을 보고 검증을 수행
    (단, 메서드단에 @Validated 필수)
    이후 검증 오류가 발생하면 FieldError, ObjectError를 생성하여 BindingResult에 자동으로 담아줌
   
- @ModelAttribute를 통해 바인딩에 성공한 필드만 Bean Validation이 적용됨


- 어노테이션 종류
-- @NotBlank: 빈값 + 공백만 있는 경우를 허용하지 않는다. 
-- @NotNull: null을 허용하지 않는다. 
-- @Range(min = 1000, max = 1000000): 범위 안의 값이어야 한다. 
-- @Max(9999): 최대 9999까지만 허용한다.

- 사용법

--필드 값의 경우

--- VO필드값에 위에 해당하는 어노테이션을 추가함 

--- 메세지를 커스텀해줄 때 두가지방법 존재 (우선순위) 
1. 에러 프로퍼티에 해당하는 에러코드에 맞는 key값을 추가
   ex. @NotBlank 의경우 NotBlank.item.itemName = 공백 불가능
   파라미터가 들어갈 경우 {0} 은 필드명이며 그 이후는 애너테이션마다 다름
2. 에노테이션(message="")를 통해 메세지 커스텀

-- 오브젝트의 경우

--- 클래스 영역에 @ScriptAssert(lang="javascript", script="조건", message="메세지")
    를 추가해줌
     (하지만 한계가 많음 실무에서 다른 객체끼리 묶어서 사용하는 경우도 있는데
      그런경우 대응하기 힘듬)
--- 보통 실무에서는 오브젝트 오류의 경우 직접 코드로 등록함
     (bindingResult.reject()를 이용

- 한계점
- 한 VO에 대해 조건에 따라 검증 어노테이션이 달라질 경우 대응 할 수 없다.

- 극복방법
-- groups 기능 사용
--- 그룹을 나누어 그룹마다 검증방법을 다르게 적용할 수 있다.

--- 단, 복잡해서 잘 안씀

--- 사용법
---- 마킹을 위한 인터페이스 생성 
---- VO클래스의 필드에 적용된 검증 어노테이션에 
      @어노테이션(groups = {마킹인터페이스})로 그룹을 나눔
---- 컨트롤러단 메서드에서 @Validated에서 @Validated(마킹인터페이스.class)를 추가
      
-- 등록, 수정 등 로직마다 검증을 위한 별도 폼 객체를 사용

--- 각각 로직에 맞는 별도 폼 객체를 만들고 VO객체랑 필드를 맞추고 validation어노테이션만 다르게 설정
     컨트롤러 메서드에 @ModelAttribute에 만들어준 별도 폼 객체를 넣어줌
     (@ModelAttribute이름을 그대로 두고 싶다면 @ModelAttribute("기존 모델")로 지정해줌)
     그리고 save, edit 등 값을 넣을 땐 VO를 생성하여 별도 폼 객체에 담긴 값을 넣어줌

- HTTP 메세지 검증

--  컨트롤러 메세지 파라미터안에 @RequestBody 뒤에 @Validated를 넣어줌
    (해당 메세지바디 객체 뒤에 BindingResult객체도 넣어줌)

-- 하지만 메세지컨버터에서 요청 JSON을 객체로 못만든 경우에는 컨트롤러에 들어올 때 컨트롤러 호출이 중단됨
    (@RequestBody의 경우 @ModelAttribute와 다르게 각각 필드 단위가 아니라 전체 객체 단위로 적용되기 때문에
     메세지컨버터가 작동이 성공해서 객체가 만들어져야 @Validated가 적용됨)
     

- 쿠키

-- 영속쿠키 >> 만료 날짜를 입력하면 해당날짜까지 유지
-- 세션쿠키 >> 만료 날짜를 생략하면 브랑줘 종료시 까지만 유지

-- 쿠키의 심각한 보안 문제

--- 쿠키 값은 임의로 변경가능
---- 클라이언트가 쿠키를 강제로 변경하면 다른 사용자가 됨

--- 쿠키에 보관된 정보는 훔쳐갈 수 있다.
---- 악성 어플리케이션을 통해 브라우저에 보관된 쿠키값을 가져갈 수 있음
---- 훔쳐간 쿠키값은 평생 사용 가능하게 할 수 있다.

--쿠키 보안
--- 예측 불가능한 임의 토큰 값을 노출하고 서버에서 토큰과 사용자 id를 매핑하여 인식
--- 토큰 만료 시간을 짧게 정하여 토큰을 털어가도 시간이 지나면 사용할 수 없게함

-세션

-- 세션 동작 방식
  1. 로그인 로직이 성공하면 쿠키를 만들고 추정이 불가능한
     토큰값을 쿠키에 넣어주고 클라이언트에게 보냄
  2. 그리고 해당 세션토큰과 로그인정보를 세션저장소에 저장
  3. 클라이언트는 매번 요청 시 항상 해당 세션토큰이 담긴 쿠키를 전송
  4. 서버에 요청이 왔을 때 해당 쿠키의 세션토큰 값을 세선 져장소에서 조회하여
     로그인 시 보관한 세션정보를 사용

-- 결국 쿠키를 이용하여 서버에 쿠키저장소를 따로 만들어서 관리하는 것

-- HTTP서블릿 세션

--- 서블릿에서 지원하는 세션 기능

--- 쿠키 이름은 JSESSIONID으로 만들어진다.

--- request.getSession(true/false)
     (default는 true)
     (true일 때 세션이 있으면 해당 세션 반환 없으면 새로 생성)
     (false일 때 세션이 있으면 해당 세션 반환 없으면 null 반환)

-- @SessionAttribute

--- @SessionAttribute(name = "들고올 세션이름", required = "생성여부") Value객체 

--- 더 간단하게 세션을 들고올 수 있음

--- trackingModes
---- 만약에 웹 브라우저가 쿠키를 지원하지 않을 때
       URL로 쿠키값을 유지하는 방법이다
---- application.properties 파일에
      server.servlet.session.tracking-modes=cookie
      을 추가해주면 URL전달 방식을 끌 수 있다.

--- 세션 정보

---- maxInactiveInterval: 세션의 유효 시간, 
      예) 1800초, (30분) 
---- creationTime: 세션 생성일시 
---- lastAccessedTime : 세션과 연결된 사용자가 
      최근에 서버에 접근한 시간, 클라이언트에서 서버로 
       sessionId(JSESSIONID)를 요청한 경우에 갱신된다. 
---- isNew: 새로 생성된 세션인지, 아니면 이미 과거에 만들어졌고, 
      클라이언트에서 서버로 sessionId(JSESSIONID)를 요청해서 조회된 세션인지 여부

--- 세션 종료 시점 

---- 세션 생성 시점에서의 시간이 아니라 마지막 요청으로 부터의 
      시간을 기준으로 유효시간을 잰다

----세션 종료시점(타임아웃) 설정 
-----  글로벌 설정 : application.properties 파일에
             server.servlet.session.timeout=초   추가
             (단, 60보다 작은 값은 불가능)
----- 특정 세션 설정 : session.setMaxInactiveInterval(초); 

6. 필터
- 여러 로직에서 공통으로 필요한 로직을 처리해줌
 ex.특정 URL로 오는것을 막거나 여러로직에서 로그인 여부에 따른 리다이렉트 처리

- 공통 관심사 처리 (AOP랑 비슷함)
- 하지만 수많은 부가기능이 존재

- 필터의 흐름
-- HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러

- 필터 제한
--  HTTP 요청 -> WAS -> 필터(적절하지 않은 요청이라 판단하면 서블릿 호출x)
   ex. 로그인 여부

- 필터 체인
-- HTTP 요청 -> WAS -> 필터 -> 필터2 -> 필터3 -> 서블릿 -> 컨트롤러

- 필터를 구현하고 등록하면 서블릿 컨테이너가 자동으로 필터를 싱글톤으로 생성

- 필터 인터페이스

-- 필터 인터페이스를 통해 연결된 모든 필터를 거치고
  필터가 없으면 서블릿이 호출됨
-- 필터 인터페이스
--- init() >> 필터 초기화 메서드, 서블릿 컨테이너가 생성될때 호출됨
--- doFilter() >> 고객의 요청이 올 떄마다 해당 메서드 호출, 필터 로직 구현하는 곳
--- destroy() >> 필터 종료 메서드, 서블릿 컨테이너가 종료될 때 호출됨

- 사용법
-- 필터를 사용하려면 필터 인터페이스를 구현받아야함
-- doFilter()에 원하는 로직을 추가
   (doFilter()의 ServletRequest는 HTTP요청이 아닌 경우까지 고려해서 만든 인터페이스이므로
    HTTP요청이라면 다운 케스팅을 통해 HTTPServletRequest로 변경해줌
--  doFilter()메서드의 FilterChain이라는 객체를 통해 다음 필터로 이어주거나 없으면
    서블릿을 호출함
    (로직에 FilterChain을 쓰지 않으면 다음 단계로 진행이 안됨)

- 등록방법
-- @Configuration 클래스에 FilterRegistrationBean을 빈으로 등록
-- FilterRegistrationBean.setFilter(원하는 필터)를 통해 필터 지정
-- FilterRegistrationBean.setOrder(숫자)해당 필터의 순서 지정
-- filterRegistrationBean.addUrlPatterns(URL) 필터를 적용할 URL패턴 지정
    (한번에 여러 패턴 지정 가능하며 모든URL에 적용할 땐 /* )
 


