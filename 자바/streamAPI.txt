1. 스트림

주의점
>> 한번 최종 연산한 스트림은 다시 재사용할 수 없음
     (즉, 다시 쓰려면 스트림을 생성해야하며 스트림 연산 중
      최종연산에서 스트림을 소비하여 결과를 도출하기에 
      최종연산 이후 스트림을 재사용하여 연산할 실행할 경우
      에러가 떨어짐)

구성
> 생성
>>데이터 소스를 스트림으로 변환하는 단계
>> 컬렉션으로부터 스트림 생성 : list.stream()
>> 배열로부터 스트림 생성 : Arrays.Stream(array)
>> 숫자 범위로부터 스트림 생성: IntStream.range(범위, 범위)
>> 일련의 값으로부터 스트림 생성 : Stream.of("a","b","c")
>> 파일로부터 스트림 생성 : Files.lines(Paths.get("file.txt"))
>> 함수로 무한 스트림 생성 : Stream.iterate(0,n -> n+2)
                                         Stream.generate(Math::random)

> 중간 연산
>> 최종 연산을 실행하기 전까지 어떠한 연산도 수행안함 -> 연산최적화 효과
      (지연연산 (Lazy evaluation)

>> 연산 종류
>>> 루트 퓨전 : 하나의 단일 루프에서 처리하는 처럼 병합됨
       ex. filter()와 map이 체이닝되어 있다면 
           두개가 병합되어 하나의 루프에서 처리하는 것처럼 사용됨
>>> 쇼트 서킷 : 결과가 확실한 경우 나머지 연산을 수행안함
       ex. limit()

>>> filter().map().limit()이 연결되어 있다면 원소가 filter되어 조건이 만족하면 map으로 연결되고
       그리고 limit을 수행하지만 limit의 조건이 충족되면 그 뒤의 filter,map은 모두 수행하지 않음

> 최종 연산
>> 스트림 요소를 소비하여 파이프라인을 실행하고 결과 도출

>>종류
>>> collect, reduce, forEach 등이 최종연산
>>> allMatch, noneMatch, findFirst, findAny 등이 최종연산이자 소트 서킷 기법이 들어감      

장점
> 병렬처리에 유리함
>> 기존 대량의 데이터들이 들어올 경우 병렬로 나누어 처리하는게 속도 상 좋다.
     하지만 기존 for문으로 병렬처리를 하려면 코드가 복잡해지고
     일일히 다 구간을 나누고 쓰레드를 도입하여 병렬처리를 해야한다.
     하지만 스트림의 parallelStream()을 통해 직접 병렬처리 코드를 짤 필요없이
     간단하게 병렬처리하여 데이터들을 처리할 수 있다.

성능
> 배열과 비교하면 성능이 많이 떨어지지만 (최적화의 차이도 존재)
   리스트와 비교하면 성능이 나쁘지 않다.(리스트는 원소들을 Wrapper클래스로 생성하기 때문)
   (대체적으로 성능이 나쁜 이유는 스트림객체를 생성하면서 부하가 생김)

> 하지만 오늘날 하드웨어성능이 뛰어나기에 크게 상관없는 부분이다.

스트림을 적용하기 좋은 조건
> 원소들을 실관되게 변환
> 원소들을 필터링
> 원소들을 하나의 연산을 사용해 결합
> 원소들을 컬렉션에 모음
> 원소들 중에 특정 조건을 만족하는 원소를 찾음
