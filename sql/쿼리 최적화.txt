1. 성능 이슈 SQL 패턴
- 비표준 구문 사용(JOIN)
- Search Argument 위반
- 불필요한 I/O 유발 (같은 테이블 조인)
- 불필요한 임시테이블, 변수
- 불필요한 Cursor/Loop 사용
- 부적절한 함수/뷰 사용
- 부적합한 프로시저 내부 코드 구성
- 부적절한 만능 조회

2. 인덱스 사용 여부 판단
- SSMS
-- 실행계획에서 인덱스 검색, index seek 라는 값을 통해 
  인덱스를 사용중 인것을 알 수 있음
-- 실행계획에서 인덱스 스캔, index Scan, 테이블 스캔 이라는 값을 통해 
  인덱스를 정상적으로 사용 불가능한 것을 확인 할 수있음

- mySql, MariaDb
-- 실행계획의 type이 const(single row), range(index range scan), ref(Non-Unique.....) 이면 인덱스가 사용되고 있는 것을 확인 가능
-- 실행계획의 type이 ALL이면 인덱스를 정상적으로 사용 불가능한 것을 확인 가능

3. ANSI ISO 표준 사용하기
- ANSI ISO 표준은 성능과 유지관리에 영향을 미침
- ISO 표준이 아닌 예시
-- JOIN을 사용하지 않고 FROM에 테이블 두개를 쓰는 경우
-- WITH ROLLUP을 쓰는 경우

4. WHERE, JOIN 절 작성 순서
- WHERE, JOIN 절 조건의 순서는 쿼리 성능과 별로 연관이 없다.
  왜?? Query Optimizer가 교환법칙, 결합법칙에 근거하여
  쿼리 실행 시 자동으로 WHERE, JOIN 절 조건 순서를 지정해줌.
  따라서 개발자는 유지관리 측면에서 WHERE, JOIN절 순서를
  생각해볼 필요가 있음
  ex.
  (10/ a > 0) AND (a <> 0)
  (a <> 0) AND (10/ a > 0) 
  첫번째조건에서는 실행 시 0나누기 오류가 떠야하지만
  Query Optimizer가 자동으로 조건 순서를 맞추어 오류가 뜨지 않음

- 주의 사항 
-- 교환법칙, 결합법칙의 대전제는 순서를 바꿔도 결과 값이 동일하다는 점이다.
   즉, JOIN의 경우 LEFT JOIN, OUTER JOIN은 순서에 영향을 받기에
   Optimizer의 교환법칙, 결합법칙이 성립되지 않음
   (INNER JOIN만 가능)

5. 스키마 이름 지정
- 쿼리에서 테이블을 쓸때 스키마 이름을 지정하면
  성능을 올릴 수 있다.
- 테이블 이름을 해석할 때 스키마에서의 객체를 확인하여 해석하는데
  스키마 생략 시 해당 테이블의 ID를 사용하여 해석하게 되면서
  불필요한 코드를 사용하게 됨. (작은 부하를 일으킴)
- 테이블 앞에 스키마를 붙이는게 성능, 유지관리, 보안 측면에서 좋음

6. 날짜시간 상수 값 
- DATE타입을 사용할 경우 ms까지 표현할때
  소수점 3자리까지 표현이 되며 .999가 되면 1로 넘어감
  BETWEEN을 사용할 경우 ms .997까지 로 표현하는 것이 좋다.
  
- 검색 시 후행 공백을 제거하기 위해 RTRIM을 사용하는데
  후행공백이 있든 없든 비교연산을 할 때는 RTRIM을 쓸 필요가 없이
  그냥 써도 검색이 가능하다. (불필요하게 RTRIM을 쓸필요가 없다)

7. 조인 조건, 검색조건 구분 (조건을 어떻게 구분해서 쓰는게 좋은지에 대해)
- 결과적으로 의미에 맞게 조건을 넣는 것이 좋다.
   (Query Optimizer가 쿼리를 재조정 해주기 때문)

- OUTER JOIN의 경우 해당 조건을 조인조건에 넣냐, 검색조건에 넣냐에 따라
  의미가 달라져버리기 때문에 의미를 잘 파악해야함

8. 의미 오류
- 프라이머리 키에 IS NULL을 쓰는 경우 불필요한 조건이다

- 수량이 0보다 크다는 제약조건이 걸려있지만 검색조건에 0보다 작게 설정하는 경우 불필요한 조건이다 

- a > 4 or a > 2 이러한 조건의 경우  불필요한 조건을 사용중이다

- DISTINCT를 사용할 때 프라이머리키가 있거나 중복될 수 없는 값을 조회하는 경우 구문이 불필요하다

- LIKE에 %가 없는 경우 불필요한 조건임

- EXISTS SELECT절을 사용하는 경우 DISTINCT는 불필요한 조건임
  (EXISTS에 대한 공부 필요)

- ORDER BY 에 불필요한 컬럼은 빼는 것이 좋다.

- HAVING을 사용할 경우 GROUP BY한 결과에 대한 조건을 거는 것이기 떄문에
  해당 조건이 WHERE절에 들어가야할 지 HAVING에 들어가야할 지 생각해 볼 필요가 있다.
   
- UNION은 중복원소를 제거하는 집합 연산에 해당하는데 중복된 데이터가 없는 경우 쓸필요가 없다.
  ex. SELECT ..... WHERE ORDER_ID < 1025
      UNION 
      SELECT ..... WHERE ORDER_ID > 1107

- INNER 조인으로 쓸 수 있는 OUTER 조인들은 INNER JOIN을 해줘야함

- 