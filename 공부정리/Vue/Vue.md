- MVVM패턴의 뷰모델 레이어에 해당하는 화면단 라이브러리
  ![[Pasted image 20240321215026.png]]
	- 페이지를 클릭하여 이벤트가 발생할 경우 DOM Listeners가 캐치하여 자바스크립트의 데이터를 변경하거나 로직을 일으킴
	- 자바스크립트의 데이터가 변경하였을 경우 Data Bindings를 통해 화면에 반영함
- VUE의 핵심
	- 데이터의 변화를 라이브러리에서 감지하여 자동으로 화면에 그려줌 (데이터 바인딩)
- 인스턴스
	- new Vue();
	- Vue에서 제공하는 API 속성들
	- 속성의 el을 통해 태그에 접근할 수 있다.
	  ![[Pasted image 20240325201638.png]]
	- Vue 인스턴스를 만드는 이유
		- 생성자 함수![[Pasted image 20240325201840.png]]
			- 해당 함수를 통해 객체를 만듬
		- 생성자 함수를 통해 매번 함수를 정의하는 것이 아니라 미리 정의된 함수를 사용할 수 있음 
		- Vue에서 vue 생성자 함수를 통해 vue에 정의된 속성들과 함수들을 재사용할 수 있음
		- Vue의 생성자 매개변수는 '객체'형태로 들어감
	- 재사용 가능한 옵션 속성
		- el, template, data, methods, created, watch 등등
		- key - value 형식을 가짐
- 컴포넌트
	- 화면의 영역을 구분하여 개발하는 것
	- 재사용성이 올라감!
	- Vue 인스턴스를 생성하면 해당 컴포넌트는 루트 컴포넌트가 된다
	- 전역으로 Vue에 컴포넌트 등록
		- Vue.component('컴포넌트이름', 컴포넌트 내용)
		- ![[Pasted image 20240325203117.png]]
	- 지역으로 Vue에 컴포넌트 등록
		- Vue의 components 속성에 key - value형태로 넣어줌
		- ![[Pasted image 20240325203639.png]]
	- 지역 vs 전역 컨포넌트
		- 전역 :
			- 플러그인이나 라이브러리를 사용할 때 쓰임
			- 인스턴스를 생성하지 않아도 기본적으로 가지고 있게됨
		- 지역 : 커스텀한 컴포넌트를 만들 때 주로 쓰임
			- 인스턴스마다 생성하고 해당 인스턴스에서만  쓰임
	- 컴포넌트 통신
		- 각각의 컴포넌트는 데이터를 각각 관리하며 컴포넌트 간 데이터를 주고 받기 위해서는 통신방식이 필요
		- 데이터(Props)는 내려보내고 이벤트(Emit)는 올려보내는 방식
		- 컴포넌트 통식방식을 통해 데이터의 흐름을 추적하여 디버깅이 가능해진다.
			- 이전 n방향 통신은 데이터 추적이 어려워 디버깅이 힘들었음
		- Props
			- 상위 컴포넌트에서 하위 컴포넌트로 데이터 전달
			- 하위 컴포넌트에 v-bind: 프롭스속성이름="상위 컴포넌트 데이터이름"
			- ![[Pasted image 20240325205609.png]]
			- props 속성은 선언 방식이 2가지이다
				- props 이름만 선언
				- props 받은 값들에 대한 타입, 필수값 유효성 체크
				- 예시![[Pasted image 20240420120156.png]]![[Pasted image 20240420120220.png]]
				-  
		- Emit
			- 하위 컴포넌트에서 상위컴포넌트로 이벤트를 올림
			- ![[Pasted image 20240325212023.png]]
			- 메서드를 선언하지 않고 바로 사용가능![[Pasted image 20240420120336.png]]
			- v-on:'이벤트이름'을 통해 해당 이벤트 시 함수를 실행 시키고 해당 함수에서this.$emit(이벤트이름, 값)을 통해 상위 컴포넌트로 이벤트, 값을 전달한다. 상위 컴포넌트에서는 해당 이벤트가 발생했을 때의 상위 컴포넌트 함수를 실행 시킬 수 있음 (함수 파라미터로 값이 들어감)
				- v-on은 @로 줄여쓸 수 있음(CLI 한정)
		- 같은 레벨 통신방법
			- emit으로 값을 상위 컴포넌트로 옮기고 그 값을 props를 통해 다른 컴포넌트로 내림![[Pasted image 20240326212702.png]]
	- this
		- 해당 객체를 가르킴
	- modal 컴포넌트
		- 메세지 띄우는 컴포넌트
		- vue에서 제공함
	- slot 컴포넌트
		- 특정 컴포넌트의 일부 UI를 재사용할 수 있는 기능
		- 해당 컴포넌트 내부 
		  ![[Pasted image 20240331105623.png]]
		  해당 컨포넌트가 쓰이는 부분
		  ![[Pasted image 20240331105747.png]]
		- slot태그를 통해 해당 컴포넌트를 쓰는 곳에서 slot태그 부분을 그 쓰이는 곳에 맞게 커스텀하여 적용할 수 있음
	- 트랜지션
		- 컴포넌트에 애니메이션을 추가할 수 있음
		- vue 트랜지션 참고
		- 트랜지션 css 예시![[Pasted image 20240331111457.png]]
- 뷰 라우터
	- 라이브러리이다. (설치가 필요)
	- 페이지 간 이동을 구현할 때 쓰임
	- new VueRouter({}); 로 인스턴스 생성
	- Vue 인스턴트에 연결
		- router의 경우 Vue인스턴스에 router 속성이 존재
		- ![[Pasted image 20240326213110.png]]
	- VueRouter 속성
		- mode 
			-  'history'로 지정하여 url에 '#'이 붙는 것을 없애줌
		- routes
			- 페이지의 라우팅 정보가 들어감
			- 어떤 URL로 들어갔을 때 어떤 페이지가 나올지 지정
			-  객체형태의 배열로 선언
				- path : '/login'
					- 페이지 URL
				- component : 'loginCompo'
					- 해당 url에서 표시될 컴포넌트
				- meta : {}
					- 라우터에 부가정보를 부여할 수 있는 속성
					- 라우터 네비게이션 가드와 활용하여 쓸 수 있음![[Pasted image 20240427135024.png]]
				- ![[Pasted image 20240326213625.png]]
	- router-view
		- 해당 태그를 통해 route속성에 지정해준 path의 url로 들어갈 경우 path에 지정한 컴포넌트들을 보여줌 
		- ![[Pasted image 20240326214315.png]]
	- router-link
		- 해당 태그를 통해 사용자를 위해 링크로 이동할 때 path를 지정해주면 해당 path로 이동해줌
		- 링크 태그와 비슷
		- ![[Pasted image 20240326214429.png]]
	- 동적 라우터 매칭
		- 페이지를 불러올 때 이전 페이지에서 데이터를 넘길 때 사용
		- 사용법
			- 라우터에 등록할때 ':값'을 넣어줌![[Pasted image 20240414151928.png]]
			- 그리고 이동하려는 페이지에 넘기려는 값을 넣어줌 ![[Pasted image 20240414151952.png]]
	- 코드 스플리팅
		- 웹에 들어왔을 때 SPA 특성상 모든 화면을 한번에 로딩한다. 코드 스플리팅은 URL로 이동 시 필요한 페이지만 들고오게 하는 기술이다. (나머지 화면들을 들고 올 필요가 없으므로 초기 화면 로딩속도가 빨라짐)
		- 사용법
			- component 속성에 import를 추가![[Pasted image 20240422211003.png]]
	- 라우트 폴백
		- 라우터가 존재하지 않는 URL로 접근했을 때 처리
		- path 속성에 '＊'을 준다. (코드에 등록한 URL을 제외한 나머지 URL로 들어오는 값들을 라우팅한다는 뜻)
		- 예시![[Pasted image 20240422211653.png]]
	- 프로그래매틱 라우팅
		- this.$router.push(URL) 
		- router-link to="" 의 태그와 같은 의미를 자바스크립트 레벨에서 사용할 수 있는 구문
	- 배포 시 주의점
		- 만약 mode에서 history로 설정하였을 경우 웹서버에 올릴 때 설정을 해주어야함 (해당 페이지 참고)
			- https://router.vuejs.org/guide/essentials/history-mode.html
- HTTP 통신 라이브러리
	- Ajax 기법
		- 비동기적인 웹제작을 위한 개발 기법
	-  axios (액시오스)
		- Vue에서 권고하는 Http통신 라이브러리
		- Promise 기반의 통신 라이브러리
		- 성공하면 then(), 실패하면 catch()로 들어감
		- ![[Pasted image 20240326220251.png]]
		- axios는 인스턴스를 생성하여 공통적인 데이터들을 넣어 공통화가 가능함![[Pasted image 20240424204023.png]]
		- axios로 해당 권한으로 취급하는 토근값을 넣는 방법
			- axios 인스턴스에 headers라는 속성 객체에서 Authorization이라는 속성에 토근 값을 넣어준다![[Pasted image 20240425210314.png]]
		- axios 인터셉터
			- http 요청, 응답 처리 전후로 로직을 추가 수 있는 기능
			- 유형
				- http 요청 전 또는 요청 후 에러에 대한 로직 처리
					- config는 http속성값들을 모아놓은 객체
					- ![[Pasted image 20240425212627.png]]
				- http 정상응답 또는 에러 응답에 대한 로직 처리
					- ![[Pasted image 20240425212717.png]]
			- 
- 템플릿 문법
	- Vue로 화면을 조작하는 방법
	- 템플릿 문법은 두가지로 나뉨
		- 데이터 바인딩
			- Vue 인스턴스에서 정의한 속성을 화면에 표시하는 방법 
				- 대표적으로  {{ }}
				- ![[Pasted image 20240327204332.png]]
		- Vue 디렉티브
			- 화면조작에서 자주 사용되는 방식이며 태그 속성 값에 'v-'가 붙음
			- v-bind
				- data에서 관리 중인 특정 값을 태그 속성에 부여하여 연결함
				- ![[Pasted image 20240327205346.png]]
			- v-if, v-else
				- 조건에 따라 특정태그를 보여주거나 안보여줄 수 있음
				- DOM에서 해당 정보를 제거함
			- v-show
				- 조건에 따라 특정태그를 보여주거나 안보여줄 수 있음
				- CSS의 display값을 설정하여안보여줌 (DOM에서 제거는 아님)
			- v-model
				- 태그의 value값을 연결함
			- v-on
				- 이벤트를 처리하며 지정한 이벤트가 발생하면 메서드를 실행함 (methods속성)
				- v-on:이벤트타입="methods속성의 메서드 이름"
					- keyup, keypress
						- 키를 눌렀을때 발생
						- key.키
							- 해당 키를 눌렀을 때 이벤트 발생
			- v-for 
				- 태그를 반복하여 생성
				- v-for="(아이템, index) in 리스트"
			- ref
				- HTML 태그에 접근할 수 있는 속성
				- 옛날 구문
					- document.getElementById() 
						- 태그 아이디 값으로 해당 태그 접근
					-  document.querySelector()
						- #, 등의 구분자로 아이디, 클래스 등의 값을 이용하여 태그 접근
				- 사용법
					- 태그에 ref="값"을 지정
					- 자바스크립트에서 this.$refs.값 으로 태그값 접근
					- ![[Pasted image 20240420111512.png]]
				- 
- 뷰 필터
	- 포맷처리 기능 
	- filters라는 속성으로 접근 (지역)![[Pasted image 20240427133746.png]]
	- ' | ' 를 필터할 값 뒤에 필터함수를 넣어 처리![[Pasted image 20240427133839.png]]
	- 전역 필터 설정
		- main.js 에서 Vue.filter()를 통해 전역으로 설정![[Pasted image 20240427134129.png]]
- watch, computed 속성
	- 데이터의 변화에 따라 특정 메서드, 로직을 실행할 수 있는 속성
		- ![[Pasted image 20240327211549.png]]
	- watch속성은 function의 매개변수로 (이전값, 이후값)을 가지고 있음
	- watch는 지양함
	- watch vs computed
		- computed는 간단한 로직, watch는 무거운 로직을 실행하는 것이 좋다
		- 웬만하면 computed를 쓰는 것이 좋음
- Vue CLI
	-  Vue 명령어 실행도구 (command line interface)
	- 명령어를 통해 특정 액션을 실행하는 도구
	- Vue 라이브러리 중 하나
	- 프로젝트 생성
		- vue create 프로젝트 이름
		- Default(Vue2)
	- 폴더 구성
		- main.js
			-  루트가될 vue인스턴스가 존재
		- App.vue
			- main.js에 지정된 vue인스턴스를 보여주며 컴포넌트들을 관리하는 컨테이너 컴포넌트 역할
		- package.json에서 "script"를 통해 명령어를 직접 지정할 수 있음
		- serve 명령어를 통해 public폴더의 index.html이 실행됨
			- 해당 index.html 파일에서 주석구문은 serve 시 src폴더의 main.js와 App.vue파일을 혼합하여 만들어진 소스들이 주석 구문에 들어감
			  (웹팩과 관련이 깊다)
			  ![[Pasted image 20240327220109.png]]
			- main.js의 .$mount('#app') 은 app이라는 아이디 태그에 붙이겠다는의미이며 아래 사진의 코드 두개는 동일하다![[Pasted image 20240327220255.png]]
			- render도 아래 사진 두 코드가 동일![[Pasted image 20240327220614.png]]
		- .vue
			- 싱글파일 컴포넌트
			- 아래사진은 양식![[Pasted image 20240327221103.png]]
	- 프로젝트 사용
		- template에는 루트 태그 하나만 올 수 있음
			- template태그안에 div태그가 두개이상 올 수 없음
		- export default {}를 사용하여 언제든지 해당 vue 컴포넌트가 사용될 수 있게 지정함
		- Vue 속성값중 data는 객체형식이 아닌 함수형식으로 return을 객체로 받는 형식으로 사용
			- ![[Pasted image 20240328213509.png]]
		- import ... from을 통해 vue 컴포넌트를 들고옴
		- this의 경우 해당 컴포넌트를 가르킴
- Vue 프로젝트 실행
	- 반응형 웹 설정 
		- 모바일, pc 어디든 해당 페이지가 깨지지 않게하는 디자인 기법
		- <meta name="viewport" content="width=device-width,initial-scale=1.0">
		- public의 index.html파일에 등록하여 반응형 웹임을 설정 (최신 버전은 자동등록)
	- 파비콘 설정
		- 파비콘 사이트에 들어가서 파비콘세팅
		- 해당 구문을 넣어줌(최신버전은 자동등록)
			- <link rel="icon" href="<%= BASE_URL %>favicon.ico">
- 로컬스토리지
	- localStorage.메서드()
	- 로컬스토리지에 자바스크립트 객체 그대로 넣어버리면 '[Obejct object]'로 값 확인을 할수 없다. 그래서 JSON.stringify()를 통해 JSON형태로 넣음
- ES6
	- 최신의 자바스크립트 문법
	- 최신 프레임워크에서 권고하는 언어 형식
	- 2015년 업데이트됨
	- 문법이 간결해져 익숙해지면 코딩을 훨씬 편하게 쓸 수 있음
	- Babel
		- ES6문법을 ES5문법으로 변환하는 컴파일러
			- 구 버전 브라우저는 ES6기능을 지원하지 않는 브라우저가 있으므로 번역이 필요
	- const, let
		- 블록 단위 {} 로 변수의 범위가 제한됨
		- ES6 새로운 변수 선언 방식
		- const
			- 상수
		- let 
			- 한번 선언한 값에 대해서 다시 선언할 수 없음
	- ES5 특징
		- 변수 스코프
			- {} 블록에 상관없이 스코프가 설정됨
			- 전역 스코프로 인식함
		- 호이스트
			- 선언한 함수, 변수가 가장 상단에 있는 것처럼 인식
			- 코드 라인 상관없이 함수선언과 변수부터 먼저 메모리를 할당함
	- 화살표 함수
		- 함수를 정의할 때 function이라는 키워드를 쓰지 않고 => 로 대체하여 문법을 간결화함
		- 
	- 객체 리터럴
		- 객체의 속성을 메서드로 사용할 떄 function 을 생략하고 생성가능![[Pasted image 20240331120335.png]]
		- 객체 속성명과 값명이 동일할 때 축약가능![[Pasted image 20240331120902.png]]
	- 자바스크립트 모듈화
		- 라이브러리 기능을 js언어 자체에서 지원
		- export, import 
		- export default 
			- 하나의 파일에서 하나만 export가 가능하다는 뜻
		- 파일별로 스코프를 나누어 스코프 충돌을 막아 안정성있는 코딩을 위해 사용
- Vuex
	- 많은 컴포넌트의 데이터를 관리하기 위한 상태 관리 라이브러리
	- 컴포넌트가 많아졌을 때 생기는 문제들을 관리하기 위해 사용됨
	- Flux
		- MVC패턴의 복잡한 데이터 흐름 문제를 해결하는 개발 패턴
		- ![[Pasted image 20240331123510.png]]
			- action
				- 화면에서 발생하는 이벤트
			- dispatcher
				- 데이터를 변경하는 방법
			- model
				- 화면에 표시될 데이터
			- view
				- 사용자에게 비춰질 화면a
		- a -> d -> m -> v -> a 로 계속 순환됨
		- 데이터의 흐름이 여러갈래로 나뉘는 MVC패턴과 달리 단반향 및 한방향으로 처리됨
	- Vuex 컨셉
		- State
			- 컴포넌트간 공유하는 데이터 : data()
		- View
			- 데이터를 표시하는 화면 : template
		- Action
			- 사용자의 입력에 따라 데이터를 변경 : methods
	- Vuex 구조
		- ![[Pasted image 20240331124340.png]]
		- 컴포넌트 -> 비동기로직 -> 동기로직 -> 상태
	- store
		- vuex파일을 보통 store로 지정함
		- Vue.use(vuex)를 해줌
		- export const store = new Vuex.Store({})
		- store.js![[Pasted image 20240401205935.png]]
		- main.js![[Pasted image 20240401210058.png]]
	- Vuex 기술 요소
		- state: 컴포넌트에 공유되는 데이터 (data)
			- vue와의 차이![[Pasted image 20240401210403.png]]
		- getters : 연산된 state값을 접근하는 속성(computed)
			- state를 직접 접근하기 번거롭기 때문에 쉽게 접근하기 위한 속성
			- 예시![[Pasted image 20240401210614.png]]
		- mutations: state값을 변경하는 이벤트 로직,메서드 (methods)
			- state의 값을 변경할 수 있는 유일한 방법이자 메서드
			- commit()으로 동작시킴
			- 예시![[Pasted image 20240401212602.png]]
			- commit(메서드이름, 추가인자)로 들어감 
			- mutations의 메서드의 인자로 항상 state가 들어가며 commit()할때 자연스럽게 해당 인자가 포함되어 있다. 추가인자의 경우 commit(메서드이름, 추가인자)로 들어감
			- 단, 추가인자는 한개까지 가능
			  (객체로 만들어서 넘겨야함)
			- state를 직접 변경하지 않고 mutation으로 변경하는 이유
				- state는 모든 컴포넌트에 공유된다는 특징이 있다. 여러개의 컴포넌트가 존재할 경우 어떤 컴포넌트에서 state를 변경했는지 추적하기힘들기 때문에 commit을 통해 변경함
		- actions : 비동기 처리 로직을 선언하는 메서드 (aysnc methods)
			- 비동기 로직을 담당하는 mutations
			- 데이터 요청, Promise, async와 같은 비동기 처리는 모두 actions에 선언
			- 예시![[Pasted image 20240401221847.png]]![[Pasted image 20240401222049.png]]
			- context를 통해 store의 메서드와 속성 접근
			- this.$store.dispatch(액션 메서드이름)을 통해 실행
			- 비동기 처리 로직을 action으로 선언하는 이유
				- state값의 변화를 추적하기 어렵기 대문에 mutations속성에는 동기 로직만 넣음
	- helper 함수
		- store에 있는 속성들을 간편하게 코딩
			- state => mapState
				- ![[Pasted image 20240402204043.png]]
				- this.변수로 접근 가능해짐![[Pasted image 20240402204127.png]]
			- getters => mapGetters
				- ![[Pasted image 20240402204210.png]]
			- mutations => mapMutations
				- ![[Pasted image 20240402210147.png]]
				-  methods에 선언
				- '@이벤트이름'으로 간단하게 표현 가능
				- HTML단 호출에서 인자가 있으면 자동으로 인자들을 가져옴
			- actions => mapActions
		- this.$store.state.변수 == mapState([변수]) 로 간편하게 사용가능
		- 사용법![[Pasted image 20240402203222.png]]
		- ...객체
			- spread operator
			- ...객체를 통해 해당 객체안에 존재하는 key, value값을 뿌려줌
			- 사용예시![[Pasted image 20240402203824.png]]
			- 
		- helper함수는 spread operator이 필수!!
			- ...을 통해 해당 객체 내부에 있는 값을 computed에 매칭시켜줌
		- mapGetters([]), mapGetters({})의 차이
			- 후자는 key이름을 달리해줄 때 사용
			- ![[Pasted image 20240402210023.png]]
	- store의 모듈화
		- 속성들을 사용하다보면 하나의 store에 많은 양의 코드들이 들가게됨
		- 그것을 속성마다 모듈화를 진행
		- 모듈화는 ES6의 import, export를 이용
			- ![[Pasted image 20240402212603.png]]
		- modules
			- 앱이 비대해져서 1개의 store로 관리하기가 힘들 때 modules속성을 사용
			- ![[Pasted image 20240402213333.png]]
			- 해당 모듈 파일에는 각각의 속성을 객체로 지정해주고 export해줌
	- 디스트럭쳐링
		- ![[Pasted image 20240414140926.png]]
- 플러그인
	- .use()
		- vue의 플러그인을 등록하는 문법
		- vue를 사용하는 영역 전체에 특정기능을 추가할 때 사용됨 (전역등록)
	- Vue 속성 추가
		- Vue.prototype.$이름 = 플러그인화할 라이브러리
		- 전역으로 this.$이름을 통해 해당 라이브러리를 사용 가능
- 이벤트 버스
	- 빈객체를 만들어 컨포넌트간 데이터를 전달하는 것을 의미
	- 해당 이벤트 버스를 통해 깊은 컨포넌트간의 이동이 가능해짐
	- 단, 해당 이벤트 버스를 $on 하고나서 반드시 $off 해주어야한다 (해당 이벤트 버스 객체가 계속 중첩되어 실행될 수 있음)
	- bus 코드 ![[Pasted image 20240416220137.png]]
	- 쓰임새![[Pasted image 20240416220202.png]]![[Pasted image 20240416220215.png]]
- 하이 오더 컴포넌트
	- 컴포넌트의 코드를 재사용하기 위한 고급기술
	- 컴포넌트위에 공통으로 쓰일 옵션을 가지는 컴포넌트를 하나 두어 코드 중복을 줄임
	- js파일에서 뷰 옵션들을 지정할 수 있으며, reder함수를 통해 원하는 컴포넌트에 그려넣음
	- 단점
		- 중간에 컴포넌트를 하나 두기 때문에 하이 오더 컴포넌트를 만들수록 컴포넌트 깊이가 깊어져 컴포넌트끼리 통신하기 힘들어짐
	- 사용법
		- 공통의 옵션들을 js파일 하나로 모음![[Pasted image 20240417205313.png]]ListView라는 하나의 컴포넌트로 통일하고 데이터만 다르게 들고옴![[Pasted image 20240417205416.png]]
- Mixins
	- 여러 컴포넌트 간 공통으로 사용하고 있는 로직 기능을 재사용하는 방법
	- data, methods, created 만 가능
	- 부차적인 로직들을 Mixins으로 빼면서 해당컴포넌트에는 핵심적인 CRUD 기능만 넣어 코드가 깔끔해지고 중복이 줄어듬
	- 사용법
		- js파일을 만들고 필요한 공통로직들을 넣는다.![[Pasted image 20240417211903.png]] 이후 해당 mixins파일을 원하는 컴포넌트 파일의 mixins속성에 추가![[Pasted image 20240417211955.png]]
	- 하이 오더 컴포넌트와의 차이점
		- 컨포넌트를 추가하지 않기에 컨포넌트 깊이가 깊어지진 않음
- 라우터 네비게이터 가드
	- 라우터에서 특정 URL로 접근하기 전의 동작을 정의하는 속성(함수)
	- beforeEnter 속성으로 정의
	- 파라미터
		- to : 이동할 URL의 라우팅 정보
		- from : 현재 URL의 라우팅 정보
		- next : 어떠한 조건이 만족되면 next()를 통해 이동할 URL로 이동가능
			- next(URL)처럼 파라미터를 넣으면 해당 URL에 매칭되는 페이지로 이동됨
	- 사용법
		- ![[Pasted image 20240418205557.png]]
- 데이터 호출 시점
	- 라이프 사이클 훅
		- created : 컴포넌트가 생성되자마자 호출되는 로직
		-  컴포넌트가 생성되고 실행됨
	- 라우터 네비게이터 가드
		- 컴포넌트가 생성되기 전에 실행됨
	- 
- 자바스크립트 비동기 처리
	- Collback
	- Promise
		- then()의 리턴값은 프로미스 객체이다.
	- async
		- 동기화 처리하려는 함수에 async를 선언하고 그 함수 안에서 동기화될 함수들을 await로 선언
		- 단, await로 선언한 함수는 리턴값이 Promise 객체여야함! (변수에 값을 담는  형태여야함)
		- async함수에서 리턴값은 어떤것을 넣든 프로미스객체가 리턴됨 (리턴값이 매개변수가됨)
		- ![[Pasted image 20240419174247.png]]
		- promise vs async![[Pasted image 20240419175212.png]]
		- async 에러 캐치
			- try - catch문을 통해 예외를 잡을 수 있음 
			- Promise의 catch()는 비동기 처리의 예외만 받지만 try-catch는 자바스크립트의 모든 코드의 예외들을 받음
- render함수
	- 템플릿을 실시간으로 내부적으로 구현해주는 함수
	- 문법![[Pasted image 20240420124802.png]]
		- 예시![[Pasted image 20240420124859.png]]
	- 위 문법을 ES6로 줄인것이
	  render: h => h('p', this.message) 이다
	- 
- 프로젝트 개발 설정 
	- ESLint
		- 자바스크립트 문법 보조 검사 라이브러리
		- rules속성을 통해 문법에 대한 검사를 커스텀 할 수 있음![[Pasted image 20240421111328.png]]
	- prettier
		- 코드의 개행 기준을 만들어주는 라이브러리
		- ESLint와 같이 쓰임
		- 사용법
			- .prittierrc 파일을 생성
			- 만약 ESLint와 함께 쓸 경우 ESLint의 설정파일에 prettier 설정 값을 입력
				- 배열로 정의하며 '[유형, 속성객체]![[Pasted image 20240421111958.png]]
	- 절대경로 설정
		- 모듈 임포트 시 프로젝트 코드의 규모가 크다면 상대경로로 가져오기엔 경로 길이가 길어지게됨. 그래서 절대경로로 들고옴
		- jsconfig.json을 통해 설정함
			- vscode 내부 기능을 활용하기 위한 설정파일
			- 
- 서비스 배포 설정
	- 배포 명령어
		- npm run biuld
		- 서버에 올릴 파일들이 생성됨
		- 해당 명령어를 통해 나온 dist폴더의 css, js, html파일들이 생성됨 (webpack사용하여 파일 생성)
		- 해당 파일들을 서버에 올려주면됨
	- 환경변수 파일 옵션 (env 파일)
		- CLI 3.x 부터 가능한 방식
			- 원래는 webpack에 직접 등록해주어야함![[Pasted image 20240420132350.png]]
		- 변수 = 값 의 형식으로 옵션들을 등록
		- process.env로 코드에서 접근 가능
		- 단, 변수 선언 시 앞에 'VUE_' 가 들어가야함
		- 예시
			- 코드단![[Pasted image 20240420132554.png]]
			- env 파일![[Pasted image 20240420132626.png]]
		- .env.development, .env.production
			- 환경변수 파일을 개발용, 운영용으로 나누어 쓸 수 있다
			- 로컬서버로 켜지면 development가 우선순위로 가짐
			- npm run build했을 때 production의 파일이 우선순위를 가짐
- JEST
	- 자바스크립트 테스트 프레임워크
	- https://jestjs.io/
	-  테스트할 컴포넌트이름.spec.js로 만듬
	- vue-cli-service test:unit라는 명령어로 테스트를 실행하며 뒤에 '--watchAll' 붙이면 자동으로 코드가 변경하였을 때 테스트를 실행시켜줌
	- 사용법
		- describe('테스트이름', 함수())
			- 테스트이름으로 테스트 그룹 지정
		- test('테스트이름', 로직())
			- 해당 테스트이름으로 테스트할 로직 실행
		- expect(테스트값)
			- 테스트에서 나온 값이 원하는 값이 맞는지 확인
		- ![[Pasted image 20240428135728.png]]
	- console.log를 찍을 경우 터미널로 해당 값을 확인할 수 있음
	- Vue 테스트
		- 최소 그룹단위는 컴포넌트
		- Vue 인스턴스를 만들어서 해당 컴포넌트를 파라미터로 넣고 마운드한 값을 테스트함
		- ![[Pasted image 20240428140656.png]]
		- Vue 테스트 라이브러리
			- vue-test-utils
			- https://v1.test-utils.vuejs.org/guides/
			- 사용법
				- shallowMount(컴포넌트, 데이터 객체)
					- vue 인스턴스 생성을 간단하게 줄여줌
					- 해당 리턴값의 vm이 인스턴스이다.
					- ![[Pasted image 20240428141201.png]]
					- 데이터 객체값을 파라미터로 추가하여 해당 컴포넌트의 Vue 속성에 값을 넣을 수 있다.![[Pasted image 20240428141756.png]]
				- find(html요소)
					- 해당 컴포넌트의 태그를 리턴하는 기능(아이디, 클래스,)
					- ![[Pasted image 20240428141452.png]]
- 뷰 실무 개념
	- CLI 2.x vs CLI 3.x
		- 명령어
			- 2.x : vue init
			- 3.x : vue create
		- 웹팩 설정파일
			- 2.x : 노출 
			- 3.x : 노출 x
				- 웹팩을 프레임워크단에서 관리, vue.config 파일에서 웹팩설정을 추가할 수 있음
		- ES6이해도
			- 2.x : x
			- 3.x : 필요 
	- 라우터구현
		- 해당 라우터는 main.js에서 Vue router 속성에 router를 추가해줌 (라우터 정보가 담긴 파일을 import 한 후 진행)
		- 그리고 원하는 컴포넌트(페이지)에 rotuer-vue 태그를 추가함
		- 리다이렉트가 필요한 경우 라우터 정보가 담긴 파일의 route 속성에 객체를 추가하여 리다이렉트 속성을 추가하여 구현![[Pasted image 20240415212527.png]]
		- 뷰라우터의 mode속성을 'histroy'로 하여 URL에 '#'이 붙는 것을 없앨 수 있음
		- name 속성을 이용하여 페이지 분기처리 가능
	- Vuex구현
		- store관련 파일을 따로 만들고 main.js에 import하고 Vue인스턴스의 store속성에 추가해준다.
		- store 속성의 경우 각각의 파일로 모듈화하여 사용할 수 있다.![[Pasted image 20240414145520.png]]
		- 
	- 라우터 트랜지션
		- 화면전환에 대해 애니메이션을 지정할 수 있음
		- 사용법
			- router-view 태그 밖에 transition 태그를 달아줌![[Pasted image 20240414165846.png]]
			- name 속성를 통해 css를 지정하여 원하는 애니메이션을 지정
	- slot
		- slot기능을 통해 해당 컴포넌트의 html을 바깥에서 조정하여 좀 더 유연하게 해당 컴포넌트를 재사용할 수 있게됨![[Pasted image 20240416220057.png]]![[Pasted image 20240416220113.png]]
	- 외부라이브러리 모듈화
		- 태그에 값을 자바스크립트로 들고올 경우 ref속성을 이용
	- 컴포넌트 디자인 패턴
		- Common : 기본적인 컴포넌트 등록과 컴포넌트 통신
			- Props와 Emit을 통해 컨포넌트간 통신
		- Slot : 마크업  확장이 가능한 컴포넌트
			- slot을 통해 화면영역을 확장가능하며 하나의 컴포넌트를 유연하게 사용가능하다. 
		- Controlled : 결합력이 높은 컴포넌트
			- checkBox등의 컴포넌트들
			- props대신 v-model을 이용하여 컴포넌트 값 변경
			- 변경된 값들을 내려줄때 상위에서 v-model로 데이터를 내려주고 하위에서 value로 props를 넣고 결과에 대해 'input'이라는 이벤트로 올려주면 됨. (상위에선 v-model로 선언하면 끝, 아래만 value 프롭스, input 이벤트 선언) 
			- 예시
				- 상위![[Pasted image 20240420124034.png]]
				- 하위![[Pasted image 20240420124053.png]]
		- Renderless : 데이터 처리 컴포넌트
			- 템플릿이 없는 컴포넌트
			- 데이터만 제공하는 컴포넌트
			- 데이터 처리에 대한 컴포넌트를 따로 분리할 때 사용
			- 사용법
				- 태그에 slot-scope 속성을 추가하고 받아올 값을 선언![[Pasted image 20240420125836.png]]
				- 해당 데이터 처리 컴포넌트에서 render()함수를 통해 $scopedSlots값에 접근하여 데이터를 선언해줌![[Pasted image 20240420130029.png]]
				- 받아온 데이터를 통해 분기를 치면서 실시간으로 데이터에 따른 화면변경이 가능
	- 비동기 처리
		- aciton를 통해 비동기로 호출할 경우 dispatch를 쓴 구문에 await처리가 필요하다.![[Pasted image 20240427121213.png]]
	- 