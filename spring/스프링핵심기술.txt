1. 웹
* 웹서버
- 정적인 파일을 서빙
* 웹애플리케이션서버
- 사용자에 따라서 다른 화면을 보여줄 수 있음(동적)
- 프로그램 코드를 실행하여 애플리케이션 로직 수행

* 웹서버, 웹애플리케이션 서버 의 차이
- 웹서버는 정적파일, was는 애플리케이션 로직을 실행

* 웹 시스템 구성
- was, DB만으로 구성 가능
-- 이렇게 해버리면 was가 애플리케이션 로직, 정적파일 다 담당해서 과부화
-- was는 잘죽어서 오류화면을 제공하지 못함
- 웹서버, was DB
-- 웹서버는 정적파일을 송출
-- 동적인 처리가 필요하면 was에 위임하는 형태(업무분담)
-- 정적 리소스가 많이 필요되면 웹서버 증설, 애플리케이션 로직이 많이 사용되면 was 증설
-- web서버는 잘 죽지 않기에 오류화면을 제공 가능해짐
-- 해당 구성을 기반으로 만들어짐!!

*서블릿
- TCP/IP연결, http요청메세지 파싱, 응답 메시지생성
  을 도와줌 (비즈니스 로직을 제외한 모든 작업을 자동화해줌)
- http 요청시 reqeust, response객체를 생성하여 서플릿 객체에 호출
  그리고 request객체에서 요청정보를 꺼내서 사용 후 response객체로 
  필요한 데이터를 담아서 클라이언트에게 넘김

*서블릿 컨테이너
- 서블릿을 지원하는 was를 서블릿 컨테이너라고함
- 서블릿 객체의 생성, 초기화,호출,종료 등 생명주기 관리
- 서블릿 객체는 싱글톤으로 관리
-- 요청마다 생성하는 것은 비효율
-- 미리 만들어두고 재활용
-- 멀티스레드 처리 지원(중요!)

*멀티 스레드
- 스레드
-- 애플리케이션 코드를 하나하나 순차적으로 실행하는것
-- 스레드가 없으면 애플리케이션 실행 불가능
-- 쓰레드는 하난의 코드라인만 실행
-- 동시처리가 필요하면 여러 쓰레드가 필요

- 요청할 때마다 쓰레드 생성
-- 동시 요청 처리가능
-- 쓰레드 생성 비용이 비쌈 (서버 부하)
-- 컨텍스트 스위칭 비용 발생 ( 쓰레드에서 다른 쓰레드로 작업을 이동할때의 비용)
-- 쓰레드 생성은 제한이 없기에 메모리 임계점을 넘어 서버가 죽을 수 있다 

- was에서 쓰레드
-- 쓰레드 풀이 존재( 미리 쓰레드를 어느정도 생성해둠)
-- 작업이 완료된 쓰레드는 쓰레드 풀로 돌아감
-- 생성된 쓰레드 이상의 작업 요청이 들어오면 대기시킴
-- 쓰레드 풀 실무 팁
--- 튜닝 포인트는 최대 쓰레드 수
    (너무 낮게 너무 높게 설정하면 안됨)

* 백엔드 용어
- 정적 리소스
- 동적 HTML 페이지
- HTTP API [참고47페이지]
-- 주로 JSON형태로 데이터 통신
-- 클라이언트, 서버 등 다양하게 시스템 연동
(이 세개를 어떻게 만들지 고민하는게 백엔드)

- 서버사이드 렌더링 (SSR) [참고51페이지]
--서버에서 최종 HTML을 생성하여 클라이언트에 전달
-- 주로 정적인 화면 사용
- 클라이언트사이드 렌더링 (CSR)
-- HTML결과를 자바스크립트를 사용해 웹 브라우저에서 동적으로 생성
-- 주로 동적인 화면 사용
-- react, vue

2. 서블릿
* httpServletRequest
- 서블릿은 개발자를 대신하여 http요청 메세지를 파싱하는데 
  그 결과를 httpServletRequest 객체에 담아서 제공
 
* http요청 데이터
- 서버로 데이터를 넘기는 방식
--GET 쿼리파라미터
--- ex. /url?username=hello&age=20
--- 메세지 바디없이 URL의 퀴리 파라미터에 데이터를 포함
--POST HTML FORM
--- 메시지 바디에 쿼리 파리미터 형식으로 전달 username=hello&age=20 
--- content-type(메시지 바디에 대한 정보를 설명)
--HTTP message body에 데이터를 직접 담음
--- HTTP API에서 주로 사용 
--- 데이터 형식은 주로 JSON
--- 단순 텍스트의 경우(content-type은 text)
---- request객체에서 getInputStream()을 통해 서블릿스트림 객체 호출
     이후 해당 객체에 담긴 메세지바디의 데이터를 String타입으로 변경
      (StreamUtils.copyToString(스트림객체, 캐릭터셋)
--- JSON의 경우(content-type은 json)(라이브러리필요)
---- JSON 데이터를 파싱할 수 있는 객체가 필요!!( 직접 만들어줌)
---- request객체에서 getInputStream()을 통해 서블릿스트림 객체 호출
     이후 해당 객체에 담긴 메세지바디의 데이터를 String타입으로 변경
---- ObjectMapper 객체를 생성하여 readValue(메세지바디, 파싱클래스)
      를 통해 해당 값을 담은 파싱객체 생성

* httpServletReponse
- 해당 객체를 통해 다양한 세팅을 제공함
  (HTTP응답 코드 지정, 헤더 생성 ,바디 생성, 쿠키, Redirect, content-type)
- setStatus(응답코드) 메서드를 통해 응답코드 세팅가능
- setHeader(name[헤더이름], value)
  (내가 만든 헤더도 세팅 가능)
  (헤더에 관한 편의 메서드도 존재함)
- 쿠키 세팅
-- 쿠키 객체를 만들어서 response의 addCookie(쿠키)를 통해 쿠키를 세팅 가능
   (쿠키 객체는 setMaxAge(초)를 통해 유지 시간 세팅 가능)
- sendRedirect(URL)을 통해 해당 URL로 리타이렉트
- 메시지 바디 세팅
-- getWriter()메서드를 통해 PrintWriter객체를 호출
   이후 해당 PrintWriter의 println(메시지)를 통해 응답 메시지바디 세팅

* http응답 데이터
- 클라이언트로 데이터를 넘기는 방식
-- 단순텍스트
-- HTTP API (JSON) (라이브러리 필요)
--- ObjectMapper의 writeValueAsString(객체) 를 통해
     해당 데이터를 JSON으로 변경

3. MVC 패턴 (서블릿 <-> JSP)
- 쓰게 된 이유
-- 하나의 서블릿이나 JSP가 로직과 렌더링을 둘다 담당하게되면
  유지보수가 어려워짐 
  (즉, 코드 파악하기도 힘들고 유지보수 중 코드를 잘못 건들 수 있음)
-- 로직과 렌더링을 수정하는 경우 하나의 코드로 관리하는 것은
  유지보수가 힘듬
-- JSP는 화면을 렌더링하는 것이 최적화 되어있기에
  로직은 따로 분할한느 것이 좋다
-- 그래서 MVC패턴을 사용
--- Controller에서 비즈니스로직을 실행하여 Model에 데이터를 담고
     View에서 Model의 데이터를 참고하여 화면을 렌더링
     (컨트롤러에 비즈니스로직을 두는 것은 너무 투머치함,
     일반적으로는 서비스계층을 두어 별도로 처리함으로써 
     컨트롤러는 비즈니스 로직을 호출하는 역할을 맡는다)
-한계
-- 매번 forward 메서드를 호출해야함
-- 사용안되는 매개변수가 생김 (response의 경우 사용안됨)
-- 공통처리가 힘듬
    (기능이 복잡해질수록 공통처리 부분이 늘어나는데
     중간에 묶어서 처리해줄 수문장이 없음)
    (프론트 컨트롤러패턴을 도입하면 해결가능)                  

4. MVC패턴(프론트 컨트롤러 패턴)
- 공통의 기능들을 모아서 중심이 되는 컨트롤러를 통해
  두어 다른 컨트롤러들과 연결해서 사용
- 컨트롤러 인터페이스를 활용해서 다형성
  ( Map<String, inferface>  )

**** 종속성 없애기
- 해당 프레임워크에 쓰이는 어떠한 객체와 해당 객체의 메서드
  에서 파라미터로 받는 값의 타입을 자료구조로 만들어서 
  그 자료구조에 값들을 저장하고 난 뒤 마지막에 해당 객체의 메서드에
  옮겨준다 
   ( request.setAttribute(String, Object) 의 경우
   Map(String, Object) 의 자료구조를 생성하여 값을 넣은 후
   map.forEach((String, Object) -> request.setAttribute(String, Object)
   이런 식으로 옮겨준다) ) 
   (단, 매개변수가 3개 이상일 땐 어떻게 처리해야할까??)

5. MVC패턴(어댑터 패턴)
- 현재는 한가지 컨트롤러 인터페이스만 사용가능하다
- 하지만 여러가지 컨트롤러를 유연하게 쓰려면
  어댑터 패턴이 필요하다.

6.springMVC 전체 구조
- DispatcherServlet = frontController
-- 스프링 부트는 DispatcherServlet을 서블릿으로 자동으로 등록
-- doDispatch()메서드가 호출됨 (가장 중요한 메서드)(frontcontroller의 service메서드 느낌)
- 주요 인터페이스 목록
-- 핸들러 매핑 (HandlerMapping)
--- 핸들러 매핑에서 빈이름에 해당하는 핸들러를 찾음
--- RequsetMappingHandlerMapping(어노테이션 기반)(1순위) 
     BeanNameUrlHandlerMapping(빈이름으로 찾음)(2순위)
-- 핸들러 어댑터 (HandlerAdapter)
--- 찾은 핸들러를 실행시킬 핸들러 어뎁터를 찾고 실행
--- RequsetMappingHandlerAdapter(어노테이션 RequestMapping인것 처리)(1순위)
--- HttpRequestHandlerAdapter(인터페이스 httpRequestHandler인 것을 처리)(2순위)
--- SimpleControllerHandlerAdapter(인터페이스 controller를 처리)(3순위)
*** 핸들러 매핑, 핸들러 어댑터 모두 순서대로 찾고 없으면 다음순서로 넘어감
-- 뷰 리졸버 (ViewResolver)
--- application.properties에 등록한 spring.mvc.view.prefix, or ...suffix설정 정보를
     등록하여 물리주소를 정해줌
--- BeanNameViewResolver(빈이름으로 뷰를 찾아서 반환)(1순위)
--- InternalResourceViewResolver(jsp를 처리할 수 있는 뷰를 반환)(2순위)

-- 뷰 (View)





