- 컴퓨터 기초 이론
	- 1bit와 2진수(디지털)
		- 1 비트 : 전기 스위치 1개
		- 전기가 흐르는 On상태는 1
		- 전기가 흐르지 않는 off 상태는 0
		- 스위치를 4개 조합하면 4bit
			- 2진수로 4자리 숫자이며 2^4 즉, 16개의 경우의 수가 존재
		- 진수 구분
		  **2^3 = 8 , 2^2 = 4, 2^1 = 2, 2^0 = 1
		  (8421 외우기!)**
	- 2진수, 16진수 진법변환
		- 컴퓨터의 경우 0,1 2진수로 표현되지만 실제는 16진수로 변환하여 쓰이고 있음
		- 16진수는 10이후로는 ABCDEF로 표현
		-  **4비트는16진수 한 자리 숫자다.**
		  ex. F6 => 4비트 + 4비트 = 8비트
		- 진수 변환 계산법
			- 2 => 16
			  ex. 6 
			  0110 => 8 4 2 1 에서 4, 2에 On이므로 6으로 표현됨
			- 16 => 2
			  ex. 12(C)
			  12(C) => 8 4 2 1 에서 8 + 4 이기에
			  1100으로 표현됨
	- 16진수 표기 사용 예시
		- 색상표현(RGB) 
			- css의 컬러 코드도 16진수로 표기하며 8비트 3개로 이루어짐 (ex. B7 1C 1C)
		- 컴퓨터 하드웨어 주소 표현
			- 0x00000281848B1070 16진수로 이루어져있음 
			- 컴퓨터의 경우 0과 1로 표현이되지만 이걸 4개씩 묶어 4비트로 사용며 4비트는 16가지의 경우를 표현할 수 있기 때문에 16진수로 쓰인다
		- 메모리 값 표현
	- 단위 체계
		- 1byte(바이트) : 8개 비트를 하나로 묶은것
			- **1바이트는 영문자 한글자가 저장될 수 있는 메모리 크기이며 관리의 최소단위! (한글은 2바이트)**
		- 바이트 이후로 1024개의 하나의 단위가 모이면 단위가 올라감
	- 컴퓨터의 글자 관리
		- 컴퓨터는 0,1 밖에 모름 하지만 십진수의 65 , 16진수의 0x41을 'A'라고 약속하고 체계화하여 코드체계가 등장하였고 컴퓨터는 약속에 따라 'A'라는 값을 **렌더링**해줌
		- 하지만 회사마다 그 코드체계의 기준이 달라졌고 ASCII이라는 미국의 표준 코드체계가 생김
		- 숫자 1과 문자 '1'은 다르다.  (심지어 빈칸도 문자임)
		- 바이너리: 숫자 글자 구별하지 않고 말하는 정보
			- 텍스트, 숫자의 포함하고 있는 큰 범위![[Pasted image 20240316132737.png]]
	- 컴퓨터의 사진 관리
		- 모니터 화면 상 '점' 하나를 화소(pixel)이라고함 
		- 여러점을 모아 사진을 만듬
		  (점하나의 RGB로 표현하고 그것을 연속으로 표현)
		- 화소(pixel)하나를 표현하는데 비트 단위의 정보가 필요 (RGB컬러면 24비트)
			- 24비트 + 8비트가 추가되면 투명도를 의미 (RGBA)
		- 현재 사진은 모든 비트맵에 대한 정보를 가지고 있는 row한 방법을 쓰지 않고 정보를 압축한 형태로 쓰고 있음![[Pasted image 20240316141123.png]]
- 컴퓨터 구조
	- 디지털 회로
		- 아래 사진을 기준으로 디지털회로를 만듬![[Pasted image 20240316141624.png]]
		- 이러한 디지털회로를 이용하여 CPU를 만듬
			- 전기신호를 보내고 AND,OR 게이트를 통해 on/off신호를 계산하고 더하기 로직을 만들게 됨![[Pasted image 20240316142903.png]](그래서 전기가 들어올땐 전도체, 안들어올 땐 부도체가 되어 반도체라는 이름이 탄생)
	- 덧셈방식
		- ![[Pasted image 20240316143019.png]]신호 하나 당 1bit이며 게이트를 통해 1,1의 결과가 나오면 올림을 통해 자릿수가 늘어나는 식으로 덧셈이 진행됨 (반가산기)
		- ![[Pasted image 20240316143248.png]]올림값을 포함한 3개의 bit를 연산하는 것을 전가산기라고함
		- ![[Pasted image 20240316143405.png]]이러한 전가산기를 병렬로 4개놓으면 4bit 전가산기라고함
	- 뺄셈방식
		- 보수를 더하면 자연스럽게 뺄셈이 됨
			- 보수
				- 6+4 = 10이다.
				  즉, 4는 6에 대한 10의 보수이다.
			- 13 - 6 을 한다 했을때 13은 1101 6은 0110이다. 이때 6의 1의 보수는1001이 됨. 이 값에 +1한 값이 2의 보수가 되며 이 값과 13의 1101값을 더하면 10111이됨. 그때 4bit를넘어서기에 자리올림된 수는 버리면 0111이되는데 이 값이 7이다.
	- 곱셈방식
		- 값을 여러번 더하면됨
		- 효율적인 방법이 존재
			- shift 방식 : 왼쪽부터 숫자를 밀어버림
			- padding 방식 : 오른쪽에 숫자를 채움
			- ex. 0010 (2) -> 0100 (4)
			     0101(5) -> 01010 (10) 
			     (왼쪽의 4자리를 넘어가는 값은 버림)
	- 나눗셈방식
		- 값을 여러번 빼면됨
		- 효율적인 방법이 존재
			- shift 방식 : 오른쪽부터 숫자를 밀어버림
			- padding 방식 : 왼쪽에 숫자를 채움
			- ex. 0100 (4) -> 0010 (2)
			     1010(10) -> 0101 (5) 
			     (오른쪽의 4자리를 넘어가는 값은 버림)
		- 어떠한 숫자를 0으로 나눈다면 어떠한숫자를 0을 무한정 빼기에 무한으로 연산이 일어나게 됨
	- 컴퓨터가 연산하는 과정
		- CPU(연산장치) , RAM(저장장치)
		- RAM의 저장량이 42억...이면 이것은 2^32이며 byte환산 시 4GB가 된다.
		  즉, 해당 RAM이 4GB짜리이다
		- 운영체제가 32비트라면 RAM이 16GB여도 4GB의 효율밖에 못냄   
	- 컴퓨터의 기억공간 관리
		- 정보가 저장되는 위치는 숫자로 표시하여 관리하며 '메모리 주소'라고 한다.
		- 보조기억장치(파일시스템)은 트랙번호, 섹터번호를 붙여 관리함
		- 기억을 관리하는 곳은 **레지스터, 캐시, 메모리, 파일시스템, 백업장치** 등 있다.
			- 왼쪽부터 속도가 빠르고 가격이 비싸서 대용량 사용이 불가능
			- 레지스터, 캐시, 메모리는 휘발성이다.
			- 레지스터와 파일시스템의 속도격차가 심하여 중간다리 역할을 해주는 캐시, 메모리가 존재
			- 캐시의 경우 메모리에 할당되어 있는 값들 중 레지스터에 곧 필요한 값을 예측하여 미리 캐시에 저장해둠
		- 어떠한 프로그램이 설치되면 하드디스크(보조기억장치)에 설치를 하고 해당 프로그램을 실행하면 메모리에 올라가고 CPU(레지스터 + 캐시)에 보내 연산을 시작함
	- 파일 시스템 (보조기억장치)
		- ![[Pasted image 20240316153945.png]]트랙, 섹터로 나누어 관리됨 (아파트 ~동 ~호 와 비슷한 개념)
		- 기본적으로 읽기, 쓰기가 가능하며 관리는 OS가 자동적으로 관리함
			- 만약 한 섹터에 10만번이상 쓰기를 한다면 해당 섹터는 더이상 읽기 쓰기를 할 수 없다. 이러한 섹터를 Bad Sector라고 함
			- 이러한 Bad Sector를 만들지 않기 위해 같은 데이터라도 OS가 빈공간에 쓰기를 함(그렇다고 이전 데이터를 지우진 않음)
		- 보통 섹터 1개당 512byte이다.
			- 데이터 저장시 512byte이하라면 해당 섹터를 전부 다씀 (따로 촘촘히 채우진 않는다.)
			- 데이터 저장시 512이상이라면 다른 섹터를 쓰기 시작하는데 옆 섹터가 이미 데이터가 존재한다면 넘어가서 다른 섹터에 저장하는 식으로 진행됨 (그래서 용량이 큰 데이터의 경우 I/O성능이 매우 떨어지게됨.)
				- 그걸 디스크조각모음으로 같이 데이터끼리 한 트랙에 모아주고 섹터를 연결시켜줌
				- 예전에는 직접 조각모음을 해주었지만 요즘은 OS가 주기적으로 자동으로 조각모음해줌
		-  파일이 저장되는 방법
			- **File Allocation Table (FAT)의 형태로 저장된 파일의 위치를 관리함**![[Pasted image 20240316155812.png]]
			- 만약 저장된 파일을 삭제시킬 경우 해당 FAT에서 삭제 플래그 값에 체크가 된다. (그래서 하드 복원이 가능한 것이다.)
		-  0번트랙 0번 섹터는 마스터부트레코드라고 하며 아주 스페셜한 섹터이며 OS의 부트로드 코드가 들어감 (컴퓨터 실행할 때 해당 섹터를 찾아 OS부트코드를 꺼내 운영체제 시스템을 메모리에 적재시킴 이걸 '부팅'이라고 함)
			- 만약 악성코드의 경우 해당 마스터부트레코드의 섹터를 못쓰게 하여PC를 가동 못하게 만들어버림
			- 포맷
				- 하드의 테이블형식을 변경시켜 파일 위치데이터만 읽어오지 못하게함 (빠른 포맷)
				- 모든 트랙 섹터를 0으로 쓰기(느린 포맷)
	- 운영체제
		- 프로세스에 할당된 메모리 공간을 관리하며 동시에 여러 프로세스들이 존재하는 멀티 태스킹 공간에서 원자성과 독립성을 보장해주기 위해 관리하는 프로그램
		- 동시성
			-  서로 다른 일이 한 주체가 동시에 진행하는 것
		- 병렬성
			- 하나의 일을 여러 주체가 동시에 진행하는 것
		- 원자성
			- 동시에 일어나는 일에서 서로 공유되는 작업이 있을 때 하나의 일만이 공유 작업을 할 수 있는 것
			 (동기화가 되는 것)
			- 동기화
				-  공유되는 자원을 동시에 사용할 수 없게 지정하는 절차장치
				- 데드락 (교착상태)
					- 논리의 오류
					- 동기화 절차에서 논리오류가 생겨 락을 풀지 못하고 언락된 자원을 실행하지 못하는 상태
		- 프로그램
			- 프로그램은 설치하는 것!
		- 프로세스
			- 설치된  프로그램을 실행하면 운영체제가 프로세스가 생성 (작업관리자에서 확인 가능) 
		- 스레드
			- 프로세스 속에 존재하는 하나의 실행단위 (프로세스는 적어도 1개의 스레드을 가지고 있다.)
			- 프로세스에게 할당된 자원(메모리)을 공유함 (연산을 하기 위해)
		- 메모리
			- 메모리 안에는 용도에 따른 메모리 공간이 존재
			- stack
				- 스레드가 사용
				- 스레드 별 개별 stack이 존재
			- heap
				- 스레드의 공용공간 많은 자원이 필요하다면 heap을 사용함
				- stack보다 heap의 용량이 더 큼 (stack = 1MB , heap = GB이상)
		- 커널
			- 운영체제의 핵심
			- 기능
				- 입출력 제어
				- 자원 관리
				- 접근 통제 (이 기능 가장 큼 )
			- User mode 와 kernel mode
				- H/W는 물리적, S/W는 논리적(가상)
				- User mode
					- 어플리케이션 프로세스 모두 여기서 실행됨
					- 해당 모드의 프로세스가  kernel에 요청하기 위해서는 매개체를 거쳐야함.
					  (**그 매개체가 파일이다**)
					- **파일**을 통해 프로세스는 Read, Write, Excute를 하며 커널에 요청
				- kernel mode
					- ![[Pasted image 20240317115649.png]]
					- 운영체제는 해당 모드에서 실행됨
					- H/W에 의존적이며 다른 것들이 작동될 수 있게 인프라가 되어줌 (H/W장치의 스펙에 따라 운영체제의 버전이 달라져야함)
					- User mode의 프로세스에게 요청받은 내용들을 H/W와 연결(Device 드라이버)하여 제어하며 처리함 (화면에hello world 출력하는 것도 마찬가지) 
					- kernel mode의 파일 시스템
						- 매개체인 파일들을 관리하며 정리하여 GUI로 보여주는 역할
					- kernel mode의 파일 시스템과 디바이스 드라이버 사이에 감시 엔진을 통해 해당 요청파일의 문제 여부를 판단
		- H/W를 S/W로 구현하는 것을 가상화라고 하며 오늘날 클라우드 컴퓨터를 뜻함
		- 가상 메모리
			- 페이지
				- 메모리를 채우고있는 하나의 단위 
			- RAM과 HDD를 섞어서 프로세스마다 가상 메모리 공간을 생성
			- 프로세스가 실행할 때 메모리를 사용하지만 실제 메모리가 아닌 가상의 메모리를 사용한다. 운영체제는 그 가상메모리를 활용하여 할당된 메모리를 확인하고 진짜 멤모리 또는 HDD의 메모리에 매핑하여 관리함
			- 일반적으로 RAM에는 실행중인 프로세스들이 할당된다. 하지만 메모리가 꽉찬다면 더이상 다른 일을 할 수 없게 되지만 HDD의 일부 영역을 RAM처럼 사용하여 메모리 용량을 오버해도 프로세스들이 실행될 수 있게 함 (HDD로 실행중인 프로세스들은 느림)
			- 운영체제에서 메모리를 관리할 때 메모리가 꽉찬 경우, 현재 메인으로 실행중인 프로세스는 RAM에 그렇지 않은 프로세스는 HDD로 잠시 보내고 다시 HDD로 보낸 프로세스가 메인으로 사용되면 RAM으로 돌아와 프로세스를 실행
			  (이때 RAM => HDD 를 page-out)
			  (이때 HDD => RAM 를 page-in)
			- 사용이유
				- 각 프로세스 메모리 공간을 완벽하게 분리 통제 가능
				- 프로세스 오류가 난 경우 가상메모리를 사용하고 있기에 다른 프로그램에 영향을 미치지 않음 
				- 메모리가 부족해도 여러 프로그램을 작동할 수 있음
			- 단점
				- 빈번한 HDD 읽기,쓰기가 일어남
				- page가 스왑되면서 잠시 모든 프로그램이 멈춤
			- 
	- 프로그래밍
		- 일의 진행순서를 정하는 것이 프로그래밍이다.
		- **일하는 절차에 대한 글쓰기**
		- 고급어와 저급어
		- 고급어
			- 유저와 가까울수록 고급어
			- 인간의 언어와 유사해짐
		- 저급어
			- 기계어 (기계에게 명령을 내리는 코드)
			- H/W에 가까울수록 저급어
		- 컴파일 방식
			-  한 파일에 대해 고급어에서 저급어로 머신을 통해 번역하고 난 다음 실행하는 방식
			- Native언어
				- 운영체제에 의존하여 CPU(머신)에 컴파일
				- 운영체제마다 만들어야함
		-  인터프리터 방식
			- 한줄씩 고급어를 저급어로 버츄얼머신을 이용하여 변역 후 실행하는 방식
			- 성능은 컴파일러방식보다 느림
			- managed언어
				- 운영체제에 의존하지않고 CPU를 가상화(버추얼머신)하여 버츄얼머신이 대행하여 컴파일
		- API와 SDK
			- API : Application Programming Interface (여기서 interface는 하나의 코드 묶음(함수)단위)
			- 호출하여 사용함
			-  SDK : Software Development Kit
				- 어느 특수한 목적으로 모아놓은 함수 묶음
				- 공구 : API , 공구세트 : SDK
	- 자료구조
		- 알고리즘 : 깨끗이 정리하는 규칙
			- 구조화된 자료에서 원하는 것을 빨리 찾아내는 방법
		- 자료구조 : 일정규칙으로 자료를 나열하는 것
			- 선형구조
				- 1차원적 구조
				- 자료가 늘어날수록 자료를 찾는데 시간이 많이 걸림
				  (일일히 하나씩 찾음)
				- stack
					- LIFO
					- 사용예시
						- 뒤집기 : 전부 넣었다가 빼면 순서가 뒤집어져 있음
						- 되돌아가기 (Cntr+ Z)
				- Queue
					- FIFO
					- 줄을 서고 있는 형태
					- 사용예시
						- 은행 창구
						- 동기화할 때 
			- 비선형구조
				- 2차원적 구조
				- 선형구조에 비해 속도가 압도적으로 빠름
				- 선형구조에 비해 자료를 찾을 때 비교하는 횟수가 줄어듬
				- 2진트리
					- ![[Pasted image 20240317145201.png]]





















