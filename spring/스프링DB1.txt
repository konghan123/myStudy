1. JDBC
- 과거에 DB마다 연결하는 방법이 달랐고
  포맷이 달랐다. 그래서 DB마다 연결, Sql전달, 결과 받는 방법을 각각 배워야했다.
  그래서 자바에서는 모든 데이터 베이스에 접속할 수 있게
  표준 인터페이스를 만들게 되는데 그것이 JDBC이다.   
  그래서 각각 DB들은 JDBC인터페이스에 맞게 구현해서 라이브러리로
  제공하는 것이 JDBC드라이버라고 한다
- 연결(connection), sql전달(statement), 결과 응답값(ResultSet)

- 하지만 sql의 경우 각각의 데이터베이스에 맞는 쿼리를 적용해야한다는
   한계점이 존재

** 데이터베이스 커넥션 연결은 주로 TCP/IP로 연결

- JDBC를 직접 사용해도 되지만 사용방법이 복잡하다
  그래서 JDBC를 편리하게 사용하기 위해 sqlMapper와 ORM기술이 등장

- sqlMapper
-- 장점
--- JDBC를 편리하게 사용하도록 도와줌
--- 응답결과를 객체로 편리하게 변환
--- sql만 알면 금방 배워서 사용가능
-- 단점
--- sql을 직접 작성

- ORM
-- 객체를 관계형 데이터베이스테이블과 매핑해주는 기술

-- 개발자 대신 sql을 동적으로 만들어 실행해줌

--장점
--- sql을 작성하지 않아도됨
--- 데이터베이스마다 다른 sql을 사용하는 문제를 해결
-- 단점
--- 깊이있는 학습이 필요

- JDBC 사용하기

-- DB연결하기

-- DriverManager.getConnection(URL, USERNAME, PASSWORD)
    해당 구문으로 드라이버연결하여 DB연결

-- 받은 DB드라이버 라이브러리에 따라 해당 드라이버의 
    Connection 인터페이스 구현체를 제공하여 연결시킴  

-- 만약 드라이버가 여러개의 경우
    URL정보에서 "jdbc:데이터베이스" 를 통해 해당 DB드라이버에 
    연결하여 커넥션을 반환함
    처리할 수 없으면 다음 드라이버 순서를 넘김

-- DB에 INSERT하기
--- String으로 sql문 짜고 Connection객체를 들고와서
    그 객체로 prepareStatement() 객체를 들고옴
    그리고 sql문의 ? 부분에  prepareStatement객체.set타입(?순서, 값)
    을 통해 sql값 세팅 그 후 executeUpdate()로 DB에 sql을 넘겨서 값을 받음

--- 이후 prepareStatement, Connection순으로 객체를 닫아줘야함!
    (반드시 finally에서 호출)

-- DB에서 SELECT하기

--- String으로 sql문 짜고 Connection객체를 들고와서
    그 객체로 prepareStatement() 객체를 들고옴
    그리고 sql문의 ? 부분에  prepareStatement객체.set타입(?순서, 값)
    을 통해 sql값 세팅 그 후 ResultSet을  prepareStatement를 통해 불러와서
    rs.next()로 한번 넘어가 쿼리에 대한 값을 불러오고
    그 값들을 DTO에 담는다!

--- ResultSet
---- select 쿼리 결과가 들어가 있음
---- ResultSet 안에는 커서가 존재하여 rs.next()하면
      커서가 다음으로 이동한다
      (최초의 커서는 데이터를 가르키지 않기에 rs.next()를 한번 해줌)


2. 커넥션 풀

- 디비 커넥션 획득 과정
-- 애플리케이션 로직은 DB 드라이버를 통해 커넥션을 조회한다. 
-- DB 드라이버는 DB와 TCP/IP 커넥션을 연결한다. 물론 이 과정에서 3 way handshake 같은 TCP/IP 연결을 위한 네트워크 동작이 발생한다. 
-- DB 드라이버는 TCP/IP 커넥션이 연결되면 ID, PW와 기타 부가정보를 DB에 전달한다. 
-- DB는 ID, PW를 통해 내부 인증을 완료하고, 내부에 DB 세션을 생성한다. 
-- DB는 커넥션 생성이 완료되었다는 응답을 보낸다. 6. DB 드라이버는 커넥션 객체를 생성해서 클라이언트에 반환한다.

- 획득 과정의 문제점
-- 매번 커넥션을 생성해야하므로 매번 리소스 소모
-- 커넥션 만드는 시간이 필요하므로 응답 시간 증가

- 커넥션풀
-- 커넥션을 미리 생성해두고 그 커넥션을 관리하는 방식
-- DB드라이버를 통해 새로운 커넥션을 얻는 것이 아닌 커넥션 풀에서 
    커넥션 객체를 반환받음

- DataSource
-- 커넥션을 획득하는 방법을 추상화한 인터페이스이다.
-- 커넥션풀, 드라이버에 직접의존하지 않고 해당 인터페이스에 의존하여
    커넥션 풀 구현 기술을 변경하고 싶다면 해당 구현체를 갈아끼우면됨
-- 스프링에서는 해당 DataSource를 지원해줌
    (DriverManagerDataSource)
    처음 객체를 생성할때만 파라미터를 넘기고 커넥션을 획을할땐
    메서드만 호출하면됨 (설정과 사용을 분리함)


3. 트랜잭션

- 데이터베이스를 쓰는 이유는 트랜잭션을 지원하기 때문

- 트랜잭션이란? 하나의 거래를 안전하게 처리하다록 보장해주는 것

- 커밋 -> 모든 작업을 성공해서 데이터베이스에 정상 반영한 것

- 롤백 -> 작업 중 하나라도 실패해서 거래 이전으로 되돌리는 것

- 트랜잭션 ACID
-- 원자성 : 트랜잭션 내에서 실행한 작업은 마치 하나의 작업인것처럼 모두 성공 또는 모두 실패해야함
-- 일관성 : 모든 트랜잭션은 일관성이 있는 데이터베이스 상탤르 유지해야함 
               (무결성 제약 조건을 항상 만족해야함)
-- 격리성 : 동시에 실행되는 트랜잭션은 서로에게 영향을 미치지 않도록 격리
               (멀티쓰레드때문에 격리성을 완벽히 보장하려면 트랜잭션을 순서대로 실행해야하는데
                문제는 그러면 성능이 매우 나빠짐 그래서 트랜잭션의 격리 수준은 4단계로 나뉨)
--- 트랜잭션 격리 수준 (아래로 갈수록 성능이 느려짐)
---- READ UNCOMMITED - 커밋되지 않은 읽기
---- READ COMMITED - 커밋된 읽기 (보통은 이 단계를 많이씀)
---- REPEATABLE READ - 반복 가능한 읽기 (두번째로 많이 씀)
---- SERIALIZABLE - 직렬화 가능

-- 지속성 : 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야함
               중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을
               복구할 수 있어야함


- 데이터베이스 연결 구조
-- 커넥션이 연결되면 DB세션을 생성해서 트랜잭션을 시작해서 커밋까지 이어짐
-- 커넥션이 만들어진 만큼 세션이 만들어짐

- 트랜잭션 사용법
-- 쿼리를 실행하고 그결과를 반영하려면 Commit을 호출하고 
    반영하고 싶지않으면 rollback명령어를 호출
    (커밋을 호출하기 전까지 임시로 데이터를 저장함)
    (보통 자동 커밋 모드로 설정되어 있음)

-- 임시로 저장된 데이터는 해당 세션만 볼 수 있으며 다른 세션은 확인 불가능하다
    (격리수준 1단계로 지정하면 임시 저장된 데이터도 볼 수 있다)

-- 자동 커밋 
--- 쿼리 실행 직후에 자동으로 커밋을 호출함
--- 커밋, 롤백을 직접 실행하지 않아도 되서 편함
--- 자동으로 커밋이 되기에 트랜잭션 기능을 제대로 실행할 수 없음
--- 설정방법 : SET autocommit true;
                   
-- 수동 커밋 
---  commit; 명령어를 실행해야 변경된 내용이 적용됨
--- 변경을 원치 않으면 rollback;을 통해 되돌림
--- commit, rollback을 안하면 timeout으로 변경 전 내용으로 되돌아감
     (timeout 시간은 설정 가능하다)
--- 설정방법 : SET autocommit false;


4. DB락
-  세션1이 트랙잭션을 시작하고 데이터를 수정하는 동안
   아직 커밋을 하지 않았는데 세션2에서 동시에 같은 데이터를 수정
   하게 되면 트랙잭션의 원자성이 깨지게 됨
   즉, 세션이 트랜잭션을 시작하고 데이터를 수정하는 동안에는
   커밋이나 롤백전까지 다른 세션에서 해당 데이터 수정을 막아야함

- 과정 
-- 한 세션이 트랜잭션을 시작하고 해당 로우에 대한 락을 획득한다.
-- 락을 획득했기에 데이터를 변경할 수 있음
-- 락을 획득한 동안 다른 세션은 해당 로우의 데이터를 변경할 수 없음
-- 커밋을 수행하면 트랜잭션이 종료되고 락을 반납함
-- 락 대기를 하던 세션이 락을 획득함

- 조회 락
-- 일반적인 조회는 락을 사용하지 않지만
    조회하고 있을 때 데이터를 변경하지 못하게 할 수 있다.
    (중요한 데이터를 가지고 복잡한 계산을 수행할 때
     한동안 다른 곳에서 해당 데이터를 건들지 못하게 막음)
-- 사용법 : SELECT FROM 테이블 ...... FOR UPDATE;

5. 스프링 트랜잭션

- 스프링 트랜잭션 추상화
-- 각 기술마다 트랜잭션 메서드가 다르다
    그래서 기술이 변경되면 서비스 로직도 수정되어야하는데
    그걸 의존성 주입을 통해 서비스 로직은 유지되도록 함

-- PlatformTransactionManager이라는 인터페이스를 통해
   트랜잭션 로직을 추상화

-- PlatformTransactionManager의 구현체도 각각 기술마다 스프링에 이미 존재함

-- 사용법

--- transactionManager.getTransaction(트랜잭션데피니션 객체)
     (status값을 반환해줌 -> 커밋, 롤백할때 파라미터로 들어감)
     (트랜잭션을 시작해줌)
--- transactionManager.commit(status)  or rollback(status)
     (커밋, 롤백해줌 자동으로 커넥션 정리도해줌)


- 스프링 트랜잭션 동기화
-- 트랜잭션을 동기화 하는 방법으로는
  메서드에 파라미터로 커넥션을 넘기면되지만
  그렇게 되면 코드가 지저분해지고 커넥션을 넘기는 메서드와
  그렇지 않은 메서드를 중복해서 만들어야하는 단점이 존재

-- 스프링에서 커넥션을 유지하는 방법을 제공함
    (트랜잭션 동기화 매니저 - TransactionSynchronizationManager)

-- 동작방식
--- 트랜잭션매니저가 데이터소스를 통해 커넥션을 만들고 트랜잭션을 시작함
--- 트랜잭션이 시작된 커넥션을 트랜잭션 동기화 매니저에 보관
--- 리포지토리에서 트랜잭션 동기화 매니저에 저장된 커넥션을 꺼내서 사용
     (더이상 파라미터로 커넥션을 전달하지 않아도됨)
--- 트랜잭션이 종료되면 트랜잭션 동기화 매니저에 저장된 커넥션을 통해
     트랜잭션을 종료하고 커넥션도 닫는다.

-- 사용법
--- DataSourceUtils.getConnection(dataSource) 
     (트랜잭션 동기화 매니저를 통해 커넥션을 반환받음)
     (트랜잭션 동기화 매니저가 관리하는 커넥션이 없다면 생성해서 반환)

--- DataSourceUtils.releaseConnection(connection, dataSource);
     (이것을 커넥션을 바로 닫는 것이 아니라 트랜잭션을 사용하기 위해 동기화된
      커넥션은 커넥션을 닫지 않고 그대로 유지해줌)
     (트랜잭션 동기화 매니저가 관리하는 커넥션이 아닌 경우 해당 커넥션을 닫음)

- 트랜잭션 템플릿
-- DB에 접근할 때 늘 같은 패턴이 반복되어서 지저분해짐
    (트랜잭션시작, try, catch, finally, 커밋, 롤백)
   그러한 패턴을 깔끔하게 변경가능하다.

-- 템플릿 콜백 패턴을 활용

-- 스프링에서 TransactionTemplate이라는 클래스를 제공함

-- 사용법

--- 트랜잭션 템플릿은 안에 PlatformTransactionManager가 포함됨
      그래서 해당 클래스를 주입할때 
      new TransactionTemplate(transactionManager);
      이런 식으로 트랜잭션매니저를 넣어줌 (유연성을 위해)

--- 트랜잭션템플릿 객체.executeWithoutResult( (status) -> {
       비즈니스 로직()
     }
     (지저분한 코드 없이 간단하게 DB접근 로직 사용 가능)
     (하지만 여전히 서비스단에 트랜잭션 처리 기술이 포함되어 있다)
     (트랜잭션 AOP로 해결)

- 트랜잭션 AOP
-- 스프링 AOP를 통해 프록시를 도입하여 트랜잭션을 편리하게 처리해줌

-- AOP를 통해 클라이언트는 서비스를 호출 전 프록시를 호출하여
   트랜잭션처리를하고 그 프록시에서 서비스를 호출하여 로직을 진행한다.
   로직이 끝나면 프록시에서 트랜잭션을 종료하여 마무리함

-- 스프링은 트랜잭션 AOP를 처리하기 위한 기능을 제공함

-- 사용법
--- 트랜잭션처리가 필요한 곳에 @Transactional 을 붙여줌
    (메서드 단에 붙이면 해당 메서드만)
    (클래스 단에 붙이면 public의 모든 메서드들)

--- 단, 스프링 AOP를 적용하려면 스프링 컨테이너가 필요함
    즉, 해당 클래스들이 스프링 빈에 등록되어 있어야 사용 가능한 기능이다.
--- 그리고 트랜잭션 AOP는 스프링 빈에 등록된 트랜잭션 매니저를 찾아서
    사용하기 때문에 트랜잭션 매니저를 스프링빈으로 등록해야함
 

6. 스프링 부트의 자동 리소스 등록
- 기존에는 스프링을 사용할 때 데이터소스와 트랜잭션 매니저를
   직접 등록해야했지만 스프링 부트에서는 자동화됨

- application.properties파일에 해당 DB 정보를 넣어서 데이터소스를 자동 등록가능하다
 ex. spring.datasource.url=jdbc:h2:tcp://localhost/~/test 
      spring.datasource.username=sa 
       spring.datasource.password=
  (커넥션풀 관련 설정도 프로퍼티파일로 설정 가능함)
  (기본으로 스프링부트에서 제공하는 데이터소스는 히카리데이터소스이다.)
  (만약 URL정보가 없다면 내장 데이터베이스(메모리 DB)를 생성함
 
- 스프링 부트는 적절한 트랜잭션 매니저를 자동으로 스프링 빈에 등록함
  어떤 트랜잭션 매니저를 선택할지는 등록된 라이브러리를 보고 판단함


7. 자바 예외
- 체크 예외  
-- Exception과 그 하위 예외들(RuntimeException제외)은
   모두 컴파일러가 체크하는 체크예외이다.

-- 체크 예외는 컴파일부터 오류가 발생하여 무조건
    던지거나 잡아야함

- 언체크 예외  
-- Exception 하위의 RuntimeException과 그 하위 예외들은
    모두 컴파일러가 체크하지 않는 언체크예외이다.
                      (런타임 예외라고도 한다)

-- 언체크 예외는 예외를 잡거나 던지지 않아도 된다.
    예외를 잡지 않으면 자동으로 밖으로 던져짐
     (throws 생략 가능)

- 체크 vs 언체크 차이는 예외를 밖으로 던질 때
  선언해야 하냐 안하냐의 차이!

- 예외의 기본 규칙
-- 예외는 해당 메서드에서 잡아서 처리하거나 다른쪽으로 던지거나
    둘중하나이며 해당 예외 하위 예외들도 다 처리됨

- 예외활용

-- 기본원칙 (비즈니스 상 직접 예외를 만들어서 사용할때)
--- 기본적으로 언체크 예외를 사용
--- 체크 예외는 비즈니스 로직상 의도적으로 던지는 예외에만 사용
    (예외를 잡아서 반드시 처리해야할 문제일 때만 체크예외사용)
    (개발 단계부터 체크 예외를 통해 인지할 수 있음)
     (체크 예외의 경우 서비스단이나 컨트롤러단에서 반드시
      체크 예외를 인지하여 던지거나 처리해야하기에 껄끄럽다)

-- 체크 예외의 문제
--- 컨트롤러, 서비스 단에서 결국 인지를 해야한다는 점
--- 인지를 하기 때문에 해당 예외를 의존해야한다는 점
    (ex. java.sql.SQLException -> JDBC가 아니라면 해당 예외가 안뜸)
    (기술을 변경한다면 수정해야할 부분이 많아지고 SOLID워칙을 깸)
    (그러면 최상위 Exception을 선언하면 해결 되지 않나??
     --> 해결이 될 지언정 체크 예외를 선언한 본질이 없어짐
     체크 예외가 발생하도 Exception을 던지기 떄문에 컴파일러 입장에서
     문법이 맞다 판단하여 오류를 발생시키지 않음)

-- 언체크 예외
--- 체크 예외가 발생하면 언체크 예외로 변환하는 작업을 거친다면
    컨트롤러나 서비스단이 해당 예외를 선언할 필요도 없고
    예외에 대한 의존이 사라지게 됨
    (단, 예외를 변환할 땐 기존 예외 스택 트레이스를 포함시켜야함!!
     아니면 예외에 대한 정보를 확인할 때 근본적인 원인을 알 수 없게됨)

8. 스프링 예외 처리

- 체크 예외의 경우 인터페이스 생성 시 문제가 생김
  SQLException의 경우 JDBC기술의 예외인데
  Repository 인터페이스를 생성하여 확장성을 늘릴 때
  체크 예외로 던진 구현체 메서드의 경우 인터페이스에서도
  던진 예외로 선언이 되어야하기에 인터페이스에 해당 예외로
  의존성이 생겨버림
  (구현체의 '예외변환'을 통해 해결)

 
- 스프링 예외 추상화
-- 스프링은 데이터 접근에 대한 수십가지 예외를 정리해서 제공함
    (주키 중복, 문법오류, 데이터정합성 예외 등등)
    (데이터 접근 예외는 모두 런타임 예외이다)

-- Transient의 하위 예외는 동일한 SQL을 다시 시도하면 성공할 가능성 있음

-- 스프링에서는 예외 변환을 제공
--- 사용법
1. SQLErrorCodeSQLExceptionTranslator 선언
2. 해당객체.translate(읽을수있는설명, sql문, 예외)
    


