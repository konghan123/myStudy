- Checksum
	- 검사합
	- 데이터의 오류 여부 확인 방법으로 쓰임
	- 보안성 x (기밀성, 보안성이 없음) -> 이 문제를 해결하기 위해 Hash가 나옴
	- 일정 자릿수를 정하고 범위를 넘는 자리올림은 버려서 자릿수 유지
	- 단반향성을 가지는 함수 (도출되어진 값을 원본 문자열로 복원이 불가능함)
	- 대표적인 예시 : 이름궁합![[Pasted image 20240625215709.png]]
- Hash
	- 단방향성(도출되어진 값을 원본 문자열로 복원이 불가능함)
	- 데이터 무결성을 확보하는데 사용
		- 인증서 검증 (공인인증서)
		- 디지털 포렌식
		- 디지털 서명 (Hash + PKI)
	- 패스워드 단방향 암호화
	- 블록체인
	- 나머지 연산과 비슷함 (나눔자의 값에 따라 도출되는 경우의 수가 정해짐)
	  ex. X % 5 = 0 1 2 3 4         X % 8  = 0 1 2 3 4 5 6 7 8
	- 대표적인 해쉬 알고리즘
		- MD-5 
			- 경우의 수가 적기 때문에 패스워드 암호화에 사용 금지
				- Hash값 길이가 짧기 때문
				- 보통 패스워드 데이터를 해킹했을 때 그 값은 해쉬값이다. 해쉬값은 단방향이기 때문에 복원하여 비밀번호를 찾을 수 없다. 그래서 프로그램으로 모든 경우의 수를 돌려버려서 비밀번호가 무엇인지 찾아냄
				- 하지만 MD-5는 길이가 짧기 때문에 빠르게 찾아버림
				- 그래서 보통 패스워드 해쉬알고리즘은 SHA-256을 많이 씀
				- 패스워드의 경우 SALT값이라는 내부자들만이 아는 값을 패스워드에 추가하여 해쉬화 해버림![[Pasted image 20240625222223.png]]
			- ![[Pasted image 20240625222146.png]]
		- SHA-1
- 대칭키
	- 키 하나로 암호화/복호화를 모두 수행하는 방식
	- 비대칭키보다 대칭키를 쓰는 것이 효율적
	- 대표적으로 AES-128
	- ==XOR==방식으로 연산함 (값이 다를 때 1, 같으면 0)![[Pasted image 20240626212543.png]]
	- 관련단어
		- 평문 : 본래값
		- 키 : 암호화, 복호화를 하기 위한 값
			- 키 값이 길수록 보안성이 올라감
		- 암호문 : 키 값을 연산하여 암호화한 값
	- 암호화한 값을 반대로 계산하면 본래값이 도출됨
	- 키를 어떻게 안전하게 보관하느냐가 관건! (대칭키 인터넷 환경 문제) 
- 비대칭키
	- 키가 두개이며 ==한쌍==의 키가 서로 상호작용함
		- 이 두키 중 하나로 암호화하면 쌍을 이루는 다른 키로 복호화함
	- 보통 두개의 키 중 하나를 공개(퍼블릭키), 나머지 하나를 비공개함(프라이빗키)
	- PKI기술의 근간을 이룸
	-  해당 암호화 키와 Modulus 두개를 퍼블릭 키라고 부름![[Pasted image 20240626213831.png]]
	- 즉, 12^X mode 323 = 65에 대해 X값을 찾는다면 해킹당한것! 하지만 X값은 무수히 크며 그 경우의 수 값을 전수 조사할 수 있는 양자컴퓨터가 나온다면 현재 암호화체계는 무력화될 수 있음
	- 문제점
		- PC가 받은 퍼블릭 키는 서버가 보낸 키인것을 확신할 수 있는가?
			- MITM 공격 기법 (중간자 공격)
				- 서버의 퍼블릭키를 중간자가 탈취후 중간자의 퍼블릭키를 PC에게 줌
				- PC는 그것을 중간자의 퍼블릭키로 암호화
				- 중간자가 암호화된 문서를 탈취하여 중간자의 프라이빗키로 복호화
				- 이때 PC의 세션키에 대한 정보가 탈취당함
				- 그 복호화한 문서를 탈취했던 서버의 퍼블릭키로 다시 암호화 후 전송
				- 서버는 암호화된 문서를 서버의 프라이빗키로 복호화
- 디지털 서명
	- 프라이빗 키로 해시 결과를 암호화하는 것
	- 문서의 위변조에 대해 알 수 있음
	- 무결성은 존재하지만 기밀성은 존재하지 않음
	- 원리
		- 전제 : 컴B는 컴A에게 퍼블릭키를 이미 전달받은것으로 가정
		- 1. 컴A에서 원본문서에 대한 해쉬값을 얻음
		- 2. 얻은 해쉬값을 프라이빗 키로 암호화함 (디지털 서명)
		- 3. 디지털 서명한 값과 원본문서를 컴B에게 전달
		- 4. 컴B는 원본문서에 대한 해쉬값을 얻음
		- 6. 디지털 서명값을 복호화한 해쉬값과 원본문서의 해쉬값을 비교하여 같은지 확인하여 문서가 위변조되었는지 확인
		- 5. 컴B는 디지털 서명한 값을 퍼블릭 키로 복호화함
- 인터넷에서 대칭, 비대칭키 체계
	- 대칭키는 암호화, 복호화를 하나의 키로 진행하기 때문에 키를 안전하게 보내는 것이 중요하지만!! ==인터넷은 퍼블릭한 곳이기 때문에 키가 탈취될 가능성==이 높다. 그래서 대칭키는 인터넷환경와 맞지 않다.
	- 이 대안으로 나온것이 비대칭키다.
		- 전제 : 어떠한 보안통신이 필요할 때
		- 1. PC, 서버 둘다 각자의 퍼블릭키, 프라이빗 키를 생성함
		- 2. PC가 PC의 퍼블릭 키를 서버에게 보냄
		- 3. 서버가 서버의 퍼블릭 키를 PC에게 보냄
		- 4. PC는 받은 서버의 퍼블릭 키로 문서를 암호화해서 보냄
		- 5. 서버는 서버의 프라이빗 키로 받은 암호화된 문서를 복호화함
		- 6. 서버도 PC의 퍼블릭키로 암호화하고 PC는 암호화된 문서를 PC의 프라이빗키로 복호화함
		- ![[Pasted image 20240626221332.png]]
- 대칭, 비대칭키 혼합 사용
	- 대칭키를 사용하였기 때문에 효율이 올라감
	- public한 인터넷 환경에 대칭키 자체를 암호화하였기 때문에 안전함
	- 이때 대칭키를 ==세션키==라고도 부름
	- 세션키는 PC마다 각각 존재( 즉, PC마다 암호화패턴이 달라짐 => 보안성증가 )
	- 원리
		- 1. PC는 대칭키 생성, 서버는 퍼블릭, 프라이빗 키 쌍을 생성
		- 2. 서버의 퍼블릭키를 PC에게 줌 
		- 3. PC는 대칭키로 문서를 암호화하고 서버의 퍼블릭키로 또 암호화하여 서버에 전송
		- 4. 서버는 받은 암호화문서를 프라이빗키로 복호화하고 다시 대칭키로 복호화
	- ![[Pasted image 20240627203550.png]]
- PKI 인증 체계 
	- 받은 퍼블릭 키를 신뢰할 수 있는 체계
	- SSL 인증서
		- 퍼블릭 키에 여러가지 정보와 무결성 판단을 위한 디지털서명을 추가하여 형식을 갖춘 데이터 ( X.509형식 )
		- 디지털서명할 때 쓰이는 프라이빗 키는 CA의 프라이빗 키이다.
	- 키를 매번 생성하는 것은 부하가 크기때문에 인증기관에게 6개월~1년짜리 키를 구매
	- 기관
		- CA (인증기관)
			- PCA하위기관
			- 인증서 발급 및 취소 등 실질적인 업무
			- 대표적으로 yessign, NCA 등이 존재
		- RA(등록기관)
			- 사용자의 신분을 확인하고 CA간 인터페이스를 제공
		- PAA (과학기술정보통신부)
			- 공인인증서에 대한 정책을 결정하고 하위 기관의 정책을 승인
		- PCA(정책인증기관)
			- 루트CA를 발급하며 기본 정책을 수립하는 기관
			- 루트CA
				- 모든 인증서의 기초가 되는 인증서를 보유
	- 원리
		- 생성 원리(서버)
			- 1. 서버가 RA에게 키쌍(인증서)을 구매 요청
			- 2. 절차를 통해 RA 또는 CA를 통해 인증서 생성(기본적으로 CA에서 생성하여 RA에게 줌)
			- 3. 그것을 서버에게 주고 서버에 설치
		- 생성원리(PC)
			- 1. 운영체제와 CA가 제휴하여 운영체제에 ==기관인증서(CA의 퍼블릭 키)==를 넣음
			- 2. 해당 운영체제를 설치한 PC는 그 기관 인증서도 설치됨 (운영체제 보안 업데이트마다 기간인증서를 갱신)
		- 검증 원리
			- 1. PC가 HTTPS통신을 할경우 서버의 퍼블릭키 대신 퍼블릭키를 감싼 인증서를 PC에게 보냄
			- 2. 운영체제를 통해 PC에 설치된 ==기관 인증서(CA의 퍼블릭 키)==를 통해 해당 인증서의 무결성을 검증
			- 3. 이후 PC 세션키를 해당 인증서의 서버 퍼블릭키로 암호화하여 서버에 보냄
			- 
	- ![[Pasted image 20240627213301.png]]