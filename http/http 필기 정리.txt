인터넷 네트워크
클라이언트 - 인터넷 - 서버 
*ip(인터넷 프로토콜) 
>> 주소(클라이언트, 서버의 각각의 인터넷 주소)
>> 클라이언트에서 패킷을 전달(출발지, 목적지, 값)
>> 해당 패킷을 노드한테 던지면서 목적지까지 전달
>> 한계점
- 패킷이 받을 대상이 없어도 패킷을 전송(패킷을 받을 수 있는 상태인지 모름)
- 중간에 노드가 문제가 생겨 패킷이 사라질 수도 있고 순서로 안올 수도있음
  (이 문제를 해결할 수 있는 방법이 TCP방법임)
- 같은 ip가 두개일 경우

*인터넷 프로토콜 스택의 4계층
-애플리케이션 계층 - HTTP, FTP (게임, 프로그램)
-전송계층 - TCP,UDP (OS)
-인터넷 계층 - IP (OS)
-네트워크 인터페이스 계층 (LAN)
[26쪽 참고]
-프로그램에서 데이터를 소켓 라이브러리로 보내고
그것을 TCP정보 생성하면서 감쌈 그리고 그것을 IP패킷으로 
한번더 감싸고 랜카드를 통해서 이동

TCP (전송 제어 프로토콜)
>> TCP를 통해 전송순서, 전송 제어, 검증 정보를 통해 IP문제를 해결
>> 특징
- 연결지향(연결을 확인하고 나서 데이터를 보냄)
1.TCP 3 way handshake (3번의 전송으로 연결확인)(가상으로 연결된것 착각x)
-- 클라이언트는 SYN이라는 메세지를 서버한테 보냄
-- 서버는 SYN+ACK 를 클라이언트한테 보냄
-- 클라이언트는 ACK를 보냄 (요즘엔 ACK보낼때 데이터도 보냄)
-- 그 후 데이터를 보냄 
- 데이터 전달 보증(데이터를 잘 받았다고 서버에서 보내줌)
- 순서 보장( 패킷 순서가 잘못된 것부터 다시 보내라고 요청함)
- 신뢰할 수 있는 프로토콜

UDP
>> 특징
- 보장되는 것없이 단순하고 빠름
- 포트가 추가됨
- 이 메세지가 맞는지 검증

포트 (한아파트(IP)에서 호수(PORT))
>> 할당된 IP에 대해서 여러패킷을 받을 때 패킷을 구분하기 위한 것
>> 전송할때 출발지 IP port, 도착지 IP port를 보냄
>> 보통 HTTP는 80포트 HTTPS는 443포트를 씀

DNS
>>IP는 기억하기 힘듬, 그리고 IP는 변경될 수 있기 때문에 등장
>> 도메인명을 IP주소로 바꿈

URI
>> URL, URN으로 나뉨
[51쪽 참고]
>> 지금은 URL만 쓰임
>>URL -> 리소스가 있는 위치를 지정(위치는 변할 수 있지만 이름은 변하지 않음)
- 프로토콜 (ex. http:)
- 호스트(ex. www.google.con)
- 포트( ex. :443)
--생략 가능하며 생략시 http는80 https는443
- path (ex. /search)
-- 리소스 경로를 말하며 계층적 구조로 이루어짐 (ex. /home/file1.jpg)
- query (ex. ?q=hello&hl=ko)
-- key=value 형태 
-- ?로 시작, &로 추가가능
>>URN -> 리소스에 이름 부여

http란?
>> 텍스트만이 아니라 이미지 영상 파일 모든 형태의 데이털르 전송가능
>> 서버간에 데이터를 주고 받을 때도 대부분 http 프로토콜로 전송 (게임의 경우 TCP로 직접연결함)

>> HTTP 역사
-HTTP/0.9 >> get만 지원
-HTTP/1.0 >> 메서드, 헤더 추가
-HTTP/1.1 >>현재까지 가장 많이 사용!!
-- RFC2068 -> RFC2616 -> RFC7230~7235 (현버전)
-HTTP/2
-HTTP/3

>> 기반 프로토콜
-TCP: HTTP/1.1 (현재 주로 사용)
-UDP: HTTP/3

>> HTTP 특징

-클라이언트 서버 구조
-- 응답 요청 구조
-- 클라이언트는 서버에 요청을 보내고 응답을 대기
-- 서버가 요청에 대한 결과를 만들어서 응답
-- 클라이언트, 서버 각각 독립적으로 개발할 수 있음
    (트래픽이 넘치면 클라이언트는 건들 필요없이 서버만 건들면 됨)

-무상태 프로토콜(스테이스리스)
-- 서버가 클라이언트의 이전 상태를 보존하지 않음
---반대개념 stateful >> 문맥을 보존함
  (stateful, stateless 차이 [89쪽참조])
-- 갑자기 클라이언트 요청량이 증가해도 서버를 대거 투입가능 (유연함)(수평확장유리)
-- 만약 서버1이 장애가 발생했을 경우 서버2가 이어 받아서 진행 가능해짐
-- 상태 유지는 최소한만 사용
-- 한계
--- 상태유지가 필요한 로그인의 경우
--- 데이터를 너무 많이 요청함

-비연결성
-- 요청에 대한 응답만 주고 연결을 끊어버림 
-- 연결을 유지하는 동안 서버의 자원을 소모하기 때문 (서버 부하 증가)
-- HTTP는 기본적으로 연결을 유지하지 않는 모델
-- 초단위 이하의 빠른 속도로 응답
-- 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 작아짐
-- 서바자원을 매우 효율적으로 사용가능(연결만해놓고 요청을 안보내는 상황도 많기 때문)
--한계
--- TCP/IP연결을 새로 맺어야함 (3wh 시간 추가됨)
--- 웹 브라우저를 요청하면 수 많은 자원(HTML, css, js ,이미지) 등을 함께 다운로드받음
-- 요즘은 HTTP 지속 연결 사용 (하나의 연결에 모든 자원들을 요청 및 응답 받음) [110쪽 참고]

-HTTP메세지
-- 요청 메세지 응답메시지 구조는 다름
-- 구조 : start-line, header, emptyline, messagebody [115쪽 참고]
---startline(요청) : request-line = 메서드 + 요청타겟 + http버전
---- 메서드 : 서버가 수행해야할 동작 지정해줌
---- 요청타겟 : 절대경로 + ?쿼리
---startline(응답) : status-line = http버전 + 상태코드
---- 상태코드 : 200(성공) 400(클라이언트요청오류) 500(서버 내부 오류)
---header(요청, 응답) : 필드네임 + : + (띄우기 가능) + 필드밸류
----필드네임은 대소문자 구분하지 않음
---- 용도
----- HTTP전송에 필요한 부가정보를 담음
--- messagebody : 실제 전송할 데이터(byte로 표현가능한 모든 데이터)

-단순함, 확장가능

>> HTTP 메서드
-왜 쓰는가??
--URI 설계할 땐 리소스 식별!!!!
--- 리소스의 의미를 담아야함 
   (미네랄을 캐라 -> 미네랄이 리소스)
[130쪽참고], [135쪽참고], [136쪽참고]
-- 리소스와 행위를 분리해야함 (행위가 바로 HTTP메서드)
--- URI는 리소스만 식별
--- 리소스는 명사 행위는 동사

- 메서드 종류
--GET : 리소스 조회
---서버에 전달하고 싶은 데이터는 query를 통해서 전달
--- 메세지 바디를 전달할 수 있지만 실무에서는 잘 넣지 않음 
--POST : 요청 데이터 처리, 주로 등록에 사용
--- 메세지 바디를 통해 서버로 요청 데이터 전달
--- 서버는 요청 데이터를 처리
---- 모든 기능을 수행 (주로 등록, 프로세스 변경에 쓰임)
--- 요청을 어떻게 처리할 지 따로 정해야함(주로 등록이지 등록만 하지 않는다)
--- 쓰임새정리
---- 새 리소스 생성
---- 요청 데이터 처리(ex. 배달완료) (그래서 POST의 결과로 새로운 리소스가 생성되지 않을 수도 있음)

--PUT : 리소스를 대체, 해당 리소스가 없으면 생성
--- 리소스를 덮어버림(지우고 생성)
--- 클라이언트가 리소스의 위치를 알고 지정해야함! (post와의 차이)
--- 단, 리소스를 완전히 대체함!!(부분대체아님)
--- PUT은 수정하는 느낌이 아님(수정하는 느낌은 PATCH이다)
[153쪽참고][154쪽참고]
--PATCH : 리소스 부분 변경
--- 부분적인 리소스를 바꿀때 (PUT처럼 위치지정필요)
--DELETE : 리소스 삭제
--- 리소스 삭제(PUT처럼 위치지정필요)
--등등 기타 메서드가 존재 [140쪽참고]

-HTTP 메서드의 속성
--안전
--- 호출해도 리소스 변경되지 않음 (GET, head은 안전 나머지는 안전하지않음)
--- 호출해도 변경이 일어나지 않는 것
--- 안전이라는 속성은 리소스만 고려한다! 
--멱등
--- 여러번 호출해도 결과가 같다(GET 조회결과 같음, PUT 대체결과 같음, DELETE 삭제 결과 같음)
--- 단, POST는 멱등이 아님!! (두 번 호출하면 같은 결제가 중복해서 발생가능성이 있음)
--- 활용 (서버가 정상응답을 못했을 때 다시 요청) (어짜피 결과는 같기 때문!)
--- 외부 요인으로 중간에 리소스가 변경되는 것 까진 고려하지 않음)
--캐시가능
--- 응답 결과를 캐시해서 사용 가능한가?
--- GET, HEAD, POST, PATCH 캐시 가능
--- 실제로는 GET, HEAD정도만 사용됨

>>HTTP 메서드 활용

-데이터 전달방식 (2가지)
-- 쿼리 파라미터를 통한 데이터 전송
--- GET (주로 정렬 필터(검색어))
-- 메시지 바디를 통한 데이터 전송
--- POST,PUT,PATCH (리소스등로그 리소스 변경)

-상황
-- 정적 데이터 조회 
--- GET을 사용하며 단순하게 리소스 경로로 조회
-- 동적 데이터 조회
--- GET으 사용하며 쿼리 파라미터 사용해서 데이터 전달
-- HTML Form 데이터 전송
--- Content-type이 application/****from****
--- 전송 데이터를 URL enconding 처리함
--- form 전송은 GET, POST만 지원
-- HTTP API 데이터 전송
--- 서버끼리 통신할때 사용됨
--- 앱 클라이언트에서 사용
--- 웹 클라이언트( Ajax 통신)
--- Content-type이 application/json (표준)

-HTTP API 설계 예시

-- POST vs PUT
--- POST는 클라이언트가 요청하면 서버측에서 자동적으로 리소스를 관리
--- 컬렉션
---- 서버가 관리하는 리소스 저장소
---- 서버가 리소스의 URI를 생성하고 관리
---- 컬렉션 예시 ) /members
--- PUT은 클라이언트가 리소스 URI를 알고있는 상황에서 서버에게 요청(단순히 서버는 클라이언트가 요청하는 대로 진행)
--- 스토어
---- 클라이언트가 관리하는 리소스 저장소
---- 클라이언트가 리소스URI를 알고 관리
--- POST로만 한다면 컨트롤 URI가 필요하게됨 (동사로된 리소스경로)
---- 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스가 있을 경우 쓰임
[참고 1 이미지 참조]


>> HTTP 상태코드

- 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능

- 2xx : 요청 정상 처리 
-- 200 : 요청 성공
-- 201 : 요청 성공해서 새로운 리소스 생성 (응답 데이터에 로케이션이 추가됨)
-- 202 : 요청이 접수되었으나 처리가 완료되지 않음
--- 요청 접수 후 시간이 필요한 경우
-- 204 : 서버가 요청을 성공적으로 수행했지만 응답 페이로드 본문에 보낼 데이터가 없는 경우
--- save 버튼 : save 버튼을 눌러도 같은 화면을 유지할 경우

- 3xx : 요청 완료하려면 추가 행동 필요
-- 리다이렉션 : 웹 브라우저는 3xx응답의 결과에 location헤더가 있다면 해당 location 위치로 자동 이동
-- 안쓰는 페이지의 경우 다른 페이지로 옮겨줄 때 사용됨
-- 리다이렉션 종류
--- 영구 리다이렉션 : 위의 경우
---- 301, 308
---- 301 : 요청 메서드가 GET으로 바뀜 (만약 무엇가 등록한다면 다시 해야함)
---- 308 : 요청 메서드를 유지 
--- 일시 리다이렉션 : 주문 완료 후 주문 내역화면으로 이동하는 경우
---- 302, 307, 303
---- 302 : 리다이렉트 시 요청 메서드가 GET으로 바뀜 (스펙의 의도가 달라져서 밑에 두가지로 또 나눔)
---- 307 : 리다이렉트 시 요청 메서드 유지
---- 303 : 리다이렉트 시 요청 메서드가 GET 변경 (무조건)
---- PRG : Post/Redirect/Get
----- post로 주문 후 새로고침을 하면?? >> 새로고침은 다시 요청이므로 또 주문을 하게 됨
--- 특수 리다이렉션 : 결과 대신 캐시를 사용할 때
---- 304 : 캐시 목적으로 사용, 클라이언트에게 리소스가 수정되지 않았음을 알려주고 로컬 PC의 캐시를 사용하게 함
----- 캐시를 사용하므로 응답에 메세지 바디를 포함하지 않음

- 4xx : 클라이언트 오류 (잘못된 문법등으로 서버가 요청을 수행못함)
-- 클라이언트가 이미 잘못된 요청, 데이터를 보내고 있기 때문에 여러번 재시도 해도 실패함 (서버의 경우는 성공할 수 있음)
-- 400 : 클라이언트가 잘못된 요청을 해서 서버가 요청처리를 못함
-- 401 : 클라이언트가 리스소에 대한 인증이 필요
--- 401 오류 발생 시 응답에 WWW-Aythenticate 헤더와 함께 인증 방법을 설명
--- 인증 : 본인이 누구인지
--- 인가 : 본인이 해당 리소스에 접근할 수 있는지
--- 403 : 서버가 요청을 이해했지만 승인을 거부
---- 인증 자격 증명은 있지만 접근 권한이 불충분할 경우
--- 404 : 요청 리소스를 찾을 수 없음
---- 서버에 요청 리소스가 없는 경우 또는 숨기고 싶은 경우

- 5xx : 서버 오류 (서버가 정상 요청을 처리하지 못함)
-- 서버에 문제로 오류 발생
-- 서버에 문제가 있기 때문에 재시도하면 성공할 수 있음
-- 500 : 서버 내부의 문제로 오류 발생 
-- 503 : 서버가 일시적으로 과부하, 예정작업이 있는 경우 일시적으로 요청을 처리할 수 없음
--- Retry-After 헤더 필드로 얼마뒤에 복구되는지 보낼 수 있음
-- 서버에 문제가 있을 때만 500 에러를 내야함(쿼리,소스의 익셉션 등등) (비즈니스 로직상 오류는 서버 오류가 아님!!)
- 모르는 상태코드가 있어도 상위 상태코드로 해석해서 처리하면 됨!

>> HTTP 헤더

- HTTP 전송에 필요한 모든 부가정보
- 임의의 헤더 추가 가능

- 표현 헤더 : ex) content-type , length 등등
-- 표현 헤더는 표현 데이터의 데이터를 해석할 수 있는 정보 제공 (위 ex처럼)
- 표현 데이터 : 요청이나 응답에서 전달할 실제 데이터

- 표현
-- content-type : 표현 데이터의 형식
-- content-encoding : 표현 데이터의 압축 방식
--- 메세지를 받는 쪽에서 인코딩 헤더 정보로 압축해제함
-- content-language : 표현 데이터의 자연언어
-- content-length : 표현 데이터의 길이
-- 표현 헤더는 응답 전송 둘다 사용됨

- 협상 (콘텐츠 네고시에이션)

-- 클라이언트가 선호하는 표현 요청
-- Accept: 클라이언트가 선호하는 미디어 타입 전달
-- Accept-charset : 클라이언트가 선호하는 문자 인코딩
-- Accept-encoding : 클라이언트가 선호하는 압축 인코딩
-- Accept-language : 클라이언트가 선호하는 자연언어
-- 협상 헤더는 요청시에만 사용됨!!!
--협상 헤더를 이용하여 서버에서 지원하는 기능을 적용할 수 있음 (나라 언어)
-- Quality values(q) [250쪽 참고]
--- q값이 클수록 우선순위이며 0~1값을 가짐
--- 생략하면 1
--- 구체적인 것이 우선한다!!
ex ) text/* , text/plain;format=flowed (우선순위 승) 
--- 구체적인것을 기준으로 미디어타입을 맞춤 [253쪽 참고]

- 전송방식
-- 단순전송 : 컨텐츠 길이만큼 한번에 전송 
-- 압축전송 : 서버에서 압축하여 전송 (content-encoding헤더를 추가해야함)
-- 분할전송 : 용량이 커서 쪼개서 전송(content-length를 넣으면 안됨, Transfer-encoding 헤더를 추가해야함)
-- 범위전송 : content-range헤더를 통해 범위로 데이터를 전송

- 일반정보 : 정보성 헤더
-- From : 유제 에이전트의 이메일 정보 (요청에서 사용)
-- Referer : 이전 웹 페이지 주소 (요청할 때 사용되며 유입 경로 분석에 쓰임)
-- User-Agent : 클라이언트 애플리케이션 정보(웹브라우저 정보) (요청에서 사용)
--- 특정 브라우저에서 장애가 발생하는지 파악 가능 
-- Server : 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보(마지막에 도달하는 서버의 정보) (응답에서 사용)
-- Date : 메세지가 발생한 날짜와 시간 (응답에서 사용)

- 특별정보 
-- Host : 필수값이며 요청에서 사용, 
--- 하나의 서버가 여러 도메인을 처리할때 Host값을 톨해 값에 맞는 도메인의 응답을 줌
-- location : 리다이렉트에 쓰임 (상태코드 3xx, 201)
-- Allow
-- Retry-After

- 인증
-- Authorization : 클라이언트의 인증 정보를 서버에 전달하는 헤더
-- WWW-Authenticate : 401오류 시 응답할 때 해당 헤더를 넣어주어야함

- 쿠키
-- 모든 요청에 정보를 넘기는 문제를 해결하기 위해
-- 서버에서 쿠키값을 웹브라우저 쿠키 저장소에 저장시키고(Set-Cookie를 통해) HTTP요청했을 때 쿠키저장소를 참조하여 쿠키값찾아서 Cookie헤더가 추가함) 
    (즉, 자동으로 쿠키정보가 무조건 포함됨 => 네트워크 트래픽 증가)
-- 쿠키 관련 헤더
--- Set-Cookie : 응답 쿠키 전달
--- Cookie : 클라이언트가 서버에서 받은 쿠키 저장, HTTP 요청시 서버에 보냄
-- 주 사용처는 사용자 로그인 세션처리할 때 많이 사용
-- 만약 서버에 전송하지 않고 웹 브라우저 내부에 저장하고 싶은 값이 있다면 웹 스토리지를 활용한느 것이 좋다
-- 쿠키의 생명주기
--- Set-Cookie expires : 만료일이 되면 쿠키삭제
--- Set-Cookie max-age : 해당 초가 지나면 삭제 (0, 음수 지정시 쿠키 삭제) 
-- 쿠키의 도메인
--- ex) domain=example.org
--- 기준 도메인 + 서브 도메인 포함됨
     (위 예시는 example.org는 물론 dev.example.org도 쿠키 접근가능해짐)
--- 생략 시 서브 도메인은 접근 못함
-- 쿠키의 경로
--- ex) path=/home
--- 이 경로를 포함한 하위 경로 페이지만 쿠키 접근가능
--- 일반적으로 루트로 지정함
-- 쿠기의 보안
--- Secure : https의 경우에만 전송
--- HttpOnly : 자바스크립트 단에서 쿠키 접근 불가능
--- SameSite : 요청 도메인과 쿠키에 설정된 도메인이 같은 경우만 쿠기 전송

>> 캐시
- 캐시를 사용하지 않는다면 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 받아야함 (느림)
- 기본 동작
-- 응답 결과가 브라우저 캐시에 저장되고 HTTP요청을 보낼 때 해당 요청이 캐시에 있는 내용이면 브라우저 캐시에서 꺼냄
-- HTTP 헤더에 캐시 유효시간을 넣어 줄 수 있음(cache-control)

- 검증 헤더와 조건부 요청
-- 방법1
--- 캐시 유효 시간이 지나서 서버에 다시 요청했을 때 
    서버의 데이터와 캐시 데이터가 변함이 없는 경우 검증 헤더를 통해 검증 후 변함이 없다면 만료된 캐시 사용 가능
--- Last-Modified(검증헤더)라는 응답 헤더를 추가해서 클라이언트에 보내면 다시 요청할 때 해당 헤더값(최종 수정일)이 있으면
     if-modified-since(조건부요청)라는 요청 헤더를 서버에게 보내서 데이터를 비교함
     그러면 서버에서 304 Not Modeified 상태코드와 함께 HTTP헤더 값만 보내서 캐시 갱신 (바디를 안보내기에 빠름) 
--- 한계
---- 1초 미만 단위로는 캐시 조정 불가능
---- 같은 데이터를 수정해서 데이터 결과가 똑같은 경우 (A->B->A)
---- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우 (주석이나 스페이스 수정)
-- 방법2
--- 캐시 데이터에 임의의 고유한 버전 이름을 달아둠
--- 데이터가 바뀌면 버전 이름을 바꾸어서 변경
--- ETag(검증헤더)라는 응답 헤더를 추가해서 클라이언트에 보내면 다시 요청할 때 해당 헤더값(버전 이름)이 있으면
     if-None-Match라는(조건부요청)라는 요청 헤더를 서버에게 보내서 데이터를 비교함
     그러면 서버에서 304 Not Modefied라는 상태코드와 헤더만 보냄
--- 즉, ETag(검증헤더)를 보내서 같으면 유지, 다르면 다시 받기
--- 캐시 제어 로직을 서버에서 관리하게 됨

- 캐시 헤더
-- cache-control
--- cache-control : max-age -> 캐시 유효시간 
--- cache-control : no-cache -> 데이터는 캐시하지만 무조건 서버에 검증하고나서 사용
--- cache-control : no-store -> 민감한 정보가 있으므로 저장하면 안됨
--- cache-control : public -> 응답이 public 캐시에 저장 가능
--- cache-control : private -> 기본값으며 응답이 해당 사용자만을 위한 것( private 캐시에 저장해야함) )
--- cache-control : s-maxage
-- Expires : 만료일을 지정 할 수 있음 (expires는 잘 안쓰임)

- 프록시 캐시
-- 프록시 캐시 서버(public)를 두어 원서버까지 가지 않고 중간 프록시 서버에서 응답을 해줌! (응답 속도 증가)
 
- 캐시 무효화
-- 웹 브라우저가 임의로 캐시하는 경우가 있음 하지만 캐시하면 안되는 경우가 존재함  
-- cache-control : no-cache, no-store, must-revalidate (캐시 무효화 방법)
--- cache-control : must-revalidate -> 캐시 만료 이후 최초 조회 시 서버에 검증하고나서 사용 
     (검증을 위한 원서버 접근이 불가능 할 경우 무조건 오류를 발생시킴)
     




















































