1. 쓰레드 로컬
- 해당 쓰레드만 접근할 수 있는 특별한 저장소

- 그래서 지역변수가 아닌 전역변수에 값이 변경하여도
  해당 쓰레드만 쓰는 저장소이기에 구분이 됨

- 쓰레드 로컬을 모두 사용했으면 반드시 
  ThreadLocal객체.remove()을 통해 해당 저장소 값을
  제거해주어야함
  (WAS는 쓰레드를 쓸때 쓰레드 풀에서 해당 쓰레드를 가지고
   프로세스를 실행하는데 만약 해당쓰레드로컬값을 지우지 않은 경우
   쓰레드풀에서 쓰레드를 불러올때 해당 쓰레드로 할당되는 경우
   쓰레드로컬에서 이전에 들고있는 값을 그래도 사용하면서
   데이터의 문제가 생길 수 있다
   ex. A사용자가 사용 이후 B사용자가 해당 쓰레드로 할당이 되었는데
        조회하면서 해당 쓰레드로컬의 값을 불러오는데 
        쓰레드로컬값을 삭제하지 않았으므로 A사용자의 데이터를
        보여주게 됨
   )

- 사용법
-- 변경되는 필드 값에 대해
    ThreadLocal<해당 필드 타입> 이름 = new ThreadLocal<>();
    선언

-- 해당값을 저장할땐 ThreadLocal객체.set(넣을값)
    해당값을 불러올땐 ThreadLocal객체.get()
    해당값을 지울땐 ThreadLocal객체.remove()


2. 템플릿 메서드 패턴
- 핵심기능과 부가기능을 분리할 수 있는 디자인 패턴이다.

- 변하는 핵심기능과 변하지 않은 부분을 따로 분리하여 모듈화

- 상속을 사용하기 때문에 자식클래스와 부모클래스가 컴파일시점에서
   강하게 결합되며 해당 템플릿 메서드 패턴은
   자식클래스 입장에서는 부모클래스의 기능을 다 사용하지 않는다
   부모 클래스가 변하면 자식클래스도 영향을 받음
   상속 자체가 단점이 됨

- 원리
-- 상속 받을 추상 클래스를 하나 만들고
    핵심기능이 들어갈 로직의 메서드를 만드는데
    추상 메서드로 만듬
    (해당 추상 클래스를 상속받은 클래스에서 직접 기능 구현)

--  부가기능 로직에 대한 메서드를 만들어서 
     해당 핵심기능이 들어가는 추상메서드를 넣어준다.
    그렇게 해서 상속받은 클래스에서는 해당 부가기능 메서드를
    사용
    (이러면 매 로직마다 클래스로 나누어서 만들어야하지 않나?
     >> 익명 내부 클래스를 이용해 매번 클래스를 만들 필요는 없음
    ex.) AbstractTemplate template1 = new AbstractTemplate() {        
          	@Override        
           	protected void call() {            
           	       log.info("비즈니스 로직1 실행");       
           	}   
          };
     즉, 굳이 상속받을 클래스를 만들 필요 없이 
     익명 내부 클래스를 만들어 적용시킴

3. 전략 패턴
- 변하지 않는 부분(context), 변하는 부분(strategy)로 나누고
   strategy라는 인터페이스를 만들고 context클래스에 변하지 않는 로직을 넣어
   그 사이에 strategy넣고 strategy를 의존성주입을 구현체를 외부에서 받아서 사용
   상속을 사용하지 않아 강한 결합이 없어짐
   
- 전략을 필드가 실행메서드의 파라미터로 받아서 
  메서드에 해당 파라미터로 전략을 받아
  선조립할 필요없이 실행할때마다 전략을 바꿀 수 있어서
  유연하게 됨. (람다 사용)
  (이렇게 사용한는 것을 스프링에서 템플릿 콜백 패턴이라고 함)
  (xxxTemplate이라고 되어있다면 템플릿 콜백패턴으로 만들어져있음) 

   

       
         