1. SELECT 연산 고급 활용

- 쿼리 논리 처리 순서
-- FROM >> JOIN >> WHERE >> GROUP BY
   >> HAVING >> SELECT 컬럼 >> ORDER BY

- BATCH란?
-- 한번에 1개 이상의 쿼리를 실행하는 것을 1BATCH
-- 로컬변수는 동일한 Batch 내에서만 참조 가능
-- 동일한 Batch에서 변경된 개체는 비인식
-- Compile 오류 시 Batch전체 취소
-- Runtime 오류 시 대부분 Batch 중단
    (제약 조건 위반은 현재 구문만 취소, 나머지 실행)

-- 배치 지시어
--- GO ( SSMS같은 SQL Server 유틸리티에서 지정해 사용 가능
--- GO[count] : 현재 배치를 [count]만큼 반복 수행

-- EXEC
--- 여러 프로시저를 한 배치에 실행시킬 때 구문 앞에 EXEC를 넣어줌

- SELECT-LIST 속성,동작 이해
-- SELECT 컬럼에 변수를 할당한 경우 변수값 처리는
   순차적으로 일어남
   (앞 컬럼에서 변수에 +1해줬다면 이후 컬럼에서 해당 변수를
    참조할 때 +1된 변수 값을 참조함)

-- SELECT에서 변수 할당과 검색을 동시에 불가능하다.

-- 스칼라변수의 값이 다중일 경우 마지막에 참조된 값이 참조됨

- 데이터 유형과 함수

-- 숫자

--- bit 
---- 0,1, null 값을 가짐
---- 문자, 숫자는 다 1
---- false이면 0, true이면 1

--- 정수
---- tinyint(1byte), smallint(2byte), int(4byte), bigint(8byte)

--- 실수
---- 고정 소수점 (decimal(값, 소수점) , numeric())

---- 부정 소수점 (float(8byte), real(4byte))
----- 정확한 숫자가 필요한 일반 업무에서는 비권장함

---- 통화 데이터 (money(8byte), smallmoney(4byte))
----- 일반적으로 잘 안쓰임 숫자에 FORMAT함수를 씀

---- 반올림, 올림, 내림
----- 특정 자리수 반올림 (ROUND(값, 자리수))
----- 특정 자리수 올림 (ROUND(값 + 가중치(0.4), 자리수))
----- 특정 자리수 내림 (ROUND(값, 자리수, 1))

----- 정수 올림 (CEILING())
----- 정수 내림 (FLOOR())

---- 0숫자로 채우기 (RIGHT(CONCAT(), REPLACE(STR()))

-- 문자

--- 고정길이 (char(일반문자), nchar(유니코드))
---- 선언 크기 만큼 공간(공백)을 차지 
---- 후행 공백이 생김

--- 가변길이 (varchar(일반문자), nvarchar(유니코드))
---- 후행 공백은 명시적으로 지정 시 생김

-- 날짜시간
--- DATETIME(8byte), SMALLDATETIME(4byte)

--- DATETIME2(소수자리수 -7까지 표현)

--- 월별 일수 구하기
---- EOMONTH(날짜) 당월 
---- EOMONTH(날짜, -1) 전월
---- EOMONTH(날짜, 1) 명월
---- DATEPART(DAY, EOMONTH(날짜)) 일자 구하기



-- 새로운 함수들
--- TRY_CONVERT() : 데이터 형변환 시 사용되며 실패 시 오류 대신 NULL 반환
--- TRY_PARSE() : 문자열 데이터형 변환 시 사용되며 실패 시 오류 대신 NULL 반환
--- CHOOSE (index, value1,value2 ...) : 나열 중 지정한 index값 반환
--- FORMAT(값, 포맷형식, 유니코드)

- NULL의 이해

-- 할당되지 않는 값

-- NULL 연산시 무조건 NULL

-- NULL은 비교연산이 불가 IS NULL, IS NOT NULL 만 가능

-- NULL의 IN, NOT IN
--- IN 의 경우 해체하면 a =  1 or a = 2 or a = null 인데
    a = null인 부분을 무시함

--- NOT IN의 경우 해체하면 a <> 1 and a <> 2 and a <> null
    NULL을 and로 결합하기 때문에 값이 없음
    (NOT IN 안에 서브쿼리가 올때 NULL값이 올 수 있다면 절대 NULL로 올 수 없게 처리해야함)

-- NULL은 최솟값으로 취급

-- 구문
--- ISNULL(값, 대체 값) >> 값이 NULL일 때 대체 값으로 매핑 
     
--- COALESCE(값, 값, 값) >> NULL이 아닌 첫번째값을 반환
    (중첩 CASE를 없앨 수 있다)

--- NULLIF(값, 값) >> 동일한 값이면 null, 아니면 첫번째값 반환
    (아닌 값 반환하기 좋음)

- CASE 문
-- 행 단위 조건 처리 유리

-- 주의 사항
--- THEN절에서 서로 다른 데이터 형을 반환하는 경우
---- 암시적으로 작은 타입을 큰타입의 형으로 맞추기 때문에 데이터 정합성 문제가 생길 수 있음
     (1 + '2' 는 3이라는 결과가 나옴)

--- ELSE 절이 없는 경우 NULL 반환

-- CASE문 평가 전에 내부 식이 먼저 계산되는 경우
    (WHEN,THEN절에 함수가 있을 경우 먼저 실행됨) 

- TOP(n)
-- 상위 n개만 표시
-- ORDER BY에 영향을 받음 (동률값에 대한 정리 필요!)
-- 클러스터 인덱스가 있어도 ORDER BY를 써야함

- 난수처리
-- RAND(seed) >> 부동소수점, 동일 seed에 동일결과
   (seed값 없이 사용하면 0~1사이 난수 리턴)
   (행단위가 아닌 쿼리단위로 한번 호출됨)
-- NEWID() >> 랜덤으로 고유값을 생성

2. DML (data mutipulation language )

- VALUES (테이블 값 생성자)
-- 테이블 입력으로 사용됨

-- 용도
--- FROM() 파생테이블 ex. ( FROM(VALUES (1),(2),(3) ) )
--- INSERT... VALUES
--- MERGE의 USING

- INSERT, UPDATE, DELETE + TOP()
-- 변경될 데이터 갯수를 제한할 수 있다.

- UPDATE SET절 고급 활용
-- UPDATE 테이블 SET @변수 = 값 = 연산식  
  (이런식으로 사용 가능)

-- UPDATE 테이블 SET
    , 값1      = 값2
    , 값2      = 값1
    (이런식으로 값 교환 가능) 

- INSERT, UPDATE, DELETE + OUTPUT
-- 문법 : OUTPUT , deleted / inserted / 테이블이름 + . + 컬럼이름
         (OUTPUT에 명시값도 지정 가능 ex. ' ', 2, 'ㅇㅇ'

-- 변경(전/후) 행 데이터 반환

-- 테이블 입력 후 재활용 가능

- Composable DML 
-- OUTPUT 결과를 테이블 입력으로 사용

ex. INSERT INTO 테이블1(output값1,output값2,output값3)
    SELECT output값1,output값2,output값3
    FROM(
             UPDATE 테이블2
                   SET  a = b
             OUTPUT 
                  inserted.output값1 as output값1,
                  deleted.output값2 as output값2,
                  inserted.output값3 as output값3
     ) D

- INSERT + EXEC
-- INSERT 테이블 
       EXEC 테이블을 호출하는 프로시저, 동적테이블


                  







